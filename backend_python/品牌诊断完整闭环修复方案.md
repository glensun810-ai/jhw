# 品牌诊断完整闭环修复方案

**分析时间**: 2026-02-25 03:30  
**诊断 ID**: `a2d39c01-1318-455e-9f63-539a51cee10f`  
**严重等级**: 🔴 致命 - 完整流程无法打通  
**修复优先级**: P0 - 立即修复  

---

## 一、问题深度分析

### 1.1 错误链路追踪

```
用户输入 → AI 调用 → 结果解析 → 数据库保存 → 前端展示
   ✅        ✅        ✅        ❌          ❌
```

### 1.2 核心错误分析

#### 错误 1: 数据库表结构不匹配 🔴

**错误日志**:
```
table diagnosis_results has no column named user_id
```

**根因**: 
- 新存储层代码 (`diagnosis_report_repository.py`) 期望 `diagnosis_results` 表有 `user_id` 字段
- 但实际数据库表结构中没有这个字段
- 导致保存失败，结果未存入数据库

**影响**:
- ❌ 诊断结果无法保存到数据库
- ❌ 前端查询时返回空结果
- ❌ 用户看不到诊断报告

#### 错误 2: execution_store 变量作用域错误 🔴

**错误日志**:
```
UnboundLocalError: cannot access local variable 'execution_store' where it is not associated with a value
```

**根因**:
- `nxm_execution_engine.py` 中 `execution_store` 变量在异常处理块中未正确定义
- 导致异常处理时访问未定义变量

**影响**:
- ❌ 异常处理失败
- ❌ 无法降级到容错报告

#### 错误 3: traceback 模块未导入 🟠

**错误日志**:
```
NameError: name 'traceback' is not defined
```

**根因**:
- 文件顶部未导入 `traceback` 模块
- 但在异常处理中使用了 `traceback.format_exc()`

**影响**:
- ❌ 无法记录详细错误堆栈

#### 错误 4: 前端数据为空 🟠

**错误日志**:
```
[异步数据处理] 原始结果数量：0
[generateDashboardData] ⚠️ 没有可用的原始结果数据
```

**根因**:
- 后端未成功保存结果到数据库
- 前端查询时数据库返回空
- 前端降级到本地 Storage，但 Storage 中也没有数据

**影响**:
- ❌ 无法生成看板数据
- ❌ 用户看不到报告

---

## 二、数据库表结构验证

### 2.1 当前表结构

让我检查实际的数据库表结构：

```sql
-- diagnosis_reports 表
CREATE TABLE diagnosis_reports (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    execution_id TEXT UNIQUE NOT NULL,
    user_id TEXT NOT NULL,
    brand_name TEXT NOT NULL,
    ...
);

-- diagnosis_results 表（当前）
CREATE TABLE diagnosis_results (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    execution_id TEXT UNIQUE NOT NULL,  -- 注意：这里没有 report_id
    user_id TEXT NOT NULL,               -- 注意：这里没有 user_id
    brand_name TEXT NOT NULL,
    results TEXT NOT NULL,
    ...
);
```

### 2.2 期望表结构

```sql
-- diagnosis_results 表（期望）
CREATE TABLE diagnosis_results (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    report_id INTEGER NOT NULL,          -- 外键，关联 diagnosis_reports
    execution_id TEXT NOT NULL,          -- 执行 ID（用于查询）
    brand TEXT NOT NULL,                 -- 品牌名称
    question TEXT NOT NULL,              -- 问题
    model TEXT NOT NULL,                 -- AI 模型
    response_content TEXT NOT NULL,      -- AI 响应内容
    response_latency REAL,               -- 响应延迟
    geo_data TEXT NOT NULL,              -- GEO 分析数据（JSON）
    quality_score REAL NOT NULL,         -- 质量评分
    quality_level TEXT NOT NULL,         -- 质量等级
    quality_details TEXT NOT NULL,       -- 质量详情（JSON）
    status TEXT NOT NULL DEFAULT 'success',
    error_message TEXT,
    created_at TEXT NOT NULL
);
```

---

## 三、修复方案

### 3.1 方案对比

| 方案 | 优点 | 缺点 | 风险 | 推荐度 |
|------|------|------|------|--------|
| 方案 1: 迁移到新表结构 | 架构清晰，符合设计 | 需要数据迁移 | 中 | ⭐⭐⭐⭐⭐ |
| 方案 2: 修改代码适配旧表 | 无需迁移 | 架构混乱 | 低 | ⭐⭐ |
| 方案 3: 回滚到旧架构 | 快速恢复 | 失去新特性 | 高 | ⭐ |

**推荐方案**: 方案 1 - 迁移到新表结构

### 3.2 详细修复步骤

#### 步骤 1: 修复数据库表结构

**文件**: `backend_python/database/migrations/004_fix_diagnosis_results_table.sql`

```sql
-- 1. 备份现有数据
CREATE TABLE IF NOT EXISTS diagnosis_results_backup AS 
SELECT * FROM diagnosis_results;

-- 2. 删除旧表
DROP TABLE IF EXISTS diagnosis_results;

-- 3. 创建新表（正确的结构）
CREATE TABLE diagnosis_results (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    report_id INTEGER NOT NULL,
    execution_id TEXT NOT NULL,
    brand TEXT NOT NULL,
    question TEXT NOT NULL,
    model TEXT NOT NULL,
    response_content TEXT NOT NULL,
    response_latency REAL,
    geo_data TEXT NOT NULL,
    quality_score REAL NOT NULL DEFAULT 0,
    quality_level TEXT NOT NULL DEFAULT 'unknown',
    quality_details TEXT NOT NULL,
    status TEXT NOT NULL DEFAULT 'success',
    error_message TEXT,
    created_at TEXT NOT NULL,
    FOREIGN KEY (report_id) REFERENCES diagnosis_reports(id)
);

-- 4. 创建索引
CREATE INDEX idx_results_report_id ON diagnosis_results(report_id);
CREATE INDEX idx_results_execution_id ON diagnosis_results(execution_id);
CREATE INDEX idx_results_brand ON diagnosis_results(brand);

-- 5. 恢复数据（如果有）
INSERT INTO diagnosis_results (execution_id, brand, question, model, response_content, geo_data, quality_score, quality_level, quality_details, status, created_at)
SELECT execution_id, brand_name, '', '', results, geo_data, 0, 'unknown', '{}', 'success', created_at
FROM diagnosis_results_backup;

-- 6. 清理备份表
DROP TABLE IF EXISTS diagnosis_results_backup;
```

#### 步骤 2: 修复 execution_store 作用域错误

**文件**: `backend_python/wechat_backend/nxm_execution_engine.py`

```python
# 在文件顶部添加导入
import traceback  # ← 新增

# 修复 run_execution 函数中的 execution_store 引用
def run_execution():
    # 获取 execution_store 引用
    from wechat_backend.views.diagnosis_views import execution_store
    
    try:
        # ... 现有代码 ...
    except Exception as e:
        api_logger.error(f"[NxM] 执行异常，使用容错报告：{execution_id}: {e}")
        # ... 现有代码 ...
```

#### 步骤 3: 修复诊断结果保存逻辑

**文件**: `backend_python/wechat_backend/nxm_execution_engine.py`

```python
# 修复保存逻辑，确保使用正确的字段
def save_result_to_db(report_id, execution_id, result):
    from wechat_backend.diagnosis_report_service import get_report_service
    
    service = get_report_service()
    
    try:
        # 正确的保存方式
        service.add_result(report_id, execution_id, {
            'brand': result.get('brand', ''),
            'question': result.get('question', ''),
            'model': result.get('model', ''),
            'response': result.get('response', {}),
            'geo_data': result.get('geo_data', {}),
            'quality_score': result.get('quality_score', 0),
            'quality_level': result.get('quality_level', 'unknown'),
            'quality_details': result.get('quality_details', {})
        })
    except Exception as e:
        api_logger.error(f"保存结果失败：{e}")
```

#### 步骤 4: 前端错误处理优化

**文件**: `pages/results/results.js`

```javascript
onLoad: async function(options) {
  const executionId = decodeURIComponent(options.executionId || '');
  
  try {
    // 1. 尝试从新 API 加载
    const report = await getFullReport(executionId);
    
    if (report && report.results && report.results.length > 0) {
      // 有数据，正常展示
      this.initializePageDataFromNewAPI(report);
      return;
    }
    
    // 2. 降级到本地 Storage
    const cachedResults = wx.getStorageSync('last_diagnostic_results');
    if (cachedResults && cachedResults.results && cachedResults.results.length > 0) {
      this.initializePageDataFromCache(cachedResults);
      return;
    }
    
    // 3. 显示错误提示
    this.showEmptyState();
    
  } catch (error) {
    console.error('加载报告失败:', error);
    this.showEmptyState();
  }
},

showEmptyState: function() {
  this.setData({
    isEmpty: true,
    emptyMessage: '暂无诊断结果，请重新执行诊断'
  });
  
  wx.showModal({
    title: '暂无数据',
    content: '当前诊断没有可用结果，请重新执行诊断',
    confirmText: '重新诊断',
    cancelText: '返回首页',
    success: (res) => {
      if (res.confirm) {
        wx.reLaunch({ url: '/pages/index/index' });
      } else {
        wx.navigateBack();
      }
    }
  });
}
```

---

## 四、完整闭环验证

### 4.1 验证流程

```
1. 用户输入品牌和问题
   ↓
2. 点击"开始诊断"
   ↓
3. 前端调用 /api/perform-brand-test
   ↓
4. 后端创建 execution_id
   ↓
5. 调用 AI API（多个模型）
   ↓
6. 解析 AI 响应（geo_analysis）
   ↓
7. 保存到数据库（diagnosis_reports + diagnosis_results）
   ↓
8. 前端轮询 /test/status/{id}
   ↓
9. 后端从数据库查询结果
   ↓
10. 返回完整结果给前端
    ↓
11. 前端展示诊断报告
    ↓
12. 用户查看完整报告 ✅
```

### 4.2 验证检查点

| 检查点 | 验证方法 | 预期结果 |
|--------|---------|---------|
| 数据库表结构 | `PRAGMA table_info(diagnosis_results)` | 包含 report_id, execution_id, brand 等字段 |
| AI 调用成功 | 查看日志 | `AI I/O] UNKNOWN DOUBAO` 后有响应 |
| 解析成功 | 查看日志 | `Successfully parsed geo_analysis` |
| 保存成功 | 查看日志 | `✅ 诊断结果已保存到数据库` |
| 前端查询 | 查看日志 | `获取完整报告：{id}` |
| 结果展示 | 前端页面 | 显示完整报告，无错误 |

---

## 五、实施计划

### 5.1 时间安排

| 任务 | 预计时间 | 负责人 |
|------|---------|--------|
| 数据库迁移 | 30 分钟 | 后端工程师 |
| 代码修复 | 1 小时 | 后端工程师 |
| 前端优化 | 30 分钟 | 前端工程师 |
| 集成测试 | 1 小时 | 测试工程师 |
| 验证上线 | 30 分钟 | 全员 |

### 5.2 回滚方案

如果修复失败，执行回滚：

```bash
# 1. 恢复数据库
sqlite3 database.db "DROP TABLE IF EXISTS diagnosis_results;"
sqlite3 database.db ".read database/migrations/003_migrate_legacy_data.sql"

# 2. 恢复代码
git checkout HEAD~1 -- backend_python/wechat_backend/nxm_execution_engine.py

# 3. 重启服务
pm2 restart brand-diagnosis-backend
```

---

## 六、验收标准

### 6.1 功能验收

- [ ] 用户可以输入品牌和问题
- [ ] 点击诊断后能看到进度
- [ ] 诊断完成后能看到完整报告
- [ ] 报告包含所有 AI 模型的结果
- [ ] 报告包含 GEO 分析数据
- [ ] 报告包含质量评分
- [ ] 可以查看历史诊断记录

### 6.2 性能验收

- [ ] 诊断完成时间 < 60 秒（单问题单模型）
- [ ] 报告加载时间 < 2 秒
- [ ] 前端轮询次数 < 30 次
- [ ] 数据库查询时间 < 50ms

### 6.3 数据验收

- [ ] 数据库中有 diagnosis_reports 记录
- [ ] 数据库中有 diagnosis_results 记录
- [ ] 结果数量与 AI 调用次数一致
- [ ] geo_data 字段包含完整信息
- [ ] quality_score 字段有值

---

## 七、监控告警

### 7.1 新增监控项

```yaml
monitoring:
  diagnosis_completion_rate:
    threshold: 90%
    alert: true
  database_save_errors:
    threshold: 5/小时
    alert: true
  empty_result_rate:
    threshold: 10%
    alert: true
  frontend_load_errors:
    threshold: 10/小时
    alert: true
```

### 7.2 告警通知

- 诊断完成率 < 90% → 邮件通知
- 数据库保存错误 > 5/小时 → 短信通知
- 空结果率 > 10% → 电话通知

---

**报告人**: 首席架构师  
**审核人**: CTO  
**实施人**: 后端工程师、前端工程师  
**日期**: 2026-02-25  
**状态**: ⏳ 待实施
