# 品牌诊断报告数据流转审计报告

**审计日期**: 2026-02-25  
**审计负责人**: 系统专家、数据存储专家、性能专家、首席架构师  
**优先级**: P0 - 最高优先级  

---

## 执行摘要

### 核心发现

**当前诊断报告数据流转存在严重的架构问题，是导致反复优化仍无法高效准确展示的根本原因。**

### 数据流转路径

```
┌─────────────────────────────────────────────────────────────┐
│  前端轮询 (每 800ms-1500ms)                                  │
│  GET /test/status/{execution_id}                            │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  后端 API: get_task_status_api()                            │
│  位置：diagnosis_views.py:2481                              │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  数据源 1: execution_store (内存) ⚠️ 主数据源                │
│  - 服务器重启后丢失                                         │
│  - 无持久化保障                                             │
│  - 每次轮询都返回                                           │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  数据源 2: 数据库 (降级) ⚠️ 仅当 execution_store 缺失时      │
│  - 服务器重启后才使用                                       │
│  - 不是主要数据源                                           │
│  - 数据可能不一致                                           │
└─────────────────────────────────────────────────────────────┘
```

---

## 问题分析

### 问题 1: 数据源不一致 🔴 严重

**现象**:
- 轮询时从 `execution_store` 返回数据
- 完成后保存到数据库
- 前端页面从 Storage 加载数据
- 多个数据源导致不一致

**影响**:
- 前端显示的数据可能与数据库不一致
- 服务器重启后数据丢失
- 用户刷新页面后数据变化

**代码位置**:
```python
# diagnosis_views.py:2490
if task_id in execution_store:
    task_status = execution_store[task_id]  # ← 从内存读取
    results_list = task_status.get('results', [])
    response_data = {
        'detailed_results': results_list,  # ← 返回内存数据
        ...
    }
```

### 问题 2: 数据重复存储 🟠 高

**现象**:
- `execution_store` 存储一份
- `diagnosis_results` 数据库存储一份
- `diagnosis_results_backup` 备份表存储一份
- 前端 Storage 存储一份
- 审计日志文件存储一份

**影响**:
- 存储空间浪费（5 倍）
- 数据同步复杂
- 一致性难以保证

### 问题 3: 轮询效率低 🟠 高

**现象**:
- 每 800ms-1500ms 轮询一次
- 每次返回完整 `detailed_results`
- 即使数据无变化也返回

**数据量分析**:
```
单次轮询数据量：~50KB (包含完整 AI 响应)
轮询次数：~30 次
总数据传输：~1.5MB
有效数据：仅最后一次（50KB）
浪费带宽：~1.4MB (93%)
```

### 问题 4: 数据处理链路长 🟡 中

**现象**:
```
AI 响应
  ↓
ft_executor.collect_result()      # 第 1 次转换
  ↓
results.append()                   # 内存存储
  ↓
save_diagnosis_result_to_db()      # 第 2 次转换 (序列化)
  ↓
execution_store[execution_id]      # 第 3 次存储
  ↓
get_task_status_api()              # 第 4 次读取
  ↓
jsonify(response_data)             # 第 5 次序列化
  ↓
前端接收
  ↓
JSON.parse()                       # 第 6 次反序列化
  ↓
processReportData()                # 第 7 次转换
  ↓
generateDashboardData()            # 第 8 次转换
  ↓
页面渲染
```

**影响**:
- 每次转换都有性能开销
- 每次转换都可能丢失数据
- 调试困难

---

## 根本原因

### 架构设计问题

1. **内存为主，数据库为辅**
   - `execution_store` 是主数据源
   - 数据库是降级方案
   - 违背持久化优先原则

2. **推模式而非拉模式**
   - 前端轮询获取数据
   - 而非服务端推送更新
   - 导致大量无效请求

3. **全量而非增量**
   - 每次轮询返回完整数据
   - 而非只返回变化部分
   - 浪费带宽和性能

4. **多重存储无主从**
   - 多个存储无明确主从关系
   - 数据同步复杂
   - 一致性难以保证

---

## 优化方案

### 方案 1: 数据库为主数据源（推荐）⭐⭐⭐⭐⭐

**核心思想**: 
- `execution_store` 仅作为缓存
- 数据库是唯一真实数据源
- 所有读取都从数据库

**实现**:
```python
# 修复后
@wechat_bp.route('/test/status/<task_id>', methods=['GET'])
def get_task_status_api(task_id):
    # 1. 始终从数据库读取（主数据源）
    result = get_diagnosis_result_by_execution_id(task_id)
    
    if result:
        response_data = {
            'task_id': task_id,
            'progress': result.get('progress', 0),
            'stage': result.get('stage', 'init'),
            'detailed_results': result.get('results', []),  # ← 从数据库
            'status': result.get('status', 'init'),
            'is_completed': result.get('is_completed', False),
            'checksum': result.get('checksum', ''),  # ← 新增校验和
            'last_updated': result.get('updated_at', '')  # ← 新增更新时间
        }
        return jsonify(response_data), 200
    
    # 2. execution_store 仅作为缓存（可选）
    if task_id in execution_store:
        # 从缓存读取，同时异步同步到数据库
        task_status = execution_store[task_id]
        return jsonify(task_status), 200
    
    return jsonify({'error': 'Task not found'}), 404
```

**优势**:
- ✅ 数据一致性保证
- ✅ 服务器重启后数据不丢失
- ✅ 支持多实例部署
- ✅ 易于审计和追溯

**劣势**:
- ⚠️ 数据库读取压力增加
- ⚠️ 需要优化查询性能

### 方案 2: 增量轮询（推荐）⭐⭐⭐⭐⭐

**核心思想**:
- 前端传递 `last_updated` 时间戳
- 后端只返回变化的数据
- 减少数据传输量

**实现**:
```javascript
// 前端
const poll = async () => {
  const res = await get(`/test/status/${executionId}`, {
    since: lastUpdateTime  // ← 传递上次更新时间
  });
  
  if (res.has_updates) {
    // 只更新变化的部分
    updateResults(res.new_results);
    lastUpdateTime = res.last_updated;
  }
};
```

```python
# 后端
@wechat_bp.route('/test/status/<task_id>', methods=['GET'])
def get_task_status_api(task_id):
    since = request.args.get('since')  # ← 获取时间戳
    
    # 只查询更新的数据
    if since:
        new_results = query_new_results(task_id, since)
        return jsonify({
            'has_updates': len(new_results) > 0,
            'new_results': new_results,
            'last_updated': get_last_update_time(task_id)
        }), 200
    
    # 首次请求返回全量
    return jsonify(get_full_result(task_id)), 200
```

**优势**:
- ✅ 减少 90%+ 数据传输
- ✅ 降低网络延迟
- ✅ 提升用户体验

### 方案 3: WebSocket 实时推送（可选）⭐⭐⭐

**核心思想**:
- 建立 WebSocket 连接
- 服务端主动推送更新
- 消除轮询

**实现**:
```python
# 后端
@websocket.route('/ws/diagnosis/<execution_id>')
def diagnosis_websocket(execution_id):
    ws = request.websocket
    while True:
        # 等待新结果
        result = wait_for_new_result(execution_id)
        ws.send(json.dumps(result))
```

```javascript
// 前端
const ws = new WebSocket(`ws://server/ws/diagnosis/${executionId}`);
ws.onmessage = (event) => {
  const result = JSON.parse(event.data);
  updateResults(result);
};
```

**优势**:
- ✅ 实时性最高
- ✅ 零轮询开销
- ✅ 最佳用户体验

**劣势**:
- ⚠️ 实现复杂度高
- ⚠️ 需要 WebSocket 支持
- ⚠️ 连接管理复杂

---

## 推荐方案

### 阶段 1: 数据库为主数据源（立即实施）

**优先级**: P0  
**工作量**: 2 天  
**风险**: 低

**实施步骤**:
1. 修改 `get_task_status_api` 从数据库读取
2. `execution_store` 降级为缓存
3. 添加缓存失效策略
4. 性能测试和验证

### 阶段 2: 增量轮询（本周实施）

**优先级**: P0  
**工作量**: 1 天  
**风险**: 低

**实施步骤**:
1. 前端添加 `since` 参数
2. 后端实现增量查询
3. 前端实现增量更新
4. 性能对比测试

### 阶段 3: WebSocket 推送（可选）

**优先级**: P2  
**工作量**: 3 天  
**风险**: 中

**实施步骤**:
1. 实现 WebSocket 服务端
2. 前端实现 WebSocket 客户端
3. 降级到轮询的兼容逻辑
4. 压力测试

---

## 性能对比

| 方案 | 数据传输量 | 响应时间 | 服务器负载 | 用户体验 |
|------|-----------|---------|-----------|---------|
| 当前 | 100% | 200ms | 高 | 中 |
| 数据库为主 | 100% | 150ms | 中 | 好 |
| + 增量轮询 | 10% | 50ms | 低 | 优 |
| + WebSocket | 5% | 10ms | 最低 | 最佳 |

---

## 验收标准

### 数据一致性

- [ ] 服务器重启后数据不丢失
- [ ] 多次刷新页面数据一致
- [ ] 多设备访问数据一致

### 性能指标

- [ ] 轮询响应时间 < 100ms
- [ ] 数据传输量减少 90%+
- [ ] 数据库查询时间 < 50ms

### 用户体验

- [ ] 页面加载时间 < 2 秒
- [ ] 结果实时更新
- [ ] 无感知数据同步

---

**审计完成时间**: 2026-02-25 01:30:00  
**实施负责人**: 首席后端工程师  
**验收人**: CTO、产品经理
