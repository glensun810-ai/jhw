{
  "debug_files": [
    "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/app.py.bak",
    "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views/diagnosis_views.py.bak"
  ],
  "commented_code_files": [
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/diagnosis_report_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        },
        {
          "line": 30,
          "content": "    \"\"\""
        },
        {
          "line": 39,
          "content": "    \"\"\""
        },
        {
          "line": 49,
          "content": "        \"\"\""
        },
        {
          "line": 64,
          "content": "        \"\"\""
        },
        {
          "line": 75,
          "content": "        \"\"\""
        },
        {
          "line": 94,
          "content": "        \"\"\""
        },
        {
          "line": 101,
          "content": "        \"\"\"批量添加诊断结果\"\"\""
        },
        {
          "line": 104,
          "content": "        return result_ids"
        },
        {
          "line": 106,
          "content": "    def add_analysis(self, report_id: int, execution_id: str,"
        },
        {
          "line": 108,
          "content": "        \"\"\""
        },
        {
          "line": 119,
          "content": "        \"\"\""
        },
        {
          "line": 124,
          "content": "        return analysis_id"
        },
        {
          "line": 126,
          "content": "    def add_analyses_batch(self, report_id: int, execution_id: str,"
        },
        {
          "line": 128,
          "content": "        \"\"\"批量添加分析数据\"\"\""
        },
        {
          "line": 134,
          "content": "        \"\"\""
        },
        {
          "line": 147,
          "content": "        \"\"\""
        },
        {
          "line": 181,
          "content": "        \"\"\""
        },
        {
          "line": 194,
          "content": "        \"\"\""
        },
        {
          "line": 231,
          "content": "        \"\"\""
        },
        {
          "line": 244,
          "content": "        \"\"\""
        },
        {
          "line": 259,
          "content": "        \"\"\""
        },
        {
          "line": 269,
          "content": "        \"\"\""
        },
        {
          "line": 278,
          "content": "    \"\"\""
        },
        {
          "line": 285,
          "content": "    \"\"\""
        },
        {
          "line": 289,
          "content": "        \"\"\""
        },
        {
          "line": 298,
          "content": "        \"\"\""
        },
        {
          "line": 341,
          "content": "    \"\"\"获取报告服务单例\"\"\""
        },
        {
          "line": 343,
          "content": "    if _report_service is None:"
        },
        {
          "line": 345,
          "content": "    return _report_service"
        },
        {
          "line": 348,
          "content": "def get_validation_service() -> ReportValidationService:"
        },
        {
          "line": 349,
          "content": "    \"\"\"获取验证服务单例\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/realtime_analyzer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "\"\"\""
        },
        {
          "line": 22,
          "content": "    \"\"\"实时结果分析器\"\"\""
        },
        {
          "line": 24,
          "content": "    def __init__(self, execution_id: str, main_brand: str, all_brands: List[str]):"
        },
        {
          "line": 25,
          "content": "        \"\"\""
        },
        {
          "line": 32,
          "content": "        \"\"\""
        },
        {
          "line": 50,
          "content": "        for brand in all_brands:"
        },
        {
          "line": 61,
          "content": "    def analyze_result(self, result: Dict[str, Any]) -> Dict[str, Any]:"
        },
        {
          "line": 62,
          "content": "        \"\"\""
        },
        {
          "line": 70,
          "content": "        \"\"\""
        },
        {
          "line": 95,
          "content": "        return analysis"
        },
        {
          "line": 97,
          "content": "    def _check_geo_data(self, response: str) -> bool:"
        },
        {
          "line": 98,
          "content": "        \"\"\"检查是否有 GEO 相关数据\"\"\""
        },
        {
          "line": 103,
          "content": "        \"\"\""
        },
        {
          "line": 108,
          "content": "        \"\"\""
        },
        {
          "line": 138,
          "content": "        \"\"\""
        },
        {
          "line": 143,
          "content": "        \"\"\""
        },
        {
          "line": 161,
          "content": "        \"\"\"提取提及的竞品\"\"\""
        },
        {
          "line": 163,
          "content": "        for brand in self.all_brands:"
        },
        {
          "line": 164,
          "content": "            if brand != self.main_brand and brand in response:"
        },
        {
          "line": 166,
          "content": "        return mentioned"
        },
        {
          "line": 168,
          "content": "    def _update_stats(self, analysis: Dict[str, Any]):"
        },
        {
          "line": 169,
          "content": "        \"\"\"更新统计数据\"\"\""
        },
        {
          "line": 218,
          "content": "        \"\"\""
        },
        {
          "line": 223,
          "content": "        \"\"\""
        },
        {
          "line": 252,
          "content": "        \"\"\"计算品牌实时排名\"\"\""
        },
        {
          "line": 255,
          "content": "        for brand, stats in self.stats['brand_stats'].items():"
        },
        {
          "line": 256,
          "content": "            if stats['count'] == 0:"
        },
        {
          "line": 261,
          "content": "            geo_rate = stats['geo_mentioned_count'] / stats['count'] if stats['count'] > 0 else 0"
        },
        {
          "line": 262,
          "content": "            avg_rank = stats['rank_sum'] / stats['geo_mentioned_count'] if stats['geo_mentioned_count'] > 0 else -1"
        },
        {
          "line": 268,
          "content": "                'success_rate': stats['success_count'] / stats['count'] if stats['count'] > 0 else 0,"
        },
        {
          "line": 272,
          "content": "                'avg_rank': round(avg_rank, 1) if avg_rank > 0 else -1"
        },
        {
          "line": 279,
          "content": "        for i, ranking in enumerate(rankings):"
        },
        {
          "line": 282,
          "content": "        return rankings"
        },
        {
          "line": 284,
          "content": "    def _calculate_sov(self) -> float:"
        },
        {
          "line": 285,
          "content": "        \"\"\"计算 SOV (Share of Voice)\"\"\""
        },
        {
          "line": 300,
          "content": "        \"\"\"计算平均情感分数\"\"\""
        },
        {
          "line": 304,
          "content": "        for stats in self.stats['brand_stats'].values():"
        },
        {
          "line": 305,
          "content": "            if stats['count'] > 0:"
        },
        {
          "line": 309,
          "content": "        if total_count == 0:"
        },
        {
          "line": 310,
          "content": "            return 0.0"
        },
        {
          "line": 312,
          "content": "        return round(total_sentiment / total_count, 2)"
        },
        {
          "line": 314,
          "content": "    def get_summary(self) -> Dict[str, Any]:"
        },
        {
          "line": 315,
          "content": "        \"\"\""
        },
        {
          "line": 320,
          "content": "        \"\"\""
        },
        {
          "line": 321,
          "content": "        return {"
        },
        {
          "line": 328,
          "content": "            'success_rate': round(self.stats['success_count'] / self.stats['completed_tasks'] * 100, 2) if self.stats['completed_tasks'] > 0 else 0,"
        },
        {
          "line": 329,
          "content": "            'brands_count': len([b for b, s in self.stats['brand_stats'].items() if s['count'] > 0]),"
        },
        {
          "line": 339,
          "content": "def get_analyzer(execution_id: str) -> RealtimeAnalyzer:"
        },
        {
          "line": 340,
          "content": "    \"\"\"获取指定执行 ID 的分析器\"\"\""
        },
        {
          "line": 345,
          "content": "    \"\"\"创建并注册分析器\"\"\""
        },
        {
          "line": 348,
          "content": "    return analyzer"
        },
        {
          "line": 351,
          "content": "def remove_analyzer(execution_id: str):"
        },
        {
          "line": 352,
          "content": "    \"\"\"移除分析器\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_pdf_export_v2.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 25,
          "content": "    \"\"\""
        },
        {
          "line": 35,
          "content": "    \"\"\""
        },
        {
          "line": 107,
          "content": "    \"\"\""
        },
        {
          "line": 118,
          "content": "    \"\"\""
        },
        {
          "line": 174,
          "content": "    \"\"\""
        },
        {
          "line": 179,
          "content": "    \"\"\""
        },
        {
          "line": 209,
          "content": "    \"\"\""
        },
        {
          "line": 214,
          "content": "    \"\"\""
        },
        {
          "line": 244,
          "content": "    \"\"\""
        },
        {
          "line": 253,
          "content": "    \"\"\""
        },
        {
          "line": 285,
          "content": "    \"\"\""
        },
        {
          "line": 290,
          "content": "    \"\"\""
        },
        {
          "line": 303,
          "content": "    \"\"\"过滤为基础版数据\"\"\""
        },
        {
          "line": 304,
          "content": "    return {"
        },
        {
          "line": 314,
          "content": "def _filter_detailed(report_data: Dict) -> Dict:"
        },
        {
          "line": 315,
          "content": "    \"\"\"过滤为详细版数据\"\"\""
        },
        {
          "line": 328,
          "content": "    \"\"\"注册 PDF 导出 Blueprint\"\"\""
        },
        {
          "line": 333,
          "content": "    from wechat_backend.services.async_export_service import start_cleanup_thread"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/market_intelligence_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\"市场情报服务，用于基准对比与心智占有率分析\"\"\""
        },
        {
          "line": 20,
          "content": "    def __init__(self):"
        },
        {
          "line": 25,
          "content": "    def calculate_category_benchmarks(self, brand_name: str, category: str = None, days: int = 30) -> Dict[str, any]:"
        },
        {
          "line": 26,
          "content": "        \"\"\""
        },
        {
          "line": 36,
          "content": "        \"\"\""
        },
        {
          "line": 38,
          "content": "        if not sql_protector.validate_input(brand_name):"
        },
        {
          "line": 40,
          "content": "        if category and not sql_protector.validate_input(category):"
        },
        {
          "line": 46,
          "content": "        if not all_brand_data:"
        },
        {
          "line": 47,
          "content": "            self.logger.warning(f\"No data found for category: {category}\")"
        },
        {
          "line": 48,
          "content": "            return {"
        },
        {
          "line": 82,
          "content": "        self.logger.info(f\"Calculated market intelligence for brand: {brand_name}, category: {category}\")"
        },
        {
          "line": 83,
          "content": "        return result"
        },
        {
          "line": 85,
          "content": "    def _get_all_brand_data_in_category(self, category: str = None, days: int = 30) -> Dict[str, List[Dict]]:"
        },
        {
          "line": 86,
          "content": "        \"\"\""
        },
        {
          "line": 95,
          "content": "        \"\"\""
        },
        {
          "line": 99,
          "content": "        if category:"
        },
        {
          "line": 108,
          "content": "            '''"
        },
        {
          "line": 116,
          "content": "            '''"
        },
        {
          "line": 123,
          "content": "        for row in rows:"
        },
        {
          "line": 131,
          "content": "            detailed_results = json.loads(detailed_results_str) if detailed_results_str else []"
        },
        {
          "line": 132,
          "content": "            results_summary = json.loads(results_summary_str) if results_summary_str else {}"
        },
        {
          "line": 146,
          "content": "        return dict(brand_data)"
        },
        {
          "line": 148,
          "content": "    def _extract_rank_from_results(self, results_summary: Dict) -> Optional[int]:"
        },
        {
          "line": 149,
          "content": "        \"\"\"从结果摘要中提取排名\"\"\""
        },
        {
          "line": 172,
          "content": "        \"\"\"計算平均情感分數\"\"\""
        },
        {
          "line": 173,
          "content": "        if not detailed_results:"
        },
        {
          "line": 174,
          "content": "            return None"
        },
        {
          "line": 177,
          "content": "        for result in detailed_results:"
        },
        {
          "line": 179,
          "content": "            if sentiment is not None:"
        },
        {
          "line": 182,
          "content": "        if sentiment_scores:"
        },
        {
          "line": 183,
          "content": "            return sum(sentiment_scores) / len(sentiment_scores)"
        },
        {
          "line": 184,
          "content": "        return None"
        },
        {
          "line": 186,
          "content": "    def _calculate_benchmarks(self, all_brand_data: Dict[str, List[Dict]]) -> Dict[str, any]:"
        },
        {
          "line": 187,
          "content": "        \"\"\"計算品类基准数据\"\"\""
        },
        {
          "line": 218,
          "content": "        \"\"\"计算我方品牌的指标\"\"\""
        },
        {
          "line": 221,
          "content": "        if not my_brand_records:"
        },
        {
          "line": 222,
          "content": "            return {"
        },
        {
          "line": 232,
          "content": "        my_ranks = [record.get('rank') for record in my_brand_records if record.get('rank') is not None]"
        },
        {
          "line": 233,
          "content": "        my_avg_rank = statistics.mean(my_ranks) if my_ranks else None"
        },
        {
          "line": 236,
          "content": "        my_sentiments = [record.get('sentiment_score') for record in my_brand_records if record.get('sentiment_score') is not None]"
        },
        {
          "line": 237,
          "content": "        my_avg_sentiment = statistics.mean(my_sentiments) if my_sentiments else None"
        },
        {
          "line": 242,
          "content": "        for record in my_brand_records:"
        },
        {
          "line": 244,
          "content": "            if detailed_results and isinstance(detailed_results, list):"
        },
        {
          "line": 248,
          "content": "            if results_summary and isinstance(results_summary, dict):"
        },
        {
          "line": 250,
          "content": "                if questions_used and isinstance(questions_used, list):"
        },
        {
          "line": 253,
          "content": "        mind_share = (total_mentions / total_queries * 100) if total_queries > 0 else 0"
        },
        {
          "line": 257,
          "content": "        for brand_name, records in all_brand_data.items():"
        },
        {
          "line": 258,
          "content": "            ranks = [r.get('rank') for r in records if r.get('rank') is not None]"
        },
        {
          "line": 259,
          "content": "            if ranks:"
        },
        {
          "line": 263,
          "content": "        sorted_brands_by_rank = sorted(all_avg_ranks.items(), key=lambda x: x[1] if x[1] is not None else float('inf'))"
        },
        {
          "line": 264,
          "content": "        rank_position = next((i+1 for i, (name, _) in enumerate(sorted_brands_by_rank) if name == my_brand_name), None)"
        },
        {
          "line": 268,
          "content": "        for brand_name, records in all_brand_data.items():"
        },
        {
          "line": 269,
          "content": "            sentiments = [r.get('sentiment_score') for r in records if r.get('sentiment_score') is not None]"
        },
        {
          "line": 270,
          "content": "            if sentiments:"
        },
        {
          "line": 273,
          "content": "        sorted_brands_by_sentiment = sorted(all_avg_sentiments.items(), key=lambda x: x[1] if x[1] is not None else float('-inf'), reverse=True)"
        },
        {
          "line": 274,
          "content": "        sentiment_position = next((i+1 for i, (name, _) in enumerate(sorted_brands_by_sentiment) if name == my_brand_name), None)"
        },
        {
          "line": 276,
          "content": "        return {"
        },
        {
          "line": 285,
          "content": "    def _generate_all_brands_comparison(self, all_brand_data: Dict[str, List[Dict]]) -> List[Dict]:"
        },
        {
          "line": 286,
          "content": "        \"\"\"生成所有品牌的对比数据\"\"\""
        },
        {
          "line": 324,
          "content": "        \"\"\""
        },
        {
          "line": 334,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/state_manager.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "\"\"\""
        },
        {
          "line": 21,
          "content": "    \"\"\""
        },
        {
          "line": 28,
          "content": "    \"\"\""
        },
        {
          "line": 51,
          "content": "        \"\"\""
        },
        {
          "line": 76,
          "content": "        \"\"\""
        },
        {
          "line": 158,
          "content": "        \"\"\""
        },
        {
          "line": 171,
          "content": "        \"\"\""
        },
        {
          "line": 241,
          "content": "        \"\"\""
        },
        {
          "line": 249,
          "content": "        \"\"\""
        },
        {
          "line": 260,
          "content": "    \"\"\"获取全局状态管理器实例\"\"\""
        },
        {
          "line": 262,
          "content": "    if _state_manager is None:"
        },
        {
          "line": 265,
          "content": "    return _state_manager"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_permission.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "\"\"\""
        },
        {
          "line": 37,
          "content": "    \"\"\"权限数据模型\"\"\""
        },
        {
          "line": 40,
          "content": "    def get_user_permissions(user_id: str) -> Dict[str, Any]:"
        },
        {
          "line": 41,
          "content": "        \"\"\"获取用户权限列表\"\"\""
        },
        {
          "line": 50,
          "content": "        ''', (user_id, datetime.now().isoformat()))"
        },
        {
          "line": 54,
          "content": "        for row in roles_result:"
        },
        {
          "line": 66,
          "content": "        if role_ids:"
        },
        {
          "line": 73,
          "content": "            ''', tuple(role_ids))"
        },
        {
          "line": 97,
          "content": "        \"\"\"分配默认角色\"\"\""
        },
        {
          "line": 103,
          "content": "        if roles:"
        },
        {
          "line": 109,
          "content": "                ''', (user_id, role_id, datetime.now().isoformat()))"
        },
        {
          "line": 117,
          "content": "        \"\"\"授予用户权限\"\"\""
        },
        {
          "line": 129,
          "content": "            if not perm:"
        },
        {
          "line": 131,
          "content": "                return False"
        },
        {
          "line": 135,
          "content": "            if roles:"
        },
        {
          "line": 141,
          "content": "                ''', (temp_role_name, f'Temporary role for permission {perm[0][1]}'))"
        },
        {
          "line": 148,
          "content": "            ''', (role_id, permission_id))"
        },
        {
          "line": 152,
          "content": "            if expires_days:"
        },
        {
          "line": 158,
          "content": "            ''', (user_id, role_id, granted_by, datetime.now().isoformat(), expires_at))"
        },
        {
          "line": 164,
          "content": "            ''', (user_id, permission_id, granted_by, reason or ''))"
        },
        {
          "line": 170,
          "content": "            return True"
        },
        {
          "line": 175,
          "content": "            return False"
        },
        {
          "line": 178,
          "content": "    def revoke_permission(user_id: str, permission_id: int, revoked_by: str,"
        },
        {
          "line": 180,
          "content": "        \"\"\"撤销用户权限\"\"\""
        },
        {
          "line": 193,
          "content": "            ''', (user_id, permission_id))"
        },
        {
          "line": 195,
          "content": "            role_ids = [row[0] for row in roles_result]"
        },
        {
          "line": 198,
          "content": "            if role_ids:"
        },
        {
          "line": 203,
          "content": "                ''', (user_id, *role_ids))"
        },
        {
          "line": 209,
          "content": "            ''', (user_id, permission_id, revoked_by, reason or ''))"
        },
        {
          "line": 214,
          "content": "            api_logger.info(f'Revoked permission {permission_id} from user {user_id}')"
        },
        {
          "line": 215,
          "content": "            return True"
        },
        {
          "line": 220,
          "content": "            return False"
        },
        {
          "line": 223,
          "content": "    def get_all_permissions() -> List[Dict[str, Any]]:"
        },
        {
          "line": 224,
          "content": "        \"\"\"获取所有权限\"\"\""
        },
        {
          "line": 231,
          "content": "        ''')"
        },
        {
          "line": 233,
          "content": "        return ["
        },
        {
          "line": 240,
          "content": "            for row in result"
        },
        {
          "line": 244,
          "content": "    def get_all_roles() -> List[Dict[str, Any]]:"
        },
        {
          "line": 245,
          "content": "        \"\"\"获取所有角色\"\"\""
        },
        {
          "line": 257,
          "content": "        ''')"
        },
        {
          "line": 259,
          "content": "        return ["
        },
        {
          "line": 267,
          "content": "            for row in result"
        },
        {
          "line": 276,
          "content": "def get_user_permissions():"
        },
        {
          "line": 277,
          "content": "    \"\"\""
        },
        {
          "line": 294,
          "content": "    \"\"\""
        },
        {
          "line": 298,
          "content": "        if not user_id:"
        },
        {
          "line": 302,
          "content": "        if not user_id:"
        },
        {
          "line": 303,
          "content": "            return jsonify({"
        },
        {
          "line": 312,
          "content": "            return jsonify({"
        },
        {
          "line": 320,
          "content": "        return jsonify({"
        },
        {
          "line": 328,
          "content": "        return jsonify({"
        },
        {
          "line": 335,
          "content": "def grant_permission():"
        },
        {
          "line": 336,
          "content": "    \"\"\""
        },
        {
          "line": 352,
          "content": "    \"\"\""
        },
        {
          "line": 356,
          "content": "        if not data:"
        },
        {
          "line": 357,
          "content": "            return jsonify({"
        },
        {
          "line": 368,
          "content": "        if not user_id or not permission_id:"
        },
        {
          "line": 369,
          "content": "            return jsonify({"
        },
        {
          "line": 378,
          "content": "            if expires_days:"
        },
        {
          "line": 381,
          "content": "            return jsonify({"
        },
        {
          "line": 398,
          "content": "        if success:"
        },
        {
          "line": 399,
          "content": "            return jsonify({"
        },
        {
          "line": 409,
          "content": "            return jsonify({"
        },
        {
          "line": 416,
          "content": "        return jsonify({"
        },
        {
          "line": 423,
          "content": "def revoke_permission():"
        },
        {
          "line": 424,
          "content": "    \"\"\""
        },
        {
          "line": 439,
          "content": "    \"\"\""
        },
        {
          "line": 443,
          "content": "        if not data:"
        },
        {
          "line": 444,
          "content": "            return jsonify({"
        },
        {
          "line": 454,
          "content": "        if not user_id or not permission_id:"
        },
        {
          "line": 455,
          "content": "            return jsonify({"
        },
        {
          "line": 465,
          "content": "            return jsonify({"
        },
        {
          "line": 481,
          "content": "        if success:"
        },
        {
          "line": 482,
          "content": "            return jsonify({"
        },
        {
          "line": 491,
          "content": "            return jsonify({"
        },
        {
          "line": 498,
          "content": "        return jsonify({"
        },
        {
          "line": 505,
          "content": "def get_all_permissions():"
        },
        {
          "line": 506,
          "content": "    \"\"\"获取所有权限列表\"\"\""
        },
        {
          "line": 526,
          "content": "    \"\"\"获取所有角色列表\"\"\""
        },
        {
          "line": 530,
          "content": "        return jsonify({"
        },
        {
          "line": 538,
          "content": "        return jsonify({"
        },
        {
          "line": 548,
          "content": "def init_permission_routes(app):"
        },
        {
          "line": 549,
          "content": "    \"\"\"初始化权限管理路由\"\"\""
        },
        {
          "line": 555,
          "content": "    \"\"\"初始化权限管理数据库表\"\"\""
        },
        {
          "line": 556,
          "content": "    import os"
        },
        {
          "line": 559,
          "content": "    if os.path.exists(sql_path):"
        },
        {
          "line": 562,
          "content": "            from wechat_backend.security.sql_protection import SafeDatabaseQuery"
        },
        {
          "line": 563,
          "content": "            from wechat_backend.database import DB_PATH"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_analytics.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\"装饰器：要求管理员权限\"\"\""
        },
        {
          "line": 24,
          "content": "    from functools import wraps"
        },
        {
          "line": 27,
          "content": "    def decorated_function(*args, **kwargs):"
        },
        {
          "line": 29,
          "content": "        if not is_admin_user(user_id):"
        },
        {
          "line": 30,
          "content": "            return jsonify({'error': 'Admin access required'}), 403"
        },
        {
          "line": 31,
          "content": "        return f(*args, **kwargs)"
        },
        {
          "line": 33,
          "content": "    return decorated_function"
        },
        {
          "line": 36,
          "content": "def is_admin_user(user_id):"
        },
        {
          "line": 37,
          "content": "    \"\"\"检查用户是否为管理员\"\"\""
        },
        {
          "line": 48,
          "content": "        ''', (user_id,))"
        },
        {
          "line": 51,
          "content": "        return result is not None"
        },
        {
          "line": 53,
          "content": "        return False"
        },
        {
          "line": 63,
          "content": "def get_active_users():"
        },
        {
          "line": 64,
          "content": "    \"\"\""
        },
        {
          "line": 70,
          "content": "    \"\"\""
        },
        {
          "line": 85,
          "content": "        if group_by == 'day':"
        },
        {
          "line": 87,
          "content": "        elif group_by == 'week':"
        },
        {
          "line": 100,
          "content": "        ''', (date_format, start_date.strftime('%Y-%m-%d')))"
        },
        {
          "line": 120,
          "content": "        ''', (today,))"
        },
        {
          "line": 128,
          "content": "        ''', (month_ago,))"
        },
        {
          "line": 171,
          "content": "    \"\"\""
        },
        {
          "line": 176,
          "content": "    \"\"\""
        },
        {
          "line": 194,
          "content": "        ''', (start_date,))"
        },
        {
          "line": 210,
          "content": "        ''', (start_date,))"
        },
        {
          "line": 222,
          "content": "        ''', (start_date,))"
        },
        {
          "line": 225,
          "content": "        for row in cursor.fetchall():"
        },
        {
          "line": 228,
          "content": "                for model in models:"
        },
        {
          "line": 236,
          "content": "            [{'name': k, 'count': v} for k, v in model_usage.items()],"
        },
        {
          "line": 243,
          "content": "        return jsonify({"
        },
        {
          "line": 258,
          "content": "        return jsonify({'error': 'Failed to get feature usage'}), 500"
        },
        {
          "line": 268,
          "content": "def get_ai_platform_stats():"
        },
        {
          "line": 269,
          "content": "    \"\"\""
        },
        {
          "line": 274,
          "content": "    \"\"\""
        },
        {
          "line": 289,
          "content": "        ''', (start_date,))"
        },
        {
          "line": 323,
          "content": "        ''', (start_date,))"
        },
        {
          "line": 326,
          "content": "        for row in cursor.fetchall():"
        },
        {
          "line": 330,
          "content": "                for model in models:"
        },
        {
          "line": 339,
          "content": "            for date, counts in sorted(daily_trend.items())"
        },
        {
          "line": 343,
          "content": "        total_calls = sum(p['count'] for p in platforms_list)"
        },
        {
          "line": 344,
          "content": "        avg_calls_per_day = round(total_calls / days, 2) if days > 0 else 0"
        },
        {
          "line": 348,
          "content": "        return jsonify({"
        },
        {
          "line": 367,
          "content": "        return jsonify({'error': 'Failed to get AI platform stats'}), 500"
        },
        {
          "line": 377,
          "content": "def get_error_stats():"
        },
        {
          "line": 378,
          "content": "    \"\"\""
        },
        {
          "line": 383,
          "content": "    \"\"\""
        },
        {
          "line": 399,
          "content": "        ''', (start_date,))"
        },
        {
          "line": 441,
          "content": "        ''', (start_date,))"
        },
        {
          "line": 448,
          "content": "                'error_rate': round(row[1] / row[2] * 100, 2) if row[2] > 0 else 0"
        },
        {
          "line": 450,
          "content": "            for row in cursor.fetchall()"
        },
        {
          "line": 462,
          "content": "        return jsonify({"
        },
        {
          "line": 482,
          "content": "        return jsonify({'error': 'Failed to get error stats'}), 500"
        },
        {
          "line": 492,
          "content": "def get_analytics_dashboard():"
        },
        {
          "line": 493,
          "content": "    \"\"\""
        },
        {
          "line": 495,
          "content": "    \"\"\""
        },
        {
          "line": 528,
          "content": "        ''', (start_date,))"
        },
        {
          "line": 577,
          "content": "    \"\"\"初始化分析路由\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_utils.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Utility functions for managing AI adapters and running tests"
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "    \"\"\""
        },
        {
          "line": 11,
          "content": "    Get an AI client for the specified platform"
        },
        {
          "line": 15,
          "content": "        api_key: API key for the platform"
        },
        {
          "line": 20,
          "content": "        AIClient instance for the specified platform"
        },
        {
          "line": 21,
          "content": "    \"\"\""
        },
        {
          "line": 48,
          "content": "    \"\"\""
        },
        {
          "line": 57,
          "content": "        AIResponse from the AI platform"
        },
        {
          "line": 58,
          "content": "    \"\"\""
        },
        {
          "line": 64,
          "content": "    \"\"\""
        },
        {
          "line": 69,
          "content": "        response_content: The response content from the AI"
        },
        {
          "line": 74,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/semantic_analyzer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Semantic Analyzer for GEO Content Quality Validator"
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "    \"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 24,
          "content": "        # Initialize Jieba with custom dictionary if available"
        },
        {
          "line": 37,
          "content": "        # Common stop words for Chinese text"
        },
        {
          "line": 59,
          "content": "        \"\"\""
        },
        {
          "line": 65,
          "content": "            brand_name: Brand name for context (optional)"
        },
        {
          "line": 69,
          "content": "        \"\"\""
        },
        {
          "line": 70,
          "content": "        # Combine all AI responses for analysis"
        },
        {
          "line": 73,
          "content": "        # Extract keywords from both texts"
        },
        {
          "line": 123,
          "content": "        \"\"\""
        },
        {
          "line": 124,
          "content": "        Extract keywords from text using TF-IDF and Jieba"
        },
        {
          "line": 132,
          "content": "        \"\"\""
        },
        {
          "line": 151,
          "content": "        \"\"\""
        },
        {
          "line": 160,
          "content": "        \"\"\""
        },
        {
          "line": 168,
          "content": "        # If texts are too short, return low similarity"
        },
        {
          "line": 196,
          "content": "        \"\"\""
        },
        {
          "line": 204,
          "content": "        \"\"\""
        },
        {
          "line": 210,
          "content": "        \"\"\""
        },
        {
          "line": 219,
          "content": "        \"\"\""
        },
        {
          "line": 234,
          "content": "        \"\"\""
        },
        {
          "line": 244,
          "content": "        \"\"\""
        },
        {
          "line": 268,
          "content": "        \"\"\""
        },
        {
          "line": 276,
          "content": "        \"\"\""
        },
        {
          "line": 287,
          "content": "        \"\"\""
        },
        {
          "line": 295,
          "content": "        \"\"\""
        },
        {
          "line": 315,
          "content": "        # Remove duplicates while preserving order"
        },
        {
          "line": 326,
          "content": "        \"\"\""
        },
        {
          "line": 334,
          "content": "        \"\"\""
        },
        {
          "line": 354,
          "content": "        # Remove duplicates while preserving order"
        },
        {
          "line": 365,
          "content": "        \"\"\""
        },
        {
          "line": 373,
          "content": "        \"\"\""
        },
        {
          "line": 390,
          "content": "    \"\"\""
        },
        {
          "line": 392,
          "content": "    \"\"\""
        },
        {
          "line": 406,
          "content": "        \"\"\""
        },
        {
          "line": 412,
          "content": "            response_sources: List of source URLs from AI responses"
        },
        {
          "line": 413,
          "content": "            brand_name: Brand name for context (optional)"
        },
        {
          "line": 417,
          "content": "        \"\"\""
        },
        {
          "line": 423,
          "content": "        # Extract domains from sources"
        },
        {
          "line": 426,
          "content": "        # Get weights for domains"
        },
        {
          "line": 456,
          "content": "            # Check if any AI response contains negative terms and this source was referenced"
        },
        {
          "line": 485,
          "content": "        \"\"\""
        },
        {
          "line": 486,
          "content": "        Check if a domain is referenced in the response"
        },
        {
          "line": 493,
          "content": "            True if domain is referenced in response"
        },
        {
          "line": 494,
          "content": "        \"\"\""
        },
        {
          "line": 498,
          "content": "        \"\"\""
        },
        {
          "line": 502,
          "content": "            semantic_analysis: Results from semantic analysis"
        },
        {
          "line": 508,
          "content": "        \"\"\""
        },
        {
          "line": 534,
          "content": "    \"\"\""
        },
        {
          "line": 543,
          "content": "    # Example sources from AI responses"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/logging_config.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "    from wechat_backend.logging_config import app_logger, api_logger, get_logger"
        },
        {
          "line": 11,
          "content": "    from backend_python.unified_logging.entry import get_logger, init"
        },
        {
          "line": 18,
          "content": "\"\"\""
        },
        {
          "line": 43,
          "content": "    \"\"\"确保日志系统已初始化\"\"\""
        },
        {
          "line": 45,
          "content": "    if not _initialized and _NEW_LOGGING_AVAILABLE:"
        },
        {
          "line": 50,
          "content": "def _get_factory():"
        },
        {
          "line": 51,
          "content": "    \"\"\"获取或创建日志工厂实例\"\"\""
        },
        {
          "line": 68,
          "content": "    \"\"\""
        },
        {
          "line": 76,
          "content": "    \"\"\""
        },
        {
          "line": 132,
          "content": "    \"\"\""
        },
        {
          "line": 143,
          "content": "    \"\"\""
        },
        {
          "line": 208,
          "content": "    \"\"\""
        },
        {
          "line": 213,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/config_manager.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "Provides secure access to API keys from environment variables"
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "    \"\"\"配置数据类\"\"\""
        },
        {
          "line": 11,
          "content": "    def __init__(self, api_key: str, default_model: Optional[str] = None,"
        },
        {
          "line": 21,
          "content": "class ConfigurationManager:"
        },
        {
          "line": 22,
          "content": "    \"\"\""
        },
        {
          "line": 24,
          "content": "    \"\"\""
        },
        {
          "line": 27,
          "content": "    def get_api_key(platform_name: str) -> Optional[str]:"
        },
        {
          "line": 28,
          "content": "        \"\"\""
        },
        {
          "line": 36,
          "content": "        \"\"\""
        },
        {
          "line": 37,
          "content": "        return Config.get_api_key(platform_name)"
        },
        {
          "line": 40,
          "content": "    def is_platform_configured(platform_name: str) -> bool:"
        },
        {
          "line": 41,
          "content": "        \"\"\""
        },
        {
          "line": 49,
          "content": "        \"\"\""
        },
        {
          "line": 50,
          "content": "        return Config.is_api_key_configured(platform_name)"
        },
        {
          "line": 53,
          "content": "    def get_platform_model(platform_name: str) -> Optional[str]:"
        },
        {
          "line": 54,
          "content": "        \"\"\""
        },
        {
          "line": 62,
          "content": "        \"\"\""
        },
        {
          "line": 75,
          "content": "        return platform_models.get(platform_name.lower())"
        },
        {
          "line": 78,
          "content": "    def get_platform_config(platform_name: str) -> Optional[ConfigData]:"
        },
        {
          "line": 79,
          "content": "        \"\"\""
        },
        {
          "line": 87,
          "content": "        \"\"\""
        },
        {
          "line": 89,
          "content": "        if not api_key:"
        },
        {
          "line": 90,
          "content": "            return None"
        },
        {
          "line": 93,
          "content": "        return ConfigData(api_key=api_key, default_model=model)"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_analytics_behavior.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "\"\"\""
        },
        {
          "line": 40,
          "content": "    \"\"\""
        },
        {
          "line": 57,
          "content": "    \"\"\""
        },
        {
          "line": 117,
          "content": "    \"\"\""
        },
        {
          "line": 130,
          "content": "    \"\"\""
        },
        {
          "line": 171,
          "content": "    \"\"\""
        },
        {
          "line": 185,
          "content": "    \"\"\""
        },
        {
          "line": 218,
          "content": "    \"\"\""
        },
        {
          "line": 229,
          "content": "    \"\"\""
        },
        {
          "line": 256,
          "content": "    \"\"\""
        },
        {
          "line": 266,
          "content": "    \"\"\""
        },
        {
          "line": 293,
          "content": "    \"\"\"保存事件（带内存限制）\"\"\""
        },
        {
          "line": 294,
          "content": "    if user_id not in _user_events:"
        },
        {
          "line": 300,
          "content": "    if len(_user_events[user_id]) > MAX_EVENTS_PER_USER:"
        },
        {
          "line": 306,
          "content": "def _cleanup_old_daily_stats():"
        },
        {
          "line": 307,
          "content": "    \"\"\"清理过期的每日统计\"\"\""
        },
        {
          "line": 325,
          "content": "    \"\"\"获取用户事件\"\"\""
        },
        {
          "line": 329,
          "content": "    if start_time:"
        },
        {
          "line": 330,
          "content": "        events = [e for e in events if e.get('timestamp', '') >= start_time]"
        },
        {
          "line": 331,
          "content": "    if end_time:"
        },
        {
          "line": 332,
          "content": "        events = [e for e in events if e.get('timestamp', '') <= end_time]"
        },
        {
          "line": 337,
          "content": "    return events[:limit]"
        },
        {
          "line": 340,
          "content": "def _get_or_create_session(user_id: str) -> str:"
        },
        {
          "line": 341,
          "content": "    \"\"\"获取或创建会话\"\"\""
        },
        {
          "line": 356,
          "content": "    \"\"\"按会话分组事件\"\"\""
        },
        {
          "line": 359,
          "content": "    for event in events:"
        },
        {
          "line": 364,
          "content": "    for session_id, session_events in sessions.items():"
        },
        {
          "line": 365,
          "content": "        if session_events:"
        },
        {
          "line": 375,
          "content": "    return result"
        },
        {
          "line": 378,
          "content": "def _calculate_session_duration(events: List[Dict[str, Any]]) -> int:"
        },
        {
          "line": 379,
          "content": "    \"\"\"计算会话时长（秒）\"\"\""
        },
        {
          "line": 394,
          "content": "    \"\"\"生成轨迹摘要\"\"\""
        },
        {
          "line": 395,
          "content": "    if not events:"
        },
        {
          "line": 396,
          "content": "        return {"
        },
        {
          "line": 408,
          "content": "    for event in events:"
        },
        {
          "line": 413,
          "content": "    most_frequent = max(event_counts.items(), key=lambda x: x[1])[0] if event_counts else None"
        },
        {
          "line": 416,
          "content": "    sessions = set(e.get('session_id') for e in events)"
        },
        {
          "line": 418,
          "content": "    return {"
        },
        {
          "line": 428,
          "content": "def _update_daily_stats(user_id: str, event: Dict[str, Any]):"
        },
        {
          "line": 429,
          "content": "    \"\"\"更新每日统计（带自动清理）\"\"\""
        },
        {
          "line": 461,
          "content": "    \"\"\"计算统计数据\"\"\""
        },
        {
          "line": 468,
          "content": "    for date_str, stats in _daily_stats.items():"
        },
        {
          "line": 469,
          "content": "        if date_range['start'] <= date_str <= date_range['end']:"
        },
        {
          "line": 473,
          "content": "            for event, count in stats['event_breakdown'].items():"
        },
        {
          "line": 476,
          "content": "            for hour, count in stats['hourly_distribution'].items():"
        },
        {
          "line": 482,
          "content": "    return {"
        },
        {
          "line": 487,
          "content": "        'popular_events': [{'event': e, 'count': c} for e, c in popular_events],"
        },
        {
          "line": 488,
          "content": "        'avg_events_per_user': total_events / len(unique_users) if unique_users else 0"
        },
        {
          "line": 492,
          "content": "def _calculate_date_range(period: str, start_date: Optional[str] = None,"
        },
        {
          "line": 494,
          "content": "    \"\"\"计算日期范围\"\"\""
        },
        {
          "line": 527,
          "content": "    \"\"\"生成热力图数据（模拟）\"\"\""
        },
        {
          "line": 528,
          "content": "    import random"
        },
        {
          "line": 532,
          "content": "    for _ in range(50):"
        },
        {
          "line": 539,
          "content": "    return {"
        },
        {
          "line": 541,
          "content": "        'scrolls': [{'depth': random.randint(0, 100)} for _ in range(20)],"
        },
        {
          "line": 542,
          "content": "        'hovers': [{'x': random.randint(0, 100), 'y': random.randint(0, 100), 'duration': random.randint(100, 5000)} for _ in range(30)]"
        },
        {
          "line": 546,
          "content": "def _generate_funnel_data(funnel_name: str, period: str) -> Dict[str, Any]:"
        },
        {
          "line": 547,
          "content": "    \"\"\"生成漏斗数据（模拟）\"\"\""
        },
        {
          "line": 571,
          "content": "    \"\"\"注册行为分析 Blueprint\"\"\""
        },
        {
          "line": 572,
          "content": "    from wechat_backend.logging_config import api_logger"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/models.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "    \"\"\"任务阶段枚举\"\"\""
        },
        {
          "line": 26,
          "content": "class TaskStatus:"
        },
        {
          "line": 27,
          "content": "    \"\"\"任务状态数据模型\"\"\""
        },
        {
          "line": 38,
          "content": "        \"\"\"转换为字典格式\"\"\""
        },
        {
          "line": 39,
          "content": "        return {"
        },
        {
          "line": 49,
          "content": "    def from_dict(cls, data):"
        },
        {
          "line": 50,
          "content": "        \"\"\"从字典创建实例\"\"\""
        },
        {
          "line": 63,
          "content": "    \"\"\"品牌测试结果数据模型，包含深度情报分析结果\"\"\""
        },
        {
          "line": 65,
          "content": "    def __init__(self, task_id, brand_name, ai_models_used=None, questions_used=None,"
        },
        {
          "line": 79,
          "content": "class DeepIntelligenceResult:"
        },
        {
          "line": 80,
          "content": "    \"\"\"深度情报分析结果数据模型，完全按照API契约定义\"\"\""
        },
        {
          "line": 100,
          "content": "        \"\"\"转换为字典格式\"\"\""
        },
        {
          "line": 101,
          "content": "        return {"
        },
        {
          "line": 108,
          "content": "    def from_dict(cls, data):"
        },
        {
          "line": 109,
          "content": "        \"\"\"从字典创建实例\"\"\""
        },
        {
          "line": 125,
          "content": "    \"\"\"初始化任务状态相关的数据库表\"\"\""
        },
        {
          "line": 144,
          "content": "    ''')"
        },
        {
          "line": 159,
          "content": "    ''')"
        },
        {
          "line": 179,
          "content": "    ''')"
        },
        {
          "line": 188,
          "content": "    \"\"\"保存任务状态\"\"\""
        },
        {
          "line": 189,
          "content": "    db_logger.info(f\"Saving task status for task: {task_status.task_id}\")"
        },
        {
          "line": 192,
          "content": "    import sys"
        },
        {
          "line": 193,
          "content": "    import os"
        },
        {
          "line": 195,
          "content": "    from utils.debug_manager import debug_log"
        },
        {
          "line": 197,
          "content": "    from backend_python.utils.logger import debug_log_results, ENABLE_DEBUG_AI_CODE"
        },
        {
          "line": 199,
          "content": "    # Extract execution_id from task_id if it contains one (for DEBUG_AI_CODE logging)"
        },
        {
          "line": 200,
          "content": "    execution_id = task_status.task_id.split('_')[1] if '_' in task_status.task_id and len(task_status.task_id.split('_')) > 1 else 'unknown'"
        },
        {
          "line": 203,
          "content": "    if not sql_protector.validate_input(task_status.task_id):"
        },
        {
          "line": 211,
          "content": "    if existing_task:"
        },
        {
          "line": 217,
          "content": "        ''', ("
        },
        {
          "line": 230,
          "content": "        ''', ("
        },
        {
          "line": 238,
          "content": "    db_logger.info(f\"Task status saved successfully for task: {task_status.task_id}\")"
        },
        {
          "line": 241,
          "content": "    if ENABLE_DEBUG_AI_CODE:"
        },
        {
          "line": 245,
          "content": "def get_task_status(task_id):"
        },
        {
          "line": 246,
          "content": "    \"\"\"获取任务状态\"\"\""
        },
        {
          "line": 258,
          "content": "    ''', (task_id,))"
        },
        {
          "line": 260,
          "content": "    if rows:"
        },
        {
          "line": 270,
          "content": "        db_logger.info(f\"Successfully retrieved task status for task: {task_id}\")"
        },
        {
          "line": 271,
          "content": "        return task_status"
        },
        {
          "line": 273,
          "content": "        db_logger.warning(f\"No task status found for task: {task_id}\")"
        },
        {
          "line": 274,
          "content": "        return None"
        },
        {
          "line": 277,
          "content": "def save_deep_intelligence_result(task_id, deep_intelligence_result):"
        },
        {
          "line": 278,
          "content": "    \"\"\"保存深度情报分析结果\"\"\""
        },
        {
          "line": 300,
          "content": "        ''', ("
        },
        {
          "line": 312,
          "content": "        ''', ("
        },
        {
          "line": 323,
          "content": "    \"\"\"获取深度情报分析结果\"\"\""
        },
        {
          "line": 324,
          "content": "    if not sql_protector.validate_input(task_id):"
        },
        {
          "line": 327,
          "content": "    db_logger.info(f\"Retrieving deep intelligence result for task: {task_id}\")"
        },
        {
          "line": 335,
          "content": "    ''', (task_id,))"
        },
        {
          "line": 352,
          "content": "    \"\"\"更新任务阶段\"\"\""
        },
        {
          "line": 353,
          "content": "    if not sql_protector.validate_input(task_id):"
        },
        {
          "line": 357,
          "content": "    import sys"
        },
        {
          "line": 358,
          "content": "    import os"
        },
        {
          "line": 360,
          "content": "    from utils.debug_manager import status_flow_log, debug_log"
        },
        {
          "line": 364,
          "content": "    from backend_python.utils.logger import debug_log_status_flow, ENABLE_DEBUG_AI_CODE"
        },
        {
          "line": 366,
          "content": "    # Extract execution_id from task_id if it contains one (for DEBUG_AI_CODE logging)"
        },
        {
          "line": 368,
          "content": "    execution_id = task_id.split('_')[1] if '_' in task_id and len(task_id.split('_')) > 1 else 'unknown'"
        },
        {
          "line": 371,
          "content": "    status_flow_log(f\"Updating task {task_id} from previous stage to {stage.value}, progress: {progress}\")"
        },
        {
          "line": 376,
          "content": "    # Track old stage for DEBUG_AI_CODE logging"
        },
        {
          "line": 377,
          "content": "    old_stage = current_status.stage.value if current_status else 'unknown'"
        },
        {
          "line": 379,
          "content": "    progress_value = progress if progress is not None else (current_status.progress if current_status else 0)"
        },
        {
          "line": 381,
          "content": "    if not current_status:"
        },
        {
          "line": 388,
          "content": "    if progress is not None:"
        },
        {
          "line": 391,
          "content": "    if status_text is not None:"
        },
        {
          "line": 395,
          "content": "    if stage == TaskStage.COMPLETED:"
        },
        {
          "line": 397,
          "content": "        if progress is None:"
        },
        {
          "line": 399,
          "content": "        if status_text is None:"
        },
        {
          "line": 402,
          "content": "    elif stage == TaskStage.FAILED:"
        },
        {
          "line": 404,
          "content": "        if progress is None:"
        },
        {
          "line": 406,
          "content": "        if status_text is None:"
        },
        {
          "line": 416,
          "content": "    if ENABLE_DEBUG_AI_CODE:"
        },
        {
          "line": 420,
          "content": "def save_brand_test_result(brand_test_result):"
        },
        {
          "line": 421,
          "content": "    \"\"\"保存品牌测试结果\"\"\""
        },
        {
          "line": 435,
          "content": "    # Extract execution_id from task_id if it contains one (for DEBUG_AI_CODE logging)"
        },
        {
          "line": 458,
          "content": "        ''', ("
        },
        {
          "line": 476,
          "content": "        ''', ("
        },
        {
          "line": 498,
          "content": "    \"\"\"获取品牌测试结果\"\"\""
        },
        {
          "line": 499,
          "content": "    if not sql_protector.validate_input(task_id):"
        },
        {
          "line": 502,
          "content": "    db_logger.info(f\"Retrieving brand test result for task: {task_id}\")"
        },
        {
          "line": 511,
          "content": "    ''', (task_id,))"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/log_level_config.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "\"\"\""
        },
        {
          "line": 47,
          "content": "    \"\"\""
        },
        {
          "line": 55,
          "content": "    \"\"\""
        },
        {
          "line": 72,
          "content": "    \"\"\""
        },
        {
          "line": 77,
          "content": "    \"\"\""
        },
        {
          "line": 95,
          "content": "    \"\"\""
        },
        {
          "line": 103,
          "content": "    \"\"\""
        },
        {
          "line": 109,
          "content": "    \"\"\""
        },
        {
          "line": 117,
          "content": "    \"\"\""
        },
        {
          "line": 142,
          "content": "\"\"\""
        },
        {
          "line": 145,
          "content": "if __name__ == '__main__':"
        },
        {
          "line": 154,
          "content": "    for module, level in MODULE_LOG_LEVELS.items():"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/database_index_optimizer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "\"\"\""
        },
        {
          "line": 35,
          "content": "    \"\"\"获取数据库连接\"\"\""
        },
        {
          "line": 38,
          "content": "    return conn"
        },
        {
          "line": 41,
          "content": "def create_index_if_not_exists(conn, index_name, table_name, columns, unique=False):"
        },
        {
          "line": 42,
          "content": "    \"\"\""
        },
        {
          "line": 51,
          "content": "    \"\"\""
        },
        {
          "line": 52,
          "content": "    if isinstance(columns, list):"
        },
        {
          "line": 57,
          "content": "    unique_str = 'UNIQUE' if unique else ''"
        },
        {
          "line": 62,
          "content": "    \"\"\""
        },
        {
          "line": 76,
          "content": "    \"\"\""
        },
        {
          "line": 83,
          "content": "    \"\"\""
        },
        {
          "line": 216,
          "content": "    \"\"\""
        },
        {
          "line": 225,
          "content": "    \"\"\""
        },
        {
          "line": 233,
          "content": "    \"\"\""
        },
        {
          "line": 242,
          "content": "    \"\"\""
        },
        {
          "line": 250,
          "content": "    \"\"\""
        },
        {
          "line": 252,
          "content": "    \"\"\""
        },
        {
          "line": 269,
          "content": "    \"\"\""
        },
        {
          "line": 274,
          "content": "    \"\"\""
        },
        {
          "line": 286,
          "content": "        \"\"\")"
        },
        {
          "line": 291,
          "content": "        for idx in indexes:"
        },
        {
          "line": 298,
          "content": "        return stats"
        },
        {
          "line": 304,
          "content": "if __name__ == '__main__':"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/smart_circuit_breaker.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "\"\"\""
        },
        {
          "line": 25,
          "content": "    \"\"\"熔断状态\"\"\""
        },
        {
          "line": 31,
          "content": "class SmartCircuitBreaker:"
        },
        {
          "line": 32,
          "content": "    \"\"\"智能熔断器\"\"\""
        },
        {
          "line": 51,
          "content": "        \"\"\"生成熔断键 (模型 + 品牌)\"\"\""
        },
        {
          "line": 52,
          "content": "        return f\"{model}:{brand}\""
        },
        {
          "line": 54,
          "content": "    def is_available(self, model: str, brand: str) -> bool:"
        },
        {
          "line": 55,
          "content": "        \"\"\"检查是否可用\"\"\""
        },
        {
          "line": 84,
          "content": "        \"\"\"记录成功\"\"\""
        },
        {
          "line": 90,
          "content": "    def record_failure(self, model: str, brand: str):"
        },
        {
          "line": 91,
          "content": "        \"\"\"记录失败\"\"\""
        },
        {
          "line": 108,
          "content": "        \"\"\"获取状态 (用于监控)\"\"\""
        },
        {
          "line": 112,
          "content": "        return f\"{state.value} (失败{failure_count}次)\""
        },
        {
          "line": 124,
          "content": "def is_model_available(model: str, brand: str) -> bool:"
        },
        {
          "line": 125,
          "content": "    \"\"\"检查模型是否可用\"\"\""
        },
        {
          "line": 130,
          "content": "    \"\"\"记录模型成功\"\"\""
        },
        {
          "line": 134,
          "content": "def record_model_failure(model: str, brand: str):"
        },
        {
          "line": 135,
          "content": "    \"\"\"记录模型失败\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/admin_test_management.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 24,
          "content": "    \"\"\"检查用户是否为管理员\"\"\""
        },
        {
          "line": 25,
          "content": "    if not user_id or user_id == 'anonymous':"
        },
        {
          "line": 26,
          "content": "        return False"
        },
        {
          "line": 34,
          "content": "        ''', (user_id,))"
        },
        {
          "line": 43,
          "content": "    \"\"\"装饰器：要求管理员权限\"\"\""
        },
        {
          "line": 44,
          "content": "    from functools import wraps"
        },
        {
          "line": 47,
          "content": "    def decorated_function(*args, **kwargs):"
        },
        {
          "line": 49,
          "content": "        if not is_admin_user(user_id):"
        },
        {
          "line": 50,
          "content": "            return jsonify({'error': 'Admin access required'}), 403"
        },
        {
          "line": 51,
          "content": "        return f(*args, **kwargs)"
        },
        {
          "line": 53,
          "content": "    return decorated_function"
        },
        {
          "line": 59,
          "content": "def get_all_tests():"
        },
        {
          "line": 60,
          "content": "    \"\"\"获取所有测试记录\"\"\""
        },
        {
          "line": 76,
          "content": "        ''', (page_size, offset))"
        },
        {
          "line": 77,
          "content": "        tests = [dict(row) for row in cursor.fetchall()]"
        },
        {
          "line": 84,
          "content": "        return jsonify({"
        },
        {
          "line": 93,
          "content": "        return jsonify({'error': str(e)}), 500"
        },
        {
          "line": 99,
          "content": "def get_ai_platforms():"
        },
        {
          "line": 100,
          "content": "    \"\"\"获取 AI 平台配置\"\"\""
        },
        {
          "line": 125,
          "content": "    \"\"\"批量删除测试记录\"\"\""
        },
        {
          "line": 132,
          "content": "        if not test_ids:"
        },
        {
          "line": 133,
          "content": "            return jsonify({'error': 'test_ids is required'}), 400"
        },
        {
          "line": 146,
          "content": "        return jsonify({"
        },
        {
          "line": 153,
          "content": "        return jsonify({'error': str(e)}), 500"
        },
        {
          "line": 159,
          "content": "def batch_user_action():"
        },
        {
          "line": 160,
          "content": "    \"\"\"批量用户操作\"\"\""
        },
        {
          "line": 177,
          "content": "            '''.format(','.join('?' * len(user_ids))), user_ids)"
        },
        {
          "line": 179,
          "content": "        elif action == 'deactivate':"
        },
        {
          "line": 182,
          "content": "            '''.format(','.join('?' * len(user_ids))), user_ids)"
        },
        {
          "line": 210,
          "content": "    \"\"\"批量发送通知\"\"\""
        },
        {
          "line": 219,
          "content": "        if not user_ids or not message:"
        },
        {
          "line": 220,
          "content": "            return jsonify({'error': 'user_ids and message are required'}), 400"
        },
        {
          "line": 226,
          "content": "        for user_id in user_ids:"
        },
        {
          "line": 230,
          "content": "            ''', (user_id, message, notification_type, datetime.now().isoformat()))"
        },
        {
          "line": 247,
          "content": "    \"\"\"注册测试管理路由\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/log_config.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "    \"\"\"日志级别\"\"\""
        },
        {
          "line": 21,
          "content": "class LogConfig:"
        },
        {
          "line": 22,
          "content": "    \"\"\"日志配置管理器\"\"\""
        },
        {
          "line": 38,
          "content": "        \"\"\"配置日志系统\"\"\""
        },
        {
          "line": 41,
          "content": "        log_level_str = os.getenv('LOG_LEVEL', 'DEBUG' if env == 'development' else 'INFO')"
        },
        {
          "line": 57,
          "content": "        if env == 'production':"
        },
        {
          "line": 62,
          "content": "def get_logger(name: str) -> logging.Logger:"
        },
        {
          "line": 63,
          "content": "    \"\"\""
        },
        {
          "line": 71,
          "content": "    \"\"\""
        },
        {
          "line": 74,
          "content": "    return logging.getLogger(name)"
        },
        {
          "line": 77,
          "content": "def set_log_level(level: int):"
        },
        {
          "line": 78,
          "content": "    \"\"\""
        },
        {
          "line": 83,
          "content": "    \"\"\""
        },
        {
          "line": 87,
          "content": "def set_production_mode():"
        },
        {
          "line": 88,
          "content": "    \"\"\"切换到生产环境模式\"\"\""
        },
        {
          "line": 94,
          "content": "    \"\"\"切换到开发环境模式\"\"\""
        },
        {
          "line": 100,
          "content": "def debug(msg: str, *args, **kwargs):"
        },
        {
          "line": 101,
          "content": "    \"\"\"DEBUG 级别日志\"\"\""
        },
        {
          "line": 106,
          "content": "    \"\"\"INFO 级别日志\"\"\""
        },
        {
          "line": 110,
          "content": "def warning(msg: str, *args, **kwargs):"
        },
        {
          "line": 111,
          "content": "    \"\"\"WARNING 级别日志\"\"\""
        },
        {
          "line": 116,
          "content": "    \"\"\"ERROR 级别日志\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/alert_system.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 36,
          "content": "    \"\"\"告警严重程度\"\"\""
        },
        {
          "line": 43,
          "content": "class AlertCondition:"
        },
        {
          "line": 44,
          "content": "    \"\"\"告警条件\"\"\""
        },
        {
          "line": 53,
          "content": "        \"\"\"检查是否触发告警\"\"\""
        },
        {
          "line": 54,
          "content": "        return value >= self.threshold"
        },
        {
          "line": 56,
          "content": "    def trigger(self, value: float):"
        },
        {
          "line": 57,
          "content": "        \"\"\"触发告警\"\"\""
        },
        {
          "line": 64,
          "content": "    \"\"\"告警\"\"\""
        },
        {
          "line": 66,
          "content": "    def __init__(self, name: str, message: str, severity: AlertSeverity = AlertSeverity.MEDIUM):"
        },
        {
          "line": 73,
          "content": "    def acknowledge(self):"
        },
        {
          "line": 74,
          "content": "        \"\"\"确认告警\"\"\""
        },
        {
          "line": 80,
          "content": "    \"\"\"告警系统\"\"\""
        },
        {
          "line": 82,
          "content": "    def __init__(self):"
        },
        {
          "line": 87,
          "content": "    def add_condition(self, condition: AlertCondition):"
        },
        {
          "line": 88,
          "content": "        \"\"\"添加告警条件\"\"\""
        },
        {
          "line": 93,
          "content": "        \"\"\"检查所有条件\"\"\""
        },
        {
          "line": 94,
          "content": "        if not self.enabled:"
        },
        {
          "line": 97,
          "content": "        for condition in self.conditions:"
        },
        {
          "line": 98,
          "content": "            if condition.name == metric_name and condition.check(value):"
        },
        {
          "line": 106,
          "content": "    def create_alert(self, name: str, message: str, severity: AlertSeverity = AlertSeverity.MEDIUM):"
        },
        {
          "line": 107,
          "content": "        \"\"\"创建告警\"\"\""
        },
        {
          "line": 113,
          "content": "        \"\"\"获取活跃的告警\"\"\""
        },
        {
          "line": 114,
          "content": "        return [a for a in self.alerts if not a.acknowledged]"
        },
        {
          "line": 116,
          "content": "    def enable(self):"
        },
        {
          "line": 117,
          "content": "        \"\"\"启用告警系统\"\"\""
        },
        {
          "line": 122,
          "content": "        \"\"\"禁用告警系统\"\"\""
        },
        {
          "line": 131,
          "content": "def get_alert_system() -> AlertSystem:"
        },
        {
          "line": 132,
          "content": "    \"\"\"获取告警系统实例\"\"\""
        },
        {
          "line": 140,
          "content": "    \"\"\"初始化默认告警\"\"\""
        },
        {
          "line": 165,
          "content": "def start_alert_monitoring():"
        },
        {
          "line": 166,
          "content": "    \"\"\"启动告警监控\"\"\""
        },
        {
          "line": 178,
          "content": "    \"\"\""
        },
        {
          "line": 193,
          "content": "    \"\"\""
        },
        {
          "line": 253,
          "content": "    \"\"\""
        },
        {
          "line": 261,
          "content": "    \"\"\""
        },
        {
          "line": 280,
          "content": "    \"\"\""
        },
        {
          "line": 285,
          "content": "    \"\"\""
        },
        {
          "line": 301,
          "content": "    \"\"\""
        },
        {
          "line": 308,
          "content": "    \"\"\""
        },
        {
          "line": 357,
          "content": "    \"\"\""
        },
        {
          "line": 366,
          "content": "    \"\"\""
        },
        {
          "line": 413,
          "content": "        \"\"\""
        },
        {
          "line": 425,
          "content": "        return True"
        },
        {
          "line": 429,
          "content": "        return False"
        },
        {
          "line": 432,
          "content": "def send_alert_notification(alert: Alert):"
        },
        {
          "line": 433,
          "content": "    \"\"\""
        },
        {
          "line": 438,
          "content": "    \"\"\""
        },
        {
          "line": 443,
          "content": "    if alert.severity in [AlertSeverity.HIGH, AlertSeverity.CRITICAL]:"
        },
        {
          "line": 447,
          "content": "    elif alert.severity == AlertSeverity.MEDIUM:"
        },
        {
          "line": 458,
          "content": "def _enhanced_create_alert(self, name: str, message: str, severity: AlertSeverity = AlertSeverity.MEDIUM):"
        },
        {
          "line": 459,
          "content": "    \"\"\"增强的 create_alert 方法，集成告警通知\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_p2_optimization.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        },
        {
          "line": 33,
          "content": "    \"\"\"趋势预测数据模型\"\"\""
        },
        {
          "line": 36,
          "content": "    def from_execution_id(execution_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 37,
          "content": "        \"\"\"从 execution_id 获取趋势预测数据\"\"\""
        },
        {
          "line": 45,
          "content": "        ''', (execution_id,))"
        },
        {
          "line": 47,
          "content": "        if not result:"
        },
        {
          "line": 48,
          "content": "            return None"
        },
        {
          "line": 69,
          "content": "        return {"
        },
        {
          "line": 76,
          "content": "            'trend': 'improving' if health_score > 50 else 'declining',"
        },
        {
          "line": 84,
          "content": "    def _generate_forecast(current_score, start_date) -> List[Dict[str, Any]]:"
        },
        {
          "line": 85,
          "content": "        \"\"\"生成预测点\"\"\""
        },
        {
          "line": 109,
          "content": "        \"\"\"生成情景分析\"\"\""
        },
        {
          "line": 110,
          "content": "        return {"
        },
        {
          "line": 129,
          "content": "    def _calculate_confidence_interval(current_score) -> Dict[str, Any]:"
        },
        {
          "line": 130,
          "content": "        \"\"\"计算置信区间\"\"\""
        },
        {
          "line": 147,
          "content": "        \"\"\"计算趋势强度\"\"\""
        },
        {
          "line": 148,
          "content": "        if current_score >= 80:"
        },
        {
          "line": 149,
          "content": "            return 'strong'"
        },
        {
          "line": 150,
          "content": "        elif current_score >= 60:"
        },
        {
          "line": 151,
          "content": "            return 'moderate'"
        },
        {
          "line": 152,
          "content": "        elif current_score >= 40:"
        },
        {
          "line": 153,
          "content": "            return 'weak'"
        },
        {
          "line": 155,
          "content": "            return 'very_weak'"
        },
        {
          "line": 158,
          "content": "    def _identify_inflection_points(current_score) -> List[Dict[str, Any]]:"
        },
        {
          "line": 159,
          "content": "        \"\"\"识别拐点\"\"\""
        },
        {
          "line": 181,
          "content": "    \"\"\"货币化分析数据模型\"\"\""
        },
        {
          "line": 184,
          "content": "    def from_execution_id(execution_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 185,
          "content": "        \"\"\"从 execution_id 获取货币化分析数据\"\"\""
        },
        {
          "line": 193,
          "content": "        ''', (execution_id,))"
        },
        {
          "line": 195,
          "content": "        if not result:"
        },
        {
          "line": 196,
          "content": "            return None"
        },
        {
          "line": 209,
          "content": "        return {"
        },
        {
          "line": 228,
          "content": "    def _calculate_media_value(total_mentions, avg_sentiment) -> float:"
        },
        {
          "line": 229,
          "content": "        \"\"\"估算媒体价值\"\"\""
        },
        {
          "line": 239,
          "content": "        \"\"\"计算单次曝光成本\"\"\""
        },
        {
          "line": 240,
          "content": "        if total_mentions == 0:"
        },
        {
          "line": 241,
          "content": "            return 0"
        },
        {
          "line": 245,
          "content": "        return round(total_cost / total_mentions, 2)"
        },
        {
          "line": 248,
          "content": "    def _analyze_organic_vs_paid(total_mentions) -> Dict[str, Any]:"
        },
        {
          "line": 249,
          "content": "        \"\"\"分析自然流量与付费流量比例\"\"\""
        },
        {
          "line": 263,
          "content": "        \"\"\"预测 ROI\"\"\""
        },
        {
          "line": 272,
          "content": "        return {"
        },
        {
          "line": 279,
          "content": "    def _platform_breakdown(total_mentions) -> Dict[str, Any]:"
        },
        {
          "line": 280,
          "content": "        \"\"\"平台分布\"\"\""
        },
        {
          "line": 301,
          "content": "        \"\"\"情感分布\"\"\""
        },
        {
          "line": 306,
          "content": "        return {"
        },
        {
          "line": 322,
          "content": "    def _generate_recommendations(media_value, roi_projection) -> List[Dict[str, Any]]:"
        },
        {
          "line": 323,
          "content": "        \"\"\"生成优化建议\"\"\""
        },
        {
          "line": 353,
          "content": "    \"\"\"获取趋势预测增强数据\"\"\""
        },
        {
          "line": 359,
          "content": "        if not data:"
        },
        {
          "line": 360,
          "content": "            return jsonify({"
        },
        {
          "line": 366,
          "content": "        return jsonify({"
        },
        {
          "line": 373,
          "content": "        return jsonify({"
        },
        {
          "line": 380,
          "content": "        return jsonify({"
        },
        {
          "line": 388,
          "content": "def get_monetization_analysis(execution_id: str):"
        },
        {
          "line": 389,
          "content": "    \"\"\"获取货币化分析\"\"\""
        },
        {
          "line": 428,
          "content": "    \"\"\"初始化 P2 优化路由\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/realtime_persistence_original.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "\"\"\""
        },
        {
          "line": 25,
          "content": "    \"\"\"实时结果持久化服务\"\"\""
        },
        {
          "line": 27,
          "content": "    def __init__(self, execution_id: str, user_openid: str):"
        },
        {
          "line": 28,
          "content": "        \"\"\""
        },
        {
          "line": 34,
          "content": "        \"\"\""
        },
        {
          "line": 41,
          "content": "    def save_task_result(self, task_data: Dict[str, Any]) -> bool:"
        },
        {
          "line": 42,
          "content": "        \"\"\""
        },
        {
          "line": 50,
          "content": "        \"\"\""
        },
        {
          "line": 55,
          "content": "        if task_key in self.saved_tasks:"
        },
        {
          "line": 57,
          "content": "            return False"
        },
        {
          "line": 74,
          "content": "                'error': task_data.get('error', '') if status != 'success' else '',"
        },
        {
          "line": 101,
          "content": "            return True"
        },
        {
          "line": 105,
          "content": "            return False"
        },
        {
          "line": 107,
          "content": "    def save_aggregated_results(self, aggregated_results: Dict[str, Any]) -> bool:"
        },
        {
          "line": 108,
          "content": "        \"\"\""
        },
        {
          "line": 116,
          "content": "        \"\"\""
        },
        {
          "line": 151,
          "content": "            if existing:"
        },
        {
          "line": 159,
          "content": "                ''', ("
        },
        {
          "line": 173,
          "content": "                ''', ("
        },
        {
          "line": 177,
          "content": "                api_logger.info(f\"Inserted aggregated results for execution: {self.execution_id}\")"
        },
        {
          "line": 179,
          "content": "            return True"
        },
        {
          "line": 183,
          "content": "            return False"
        },
        {
          "line": 185,
          "content": "    def save_brand_rankings(self, brand_rankings: List[Dict[str, Any]]) -> bool:"
        },
        {
          "line": 186,
          "content": "        \"\"\""
        },
        {
          "line": 194,
          "content": "        \"\"\""
        },
        {
          "line": 198,
          "content": "            for ranking in brand_rankings:"
        },
        {
          "line": 212,
          "content": "                if existing:"
        },
        {
          "line": 220,
          "content": "                    ''', ("
        },
        {
          "line": 231,
          "content": "                    ''', ("
        },
        {
          "line": 237,
          "content": "            return True"
        },
        {
          "line": 241,
          "content": "            return False"
        },
        {
          "line": 243,
          "content": "    def get_saved_tasks_count(self) -> int:"
        },
        {
          "line": 244,
          "content": "        \"\"\"获取已保存的任务数量\"\"\""
        },
        {
          "line": 248,
          "content": "        \"\"\"生成任务键\"\"\""
        },
        {
          "line": 253,
          "content": "        return f\"{brand}_{model}_{question}\""
        },
        {
          "line": 255,
          "content": "    def get_stats(self) -> Dict[str, Any]:"
        },
        {
          "line": 256,
          "content": "        \"\"\"获取持久化统计\"\"\""
        },
        {
          "line": 269,
          "content": "    \"\"\"获取指定执行 ID 的持久化服务\"\"\""
        },
        {
          "line": 270,
          "content": "    return _persistence_services.get(execution_id)"
        },
        {
          "line": 273,
          "content": "def create_persistence_service("
        },
        {
          "line": 277,
          "content": "    \"\"\"创建并注册持久化服务\"\"\""
        },
        {
          "line": 285,
          "content": "    \"\"\"移除持久化服务\"\"\""
        },
        {
          "line": 286,
          "content": "    if execution_id in _persistence_services:"
        },
        {
          "line": 288,
          "content": "        api_logger.info(f\"Removed RealtimePersistence for execution: {execution_id}, saved {stats['saved_tasks']} tasks\")"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/diagnosis_report_repository.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "\"\"\""
        },
        {
          "line": 53,
          "content": "    \"\"\"计算数据 SHA256 校验和\"\"\""
        },
        {
          "line": 55,
          "content": "    return hashlib.sha256(json_str.encode('utf-8')).hexdigest()"
        },
        {
          "line": 58,
          "content": "def verify_checksum(data: Dict[str, Any], checksum: str) -> bool:"
        },
        {
          "line": 59,
          "content": "    \"\"\"验证数据完整性\"\"\""
        },
        {
          "line": 64,
          "content": "    \"\"\"获取服务器版本号\"\"\""
        },
        {
          "line": 65,
          "content": "    return os.getenv('SERVER_VERSION', '2.0.0')"
        },
        {
          "line": 68,
          "content": "def get_file_archive_path(execution_id: str, created_at: datetime) -> str:"
        },
        {
          "line": 69,
          "content": "    \"\"\"获取文件归档路径\"\"\""
        },
        {
          "line": 86,
          "content": "    \"\"\""
        },
        {
          "line": 93,
          "content": "    \"\"\""
        },
        {
          "line": 97,
          "content": "        \"\"\"获取数据库连接\"\"\""
        },
        {
          "line": 109,
          "content": "    def create(self, execution_id: str, user_id: str, config: Dict[str, Any]) -> int:"
        },
        {
          "line": 110,
          "content": "        \"\"\""
        },
        {
          "line": 120,
          "content": "        \"\"\""
        },
        {
          "line": 139,
          "content": "            ''', ("
        },
        {
          "line": 163,
          "content": "        \"\"\""
        },
        {
          "line": 172,
          "content": "        \"\"\""
        },
        {
          "line": 182,
          "content": "            ''', ("
        },
        {
          "line": 183,
          "content": "                status, progress, stage, 1 if is_completed else 0, now,"
        },
        {
          "line": 184,
          "content": "                1 if is_completed else 0, now,"
        },
        {
          "line": 189,
          "content": "            return cursor.rowcount > 0"
        },
        {
          "line": 191,
          "content": "    def update_status_sync(self, execution_id: str, status: str, progress: int = None,"
        },
        {
          "line": 193,
          "content": "        \"\"\""
        },
        {
          "line": 203,
          "content": "        \"\"\""
        },
        {
          "line": 218,
          "content": "        if progress is None:"
        },
        {
          "line": 229,
          "content": "        return self.update_status(execution_id, status, progress, stage, is_completed)"
        },
        {
          "line": 231,
          "content": "    def get_by_execution_id(self, execution_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 232,
          "content": "        \"\"\"根据执行 ID 获取报告\"\"\""
        },
        {
          "line": 249,
          "content": "        \"\"\""
        },
        {
          "line": 257,
          "content": "        \"\"\""
        },
        {
          "line": 268,
          "content": "        \"\"\"获取用户历史报告\"\"\""
        },
        {
          "line": 279,
          "content": "            ''', (user_id, limit, offset))"
        },
        {
          "line": 290,
          "content": "        \"\"\"创建报告快照\"\"\""
        },
        {
          "line": 301,
          "content": "            ''', ("
        },
        {
          "line": 316,
          "content": "    \"\"\""
        },
        {
          "line": 323,
          "content": "    \"\"\""
        },
        {
          "line": 327,
          "content": "        \"\"\"获取数据库连接\"\"\""
        },
        {
          "line": 339,
          "content": "    def add(self, report_id: int, execution_id: str, result: Dict[str, Any]) -> int:"
        },
        {
          "line": 340,
          "content": "        \"\"\"添加单个诊断结果（完整版 - Migration 004）"
        },
        {
          "line": 356,
          "content": "        \"\"\""
        },
        {
          "line": 364,
          "content": "        first_choice = choices[0] if choices else {}"
        },
        {
          "line": 384,
          "content": "            ''', ("
        },
        {
          "line": 422,
          "content": "        \"\"\"批量添加诊断结果\"\"\""
        },
        {
          "line": 424,
          "content": "        for result in results:"
        },
        {
          "line": 427,
          "content": "        return result_ids"
        },
        {
          "line": 429,
          "content": "    def get_by_execution_id(self, execution_id: str) -> List[Dict[str, Any]]:"
        },
        {
          "line": 430,
          "content": "        \"\"\"根据执行 ID 获取所有结果\"\"\""
        },
        {
          "line": 438,
          "content": "            ''', (execution_id,))"
        },
        {
          "line": 441,
          "content": "            for row in cursor.fetchall():"
        },
        {
          "line": 453,
          "content": "            return results"
        },
        {
          "line": 455,
          "content": "    def get_by_report_id(self, report_id: int) -> List[Dict[str, Any]]:"
        },
        {
          "line": 456,
          "content": "        \"\"\"根据报告 ID 获取所有结果\"\"\""
        },
        {
          "line": 464,
          "content": "            ''', (report_id,))"
        },
        {
          "line": 467,
          "content": "            for row in cursor.fetchall():"
        },
        {
          "line": 477,
          "content": "            return results"
        },
        {
          "line": 480,
          "content": "class DiagnosisAnalysisRepository:"
        },
        {
          "line": 481,
          "content": "    \"\"\""
        },
        {
          "line": 487,
          "content": "    \"\"\""
        },
        {
          "line": 490,
          "content": "    def get_connection(self):"
        },
        {
          "line": 491,
          "content": "        \"\"\"获取数据库连接\"\"\""
        },
        {
          "line": 505,
          "content": "        \"\"\"添加分析数据\"\"\""
        },
        {
          "line": 516,
          "content": "            ''', ("
        },
        {
          "line": 530,
          "content": "        \"\"\"批量添加分析数据\"\"\""
        },
        {
          "line": 532,
          "content": "        for analysis_type, analysis_data in analyses.items():"
        },
        {
          "line": 535,
          "content": "        return analysis_ids"
        },
        {
          "line": 537,
          "content": "    def get_by_execution_id(self, execution_id: str) -> Dict[str, Any]:"
        },
        {
          "line": 538,
          "content": "        \"\"\"根据执行 ID 获取所有分析数据\"\"\""
        },
        {
          "line": 546,
          "content": "            ''', (execution_id,))"
        },
        {
          "line": 549,
          "content": "            for row in cursor.fetchall():"
        },
        {
          "line": 554,
          "content": "            return analysis"
        },
        {
          "line": 559,
          "content": "class FileArchiveManager:"
        },
        {
          "line": 560,
          "content": "    \"\"\""
        },
        {
          "line": 568,
          "content": "    \"\"\""
        },
        {
          "line": 570,
          "content": "    def save_report(self, execution_id: str, report_data: Dict[str, Any],"
        },
        {
          "line": 572,
          "content": "        \"\"\"保存报告到文件\"\"\""
        },
        {
          "line": 594,
          "content": "        \"\"\"保存品牌分析结果\"\"\""
        },
        {
          "line": 604,
          "content": "                           ''', ("
        },
        {
          "line": 616,
          "content": "        \"\"\"归档报告（压缩）\"\"\""
        },
        {
          "line": 629,
          "content": "        return filepath"
        },
        {
          "line": 631,
          "content": "    def get_report(self, execution_id: str, created_at: datetime) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 632,
          "content": "        \"\"\"从文件读取报告\"\"\""
        },
        {
          "line": 648,
          "content": "        \"\"\"清理旧文件（移动到归档）\"\"\""
        },
        {
          "line": 657,
          "content": "        for year_dir in os.listdir(REPORTS_DIR):"
        },
        {
          "line": 659,
          "content": "            if not os.path.isdir(year_path):"
        },
        {
          "line": 662,
          "content": "            for month_dir in os.listdir(year_path):"
        },
        {
          "line": 664,
          "content": "                if not os.path.isdir(month_path):"
        },
        {
          "line": 667,
          "content": "                for day_dir in os.listdir(month_path):"
        },
        {
          "line": 669,
          "content": "                    if not os.path.isdir(day_path):"
        },
        {
          "line": 675,
          "content": "                        if file_date < cutoff_date:"
        },
        {
          "line": 682,
          "content": "                            for filename in os.listdir(day_path):"
        },
        {
          "line": 683,
          "content": "                                if filename.endswith('.json'):"
        },
        {
          "line": 696,
          "content": "                            if not os.listdir(day_path):"
        },
        {
          "line": 698,
          "content": "                                if not os.listdir(month_path):"
        },
        {
          "line": 700,
          "content": "                                    if not os.listdir(year_path):"
        },
        {
          "line": 707,
          "content": "        return stats"
        },
        {
          "line": 712,
          "content": "def delete_diagnosis_report_by_execution_id(execution_id: str) -> bool:"
        },
        {
          "line": 713,
          "content": "    \"\"\""
        },
        {
          "line": 721,
          "content": "    \"\"\""
        },
        {
          "line": 723,
          "content": "    return repo.delete_by_execution_id(execution_id)"
        },
        {
          "line": 728,
          "content": "def init_database_tables():"
        },
        {
          "line": 729,
          "content": "    \"\"\"初始化数据库表（如果尚未创建）\"\"\""
        },
        {
          "line": 768,
          "content": "    \"\"\"获取全局诊断报告仓库实例\"\"\""
        },
        {
          "line": 770,
          "content": "    if _report_repo is None:"
        },
        {
          "line": 772,
          "content": "    return _report_repo"
        },
        {
          "line": 775,
          "content": "def save_diagnosis_report("
        },
        {
          "line": 780,
          "content": "    \"\"\""
        },
        {
          "line": 782,
          "content": "    \"\"\""
        },
        {
          "line": 786,
          "content": "    if existing:"
        },
        {
          "line": 789,
          "content": "        return existing['id']"
        },
        {
          "line": 798,
          "content": "        if is_completed:"
        },
        {
          "line": 801,
          "content": "        return report_id"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/recommendation_generator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\"建议优先级枚举\"\"\""
        },
        {
          "line": 21,
          "content": "class RecommendationType(Enum):"
        },
        {
          "line": 22,
          "content": "    \"\"\"建议类型枚举\"\"\""
        },
        {
          "line": 31,
          "content": "    \"\"\"单条建议的数据结构\"\"\""
        },
        {
          "line": 42,
          "content": "class RecommendationGenerator:"
        },
        {
          "line": 43,
          "content": "    \"\"\"干预建议生成器\"\"\""
        },
        {
          "line": 56,
          "content": "        \"\"\""
        },
        {
          "line": 66,
          "content": "        \"\"\""
        },
        {
          "line": 95,
          "content": "        \"\"\""
        },
        {
          "line": 105,
          "content": "        \"\"\""
        },
        {
          "line": 138,
          "content": "        \"\"\""
        },
        {
          "line": 147,
          "content": "        \"\"\""
        },
        {
          "line": 183,
          "content": "        \"\"\""
        },
        {
          "line": 192,
          "content": "        \"\"\""
        },
        {
          "line": 203,
          "content": "        \"\"\""
        },
        {
          "line": 210,
          "content": "            if platform_config and platform_config.api_key:"
        },
        {
          "line": 217,
          "content": "                if response.success:"
        },
        {
          "line": 218,
          "content": "                    return response.content.strip()"
        },
        {
          "line": 228,
          "content": "        return f\"我们注意到有关{brand_name}的某些讨论。我们始终致力于为用户提供优质的产品和服务，并将持续改进以满足用户需求。\""
        },
        {
          "line": 230,
          "content": "    def _generate_source_attack_recommendations("
        },
        {
          "line": 235,
          "content": "        \"\"\""
        },
        {
          "line": 244,
          "content": "        \"\"\""
        },
        {
          "line": 247,
          "content": "        for source in high_priority_sources:"
        },
        {
          "line": 252,
          "content": "            priority = RecommendationPriority.HIGH if citation_count > 10 else \\"
        },
        {
          "line": 253,
          "content": "                      RecommendationPriority.MEDIUM if citation_count > 5 else \\"
        },
        {
          "line": 268,
          "content": "                urgency=9 if citation_count > 10 else 7 if citation_count > 5 else 5"
        },
        {
          "line": 272,
          "content": "        return recommendations"
        },
        {
          "line": 274,
          "content": "    def _generate_brand_strengthening_recommendations(self, brand_name: str) -> List[Recommendation]:"
        },
        {
          "line": 275,
          "content": "        \"\"\""
        },
        {
          "line": 283,
          "content": "        \"\"\""
        },
        {
          "line": 302,
          "content": "        return recommendations"
        },
        {
          "line": 304,
          "content": "    def _priority_to_int(self, priority: RecommendationPriority) -> int:"
        },
        {
          "line": 305,
          "content": "        \"\"\"将优先级转换为整数以便排序\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/database_query_optimizer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 28,
          "content": "    \"\"\""
        },
        {
          "line": 35,
          "content": "    \"\"\""
        },
        {
          "line": 45,
          "content": "        \"\"\""
        },
        {
          "line": 58,
          "content": "        \"\"\""
        },
        {
          "line": 87,
          "content": "        \"\"\""
        },
        {
          "line": 91,
          "content": "        columns = [description[0] for description in cursor.description]"
        },
        {
          "line": 92,
          "content": "        records = [dict(zip(columns, row)) for row in cursor.fetchall()]"
        },
        {
          "line": 94,
          "content": "        return records, total"
        },
        {
          "line": 97,
          "content": "    def get_task_status_for_polling("
        },
        {
          "line": 101,
          "content": "        \"\"\""
        },
        {
          "line": 110,
          "content": "        \"\"\""
        },
        {
          "line": 119,
          "content": "        \"\"\""
        },
        {
          "line": 131,
          "content": "        \"\"\""
        },
        {
          "line": 140,
          "content": "        \"\"\""
        },
        {
          "line": 149,
          "content": "        \"\"\""
        },
        {
          "line": 152,
          "content": "        columns = [description[0] for description in cursor.description]"
        },
        {
          "line": 153,
          "content": "        return [dict(zip(columns, row)) for row in cursor.fetchall()]"
        },
        {
          "line": 156,
          "content": "    def get_brand_analysis("
        },
        {
          "line": 161,
          "content": "        \"\"\""
        },
        {
          "line": 171,
          "content": "        \"\"\""
        },
        {
          "line": 187,
          "content": "        \"\"\""
        },
        {
          "line": 209,
          "content": "        \"\"\""
        },
        {
          "line": 219,
          "content": "        \"\"\""
        },
        {
          "line": 233,
          "content": "        \"\"\""
        },
        {
          "line": 237,
          "content": "        if not row:"
        },
        {
          "line": 238,
          "content": "            return {'error': 'No data found'}"
        },
        {
          "line": 240,
          "content": "        columns = [description[0] for description in cursor.description]"
        },
        {
          "line": 243,
          "content": "        return {"
        },
        {
          "line": 250,
          "content": "    def optimize_database(conn: sqlite3.Connection):"
        },
        {
          "line": 251,
          "content": "        \"\"\""
        },
        {
          "line": 256,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/__init__.py",
      "lines": [
        {
          "line": 5,
          "content": "    \"\"\"获取 app 实例\"\"\""
        },
        {
          "line": 7,
          "content": "    if _app is None:"
        },
        {
          "line": 8,
          "content": "        from wechat_backend.app import app"
        },
        {
          "line": 10,
          "content": "    return _app"
        },
        {
          "line": 12,
          "content": "def create_app():"
        },
        {
          "line": 13,
          "content": "    \"\"\"创建并返回 app 实例\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_admin.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 22,
          "content": "    \"\"\""
        },
        {
          "line": 27,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/database_retry.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 21,
          "content": "    \"\"\"数据库重试失败异常\"\"\""
        },
        {
          "line": 22,
          "content": "    def __init__(self, message: str, attempts: int, last_error: Exception):"
        },
        {
          "line": 28,
          "content": "def retry_database_operation("
        },
        {
          "line": 35,
          "content": "    \"\"\""
        },
        {
          "line": 50,
          "content": "    \"\"\""
        },
        {
          "line": 51,
          "content": "    def decorator(func: Callable) -> Callable:"
        },
        {
          "line": 53,
          "content": "        def wrapper(*args, **kwargs) -> Any:"
        },
        {
          "line": 56,
          "content": "            for attempt in range(max_retries + 1):"
        },
        {
          "line": 61,
          "content": "                    if attempt > 0:"
        },
        {
          "line": 66,
          "content": "                    return result"
        },
        {
          "line": 77,
          "content": "                    if should_retry:"
        },
        {
          "line": 79,
          "content": "                        import random"
        },
        {
          "line": 112,
          "content": "        return wrapper"
        },
        {
          "line": 113,
          "content": "    return decorator"
        },
        {
          "line": 116,
          "content": "def _is_retryable_error(error: Exception) -> bool:"
        },
        {
          "line": 117,
          "content": "    \"\"\""
        },
        {
          "line": 129,
          "content": "    \"\"\""
        },
        {
          "line": 145,
          "content": "    for pattern in retryable_patterns:"
        },
        {
          "line": 146,
          "content": "        if pattern in error_str:"
        },
        {
          "line": 147,
          "content": "            return True"
        },
        {
          "line": 149,
          "content": "    return False"
        },
        {
          "line": 152,
          "content": "def _alert_critical_failure(function_name: str, error_message: str, attempts: int):"
        },
        {
          "line": 153,
          "content": "    \"\"\""
        },
        {
          "line": 160,
          "content": "    \"\"\""
        },
        {
          "line": 161,
          "content": "    from wechat_backend.alerting import alert_critical_failure"
        },
        {
          "line": 171,
          "content": "class DatabaseOperationWithRetry:"
        },
        {
          "line": 172,
          "content": "    \"\"\""
        },
        {
          "line": 178,
          "content": "    \"\"\""
        },
        {
          "line": 180,
          "content": "    def __init__("
        },
        {
          "line": 190,
          "content": "    def execute(self, operation: Callable[[], Any], operation_name: str = \"Database Operation\") -> Any:"
        },
        {
          "line": 191,
          "content": "        \"\"\""
        },
        {
          "line": 203,
          "content": "        \"\"\""
        },
        {
          "line": 206,
          "content": "        for attempt in range(self.max_retries + 1):"
        },
        {
          "line": 210,
          "content": "                if attempt > 0:"
        },
        {
          "line": 215,
          "content": "                return result"
        },
        {
          "line": 220,
          "content": "                if attempt < self.max_retries and _is_retryable_error(e):"
        },
        {
          "line": 221,
          "content": "                    import random"
        },
        {
          "line": 252,
          "content": "def get_database_retryer() -> DatabaseOperationWithRetry:"
        },
        {
          "line": 253,
          "content": "    \"\"\"获取全局数据库重试器\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/nxm_execution_engine.py",
      "lines": [
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 34,
          "content": "\"\"\""
        },
        {
          "line": 78,
          "content": "    \"\"\""
        },
        {
          "line": 89,
          "content": "    \"\"\""
        },
        {
          "line": 105,
          "content": "    \"\"\""
        },
        {
          "line": 118,
          "content": "    \"\"\""
        },
        {
          "line": 139,
          "content": "    \"\"\""
        },
        {
          "line": 147,
          "content": "    \"\"\""
        },
        {
          "line": 161,
          "content": "    \"\"\""
        },
        {
          "line": 166,
          "content": "    \"\"\""
        },
        {
          "line": 188,
          "content": "    \"\"\""
        },
        {
          "line": 196,
          "content": "    \"\"\""
        },
        {
          "line": 226,
          "content": "    \"\"\""
        },
        {
          "line": 233,
          "content": "    \"\"\""
        },
        {
          "line": 653,
          "content": "    \"\"\""
        },
        {
          "line": 661,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_p1_analysis.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "\"\"\""
        },
        {
          "line": 35,
          "content": "    \"\"\"信源情报数据模型\"\"\""
        },
        {
          "line": 38,
          "content": "    def from_execution_id(execution_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 39,
          "content": "        \"\"\"从 execution_id 获取信源情报数据\"\"\""
        },
        {
          "line": 47,
          "content": "        ''', (execution_id,))"
        },
        {
          "line": 49,
          "content": "        if not result:"
        },
        {
          "line": 50,
          "content": "            return None"
        },
        {
          "line": 61,
          "content": "        ''', (execution_id,))"
        },
        {
          "line": 92,
          "content": "        \"\"\"生成平台分布\"\"\""
        },
        {
          "line": 96,
          "content": "        for i, platform in enumerate(platforms):"
        },
        {
          "line": 97,
          "content": "            if i < len(rankings):"
        },
        {
          "line": 103,
          "content": "        return breakdown"
        },
        {
          "line": 106,
          "content": "    def _generate_type_breakdown(rankings) -> Dict[str, Any]:"
        },
        {
          "line": 107,
          "content": "        \"\"\"生成信源类型分布\"\"\""
        },
        {
          "line": 122,
          "content": "        \"\"\"生成情感分布\"\"\""
        },
        {
          "line": 123,
          "content": "        return {"
        },
        {
          "line": 124,
          "content": "            'positive': sum(1 for r in rankings if r[4] > 0.6),"
        },
        {
          "line": 125,
          "content": "            'negative': sum(1 for r in rankings if r[4] < 0.4),"
        },
        {
          "line": 126,
          "content": "            'neutral': sum(1 for r in rankings if 0.4 <= r[4] <= 0.6)"
        },
        {
          "line": 130,
          "content": "class CompetitiveAnalysisModel:"
        },
        {
          "line": 131,
          "content": "    \"\"\"竞争分析数据模型\"\"\""
        },
        {
          "line": 135,
          "content": "        \"\"\"从 execution_id 获取竞争分析数据\"\"\""
        },
        {
          "line": 143,
          "content": "        ''', (execution_id,))"
        },
        {
          "line": 158,
          "content": "        ''', (execution_id,))"
        },
        {
          "line": 162,
          "content": "        for i, r in enumerate(rankings):"
        },
        {
          "line": 184,
          "content": "        return {"
        },
        {
          "line": 187,
          "content": "            'my_brand': next((c for c in competitors if c['brand'] == main_brand), None),"
        },
        {
          "line": 188,
          "content": "            'competitors': [c for c in competitors if c['brand'] != main_brand],"
        },
        {
          "line": 195,
          "content": "    def _determine_market_positioning(competitors) -> Dict[str, str]:"
        },
        {
          "line": 196,
          "content": "        \"\"\"确定市场定位\"\"\""
        },
        {
          "line": 216,
          "content": "        \"\"\"分析差异化\"\"\""
        },
        {
          "line": 217,
          "content": "        my_brand = next((c for c in competitors if c['brand'] == main_brand), None)"
        },
        {
          "line": 218,
          "content": "        other_competitors = [c for c in competitors if c['brand'] != main_brand]"
        },
        {
          "line": 220,
          "content": "        if not my_brand:"
        },
        {
          "line": 221,
          "content": "            return {}"
        },
        {
          "line": 231,
          "content": "        for dim in dimensions:"
        },
        {
          "line": 233,
          "content": "            avg_competitor_score = sum(c.get('dimension_scores', {}).get(dim, 0) for c in other_competitors) / max(len(other_competitors), 1)"
        },
        {
          "line": 235,
          "content": "            if my_score > avg_competitor_score + 10:"
        },
        {
          "line": 237,
          "content": "            elif my_score > avg_competitor_score:"
        },
        {
          "line": 242,
          "content": "        return {"
        },
        {
          "line": 249,
          "content": "class RecommendationsModel:"
        },
        {
          "line": 250,
          "content": "    \"\"\"推荐建议数据模型\"\"\""
        },
        {
          "line": 254,
          "content": "        \"\"\"从 execution_id 获取推荐建议\"\"\""
        },
        {
          "line": 262,
          "content": "        ''', (execution_id,))"
        },
        {
          "line": 288,
          "content": "        \"\"\"生成优先级行动建议\"\"\""
        },
        {
          "line": 291,
          "content": "        if health_score < 60:"
        },
        {
          "line": 300,
          "content": "        if sov < 30:"
        },
        {
          "line": 309,
          "content": "        if avg_sentiment < 0.5:"
        },
        {
          "line": 319,
          "content": "        if not actions:"
        },
        {
          "line": 328,
          "content": "        return actions"
        },
        {
          "line": 331,
          "content": "    def _generate_strategic_suggestions(health_score, sov, avg_sentiment) -> List[Dict[str, Any]]:"
        },
        {
          "line": 332,
          "content": "        \"\"\"生成战略建议\"\"\""
        },
        {
          "line": 364,
          "content": "        \"\"\"生成风险缓解方案\"\"\""
        },
        {
          "line": 367,
          "content": "        if health_score < 50:"
        },
        {
          "line": 374,
          "content": "        if avg_sentiment < 0.4:"
        },
        {
          "line": 381,
          "content": "        return risks or [{"
        },
        {
          "line": 388,
          "content": "class InterceptionAnalysisModel:"
        },
        {
          "line": 389,
          "content": "    \"\"\"拦截分析数据模型\"\"\""
        },
        {
          "line": 393,
          "content": "        \"\"\"从 execution_id 获取拦截分析数据\"\"\""
        },
        {
          "line": 401,
          "content": "        ''', (execution_id,))"
        },
        {
          "line": 436,
          "content": "    \"\"\"获取信源深度分析\"\"\""
        },
        {
          "line": 442,
          "content": "        if not data:"
        },
        {
          "line": 443,
          "content": "            return jsonify({"
        },
        {
          "line": 449,
          "content": "        return jsonify({"
        },
        {
          "line": 456,
          "content": "        return jsonify({"
        },
        {
          "line": 463,
          "content": "        return jsonify({"
        },
        {
          "line": 471,
          "content": "def get_competitive_analysis(execution_id: str):"
        },
        {
          "line": 472,
          "content": "    \"\"\"获取竞争分析详情\"\"\""
        },
        {
          "line": 508,
          "content": "    \"\"\"获取推荐建议\"\"\""
        },
        {
          "line": 514,
          "content": "        if not data:"
        },
        {
          "line": 515,
          "content": "            return jsonify({"
        },
        {
          "line": 521,
          "content": "        return jsonify({"
        },
        {
          "line": 528,
          "content": "        return jsonify({"
        },
        {
          "line": 535,
          "content": "        return jsonify({"
        },
        {
          "line": 543,
          "content": "def get_interception_analysis(execution_id: str):"
        },
        {
          "line": 544,
          "content": "    \"\"\"获取拦截分析\"\"\""
        },
        {
          "line": 583,
          "content": "    \"\"\"初始化 P1 分析路由\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_sync.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 36,
          "content": "    \"\"\""
        },
        {
          "line": 48,
          "content": "    \"\"\""
        },
        {
          "line": 101,
          "content": "    \"\"\""
        },
        {
          "line": 112,
          "content": "    \"\"\""
        },
        {
          "line": 154,
          "content": "    \"\"\""
        },
        {
          "line": 171,
          "content": "    \"\"\""
        },
        {
          "line": 223,
          "content": "    \"\"\""
        },
        {
          "line": 233,
          "content": "    \"\"\""
        },
        {
          "line": 276,
          "content": "    \"\"\""
        },
        {
          "line": 284,
          "content": "    \"\"\""
        },
        {
          "line": 314,
          "content": "    \"\"\"注册数据同步 Blueprint\"\"\""
        },
        {
          "line": 315,
          "content": "    from wechat_backend.logging_config import api_logger"
        },
        {
          "line": 316,
          "content": "    from wechat_backend.sync.sync_storage import init_sync_storage"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/source_weight_library.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Source Weight Library for GEO Content Quality Validator"
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\""
        },
        {
          "line": 16,
          "content": "    Database of website influence weights for evaluating AI response sources"
        },
        {
          "line": 17,
          "content": "    \"\"\""
        },
        {
          "line": 20,
          "content": "        \"\"\""
        },
        {
          "line": 25,
          "content": "        \"\"\""
        },
        {
          "line": 36,
          "content": "        \"\"\""
        },
        {
          "line": 38,
          "content": "        \"\"\""
        },
        {
          "line": 54,
          "content": "        ''')"
        },
        {
          "line": 56,
          "content": "        # Create indexes for faster lookups"
        },
        {
          "line": 66,
          "content": "    def load_default_weights(self):"
        },
        {
          "line": 67,
          "content": "        \"\"\""
        },
        {
          "line": 69,
          "content": "        \"\"\""
        },
        {
          "line": 113,
          "content": "        for domain, site_name, weight_score, category, description in default_sources:"
        },
        {
          "line": 119,
          "content": "                ''', (domain, site_name, weight_score, category, description))"
        },
        {
          "line": 129,
          "content": "        \"\"\""
        },
        {
          "line": 130,
          "content": "        Get the weight score for a specific domain"
        },
        {
          "line": 136,
          "content": "            Tuple of (weight_score, site_name, category) or None if not found"
        },
        {
          "line": 137,
          "content": "        \"\"\""
        },
        {
          "line": 145,
          "content": "        ''', (domain,))"
        },
        {
          "line": 150,
          "content": "        return result"
        },
        {
          "line": 152,
          "content": "    def get_multiple_source_weights(self, domains: List[str]) -> Dict[str, Optional[Tuple[float, str, str]]]:"
        },
        {
          "line": 153,
          "content": "        \"\"\""
        },
        {
          "line": 161,
          "content": "        \"\"\""
        },
        {
          "line": 162,
          "content": "        if not domains:"
        },
        {
          "line": 163,
          "content": "            return {}"
        },
        {
          "line": 165,
          "content": "        # Create placeholders for SQL query"
        },
        {
          "line": 166,
          "content": "        placeholders = ','.join(['?' for _ in domains])"
        },
        {
          "line": 175,
          "content": "        ''', domains)"
        },
        {
          "line": 188,
          "content": "        \"\"\""
        },
        {
          "line": 189,
          "content": "        Extract domain from a URL"
        },
        {
          "line": 195,
          "content": "            Domain string or None if invalid"
        },
        {
          "line": 196,
          "content": "        \"\"\""
        },
        {
          "line": 201,
          "content": "            # Remove 'www.' prefix if present"
        },
        {
          "line": 214,
          "content": "        \"\"\""
        },
        {
          "line": 215,
          "content": "        Extract domains from a list of URLs"
        },
        {
          "line": 222,
          "content": "        \"\"\""
        },
        {
          "line": 232,
          "content": "        \"\"\""
        },
        {
          "line": 240,
          "content": "        \"\"\""
        },
        {
          "line": 249,
          "content": "        ''', (category,))"
        },
        {
          "line": 254,
          "content": "        return ["
        },
        {
          "line": 264,
          "content": "            for row in results"
        },
        {
          "line": 267,
          "content": "    def get_high_weight_sources(self, min_weight: float = 0.7) -> List[Dict[str, any]]:"
        },
        {
          "line": 268,
          "content": "        \"\"\""
        },
        {
          "line": 276,
          "content": "        \"\"\""
        },
        {
          "line": 285,
          "content": "        ''', (min_weight,))"
        },
        {
          "line": 304,
          "content": "        \"\"\""
        },
        {
          "line": 305,
          "content": "        Extract domain from a URL"
        },
        {
          "line": 311,
          "content": "            Domain string or None if invalid"
        },
        {
          "line": 312,
          "content": "        \"\"\""
        },
        {
          "line": 317,
          "content": "            # Remove 'www.' prefix if present"
        },
        {
          "line": 330,
          "content": "        \"\"\""
        },
        {
          "line": 339,
          "content": "        \"\"\""
        },
        {
          "line": 351,
          "content": "            ''', (domain, site_name, weight_score, category, description))"
        },
        {
          "line": 360,
          "content": "    def update_source_weight(self, domain: str, new_weight: float):"
        },
        {
          "line": 361,
          "content": "        \"\"\""
        },
        {
          "line": 367,
          "content": "        \"\"\""
        },
        {
          "line": 368,
          "content": "        if not (0 <= new_weight <= 1.0):"
        },
        {
          "line": 378,
          "content": "        ''', (new_weight, domain))"
        },
        {
          "line": 390,
          "content": "        \"\"\""
        },
        {
          "line": 395,
          "content": "        \"\"\""
        },
        {
          "line": 406,
          "content": "        \"\"\""
        },
        {
          "line": 407,
          "content": "        Get all sources from the database"
        },
        {
          "line": 411,
          "content": "        \"\"\""
        },
        {
          "line": 419,
          "content": "        ''')"
        },
        {
          "line": 424,
          "content": "        return ["
        },
        {
          "line": 434,
          "content": "            for row in results"
        },
        {
          "line": 437,
          "content": "    def search_sources_by_domain(self, domain_pattern: str) -> List[Dict[str, any]]:"
        },
        {
          "line": 438,
          "content": "        \"\"\""
        },
        {
          "line": 446,
          "content": "        \"\"\""
        },
        {
          "line": 455,
          "content": "        ''', (f'%{domain_pattern}%',))"
        },
        {
          "line": 474,
          "content": "        \"\"\""
        },
        {
          "line": 483,
          "content": "        \"\"\""
        },
        {
          "line": 492,
          "content": "        ''', (min_weight, max_weight))"
        },
        {
          "line": 497,
          "content": "        return ["
        },
        {
          "line": 507,
          "content": "            for row in results"
        },
        {
          "line": 512,
          "content": "if __name__ == \"__main__\":"
        },
        {
          "line": 527,
          "content": "    for domain in domains:"
        },
        {
          "line": 529,
          "content": "        if weight_info:"
        },
        {
          "line": 538,
          "content": "    for source in high_weight_sources[:5]:  # Show first 5"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/fault_tolerant_executor.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "\"\"\""
        },
        {
          "line": 27,
          "content": "    \"\"\"错误类型枚举\"\"\""
        },
        {
          "line": 38,
          "content": "class FaultTolerantResult:"
        },
        {
          "line": 39,
          "content": "    \"\"\"容错执行结果\"\"\""
        },
        {
          "line": 60,
          "content": "        \"\"\"转换为字典\"\"\""
        },
        {
          "line": 61,
          "content": "        return {"
        },
        {
          "line": 65,
          "content": "            \"error_type\": self.error_type.value if self.error_type else None,"
        },
        {
          "line": 72,
          "content": "    def success(cls, data: Any, source: str = None, execution_time: float = None) -> 'FaultTolerantResult':"
        },
        {
          "line": 73,
          "content": "        \"\"\"创建成功结果\"\"\""
        },
        {
          "line": 89,
          "content": "        \"\"\"创建失败结果\"\"\""
        },
        {
          "line": 90,
          "content": "        return cls("
        },
        {
          "line": 99,
          "content": "class FaultTolerantExecutor:"
        },
        {
          "line": 100,
          "content": "    \"\"\""
        },
        {
          "line": 119,
          "content": "    \"\"\""
        },
        {
          "line": 129,
          "content": "    def __init__(self, timeout_seconds: int = 10):"
        },
        {
          "line": 130,
          "content": "        \"\"\""
        },
        {
          "line": 135,
          "content": "        \"\"\""
        },
        {
          "line": 138,
          "content": "    async def execute_with_fallback("
        },
        {
          "line": 146,
          "content": "        \"\"\""
        },
        {
          "line": 158,
          "content": "        \"\"\""
        },
        {
          "line": 163,
          "content": "            if asyncio.iscoroutinefunction(task_func):"
        },
        {
          "line": 165,
          "content": "                data = await asyncio.wait_for("
        },
        {
          "line": 172,
          "content": "                data = await asyncio.wait_for("
        },
        {
          "line": 181,
          "content": "            return FaultTolerantResult.success("
        },
        {
          "line": 193,
          "content": "            return FaultTolerantResult.failed("
        },
        {
          "line": 217,
          "content": "            return FaultTolerantResult.failed("
        },
        {
          "line": 224,
          "content": "    def collect_result("
        },
        {
          "line": 233,
          "content": "        \"\"\""
        },
        {
          "line": 246,
          "content": "        \"\"\""
        },
        {
          "line": 247,
          "content": "        return {"
        },
        {
          "line": 257,
          "content": "    def _identify_error_type(self, exception: Exception) -> ErrorType:"
        },
        {
          "line": 258,
          "content": "        \"\"\"识别错误类型\"\"\""
        },
        {
          "line": 277,
          "content": "        \"\"\"将 AI 错误类型映射到容错错误类型\"\"\""
        },
        {
          "line": 278,
          "content": "        from wechat_backend.ai_adapters.base_adapter import AIErrorType"
        },
        {
          "line": 289,
          "content": "        return mapping.get(ai_error_type, ErrorType.UNKNOWN)"
        },
        {
          "line": 291,
          "content": "    def _generate_user_friendly_error("
        },
        {
          "line": 297,
          "content": "        \"\"\"生成用户友好的错误信息\"\"\""
        },
        {
          "line": 318,
          "content": "        \"\"\"格式化详细错误信息（用于日志）\"\"\""
        },
        {
          "line": 327,
          "content": "        return \" | \".join(error_details)"
        },
        {
          "line": 330,
          "content": "class BatchFaultTolerantExecutor:"
        },
        {
          "line": 331,
          "content": "    \"\"\""
        },
        {
          "line": 349,
          "content": "    \"\"\""
        },
        {
          "line": 351,
          "content": "    def __init__(self, timeout_seconds: int = 10, max_concurrent: int = 5):"
        },
        {
          "line": 352,
          "content": "        \"\"\""
        },
        {
          "line": 358,
          "content": "        \"\"\""
        },
        {
          "line": 363,
          "content": "    async def execute_batch("
        },
        {
          "line": 367,
          "content": "        \"\"\""
        },
        {
          "line": 376,
          "content": "        \"\"\""
        },
        {
          "line": 377,
          "content": "        async def execute_with_semaphore(task: Dict[str, Any]) -> FaultTolerantResult:"
        },
        {
          "line": 378,
          "content": "            async with self._semaphore:"
        },
        {
          "line": 379,
          "content": "                return await self.executor.execute_with_fallback("
        },
        {
          "line": 388,
          "content": "        results = await asyncio.gather(*["
        },
        {
          "line": 389,
          "content": "            execute_with_semaphore(task) for task in tasks"
        },
        {
          "line": 392,
          "content": "        return results"
        },
        {
          "line": 394,
          "content": "    def get_statistics(self, results: List[FaultTolerantResult]) -> Dict[str, Any]:"
        },
        {
          "line": 395,
          "content": "        \"\"\""
        },
        {
          "line": 403,
          "content": "        \"\"\""
        },
        {
          "line": 405,
          "content": "        success_count = sum(1 for r in results if r.status == \"success\")"
        },
        {
          "line": 410,
          "content": "        for result in results:"
        },
        {
          "line": 411,
          "content": "            if result.status == \"failed\" and result.error_type:"
        },
        {
          "line": 416,
          "content": "        successful_times = [r.execution_time for r in results if r.status == \"success\" and r.execution_time]"
        },
        {
          "line": 417,
          "content": "        avg_execution_time = sum(successful_times) / len(successful_times) if successful_times else 0"
        },
        {
          "line": 419,
          "content": "        return {"
        },
        {
          "line": 423,
          "content": "            \"success_rate\": success_count / total if total > 0 else 0,"
        },
        {
          "line": 430,
          "content": "def safe_json_serialize(obj: Any, default_value: Any = None) -> Any:"
        },
        {
          "line": 431,
          "content": "    \"\"\""
        },
        {
          "line": 440,
          "content": "    \"\"\""
        },
        {
          "line": 441,
          "content": "    import json"
        },
        {
          "line": 443,
          "content": "        return json.loads(json.dumps(obj, ensure_ascii=False, default=str))"
        },
        {
          "line": 446,
          "content": "        return default_value"
        },
        {
          "line": 452,
          "content": "async def execute_with_fallback(task_func: Callable, task_name: str, source: str = None, *args, **kwargs) -> FaultTolerantResult:"
        },
        {
          "line": 453,
          "content": "    \"\"\""
        },
        {
          "line": 458,
          "content": "    \"\"\""
        },
        {
          "line": 459,
          "content": "    return await _global_executor.execute_with_fallback(task_func, task_name, source, *args, **kwargs)"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_timeout.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "\"\"\""
        },
        {
          "line": 29,
          "content": "    \"\"\"问题复杂度\"\"\""
        },
        {
          "line": 65,
          "content": "def get_timeout_config(model_name: str, question: str = \"\") -> int:"
        },
        {
          "line": 66,
          "content": "    \"\"\""
        },
        {
          "line": 75,
          "content": "    \"\"\""
        },
        {
          "line": 77,
          "content": "    if question:"
        },
        {
          "line": 79,
          "content": "        if length < 20:"
        },
        {
          "line": 81,
          "content": "        elif length < 50:"
        },
        {
          "line": 93,
          "content": "    return timeout"
        },
        {
          "line": 96,
          "content": "class AITimeoutError(Exception):"
        },
        {
          "line": 97,
          "content": "    \"\"\"AI 调用超时异常\"\"\""
        },
        {
          "line": 105,
          "content": "    \"\"\"AI 调用失败异常\"\"\""
        },
        {
          "line": 106,
          "content": "    def __init__(self, model_name: str, message: str):"
        },
        {
          "line": 112,
          "content": "async def call_with_timeout("
        },
        {
          "line": 119,
          "content": "    \"\"\""
        },
        {
          "line": 134,
          "content": "    \"\"\""
        },
        {
          "line": 136,
          "content": "        # 使用 asyncio.wait_for 添加超时"
        },
        {
          "line": 137,
          "content": "        return await asyncio.wait_for("
        },
        {
          "line": 149,
          "content": "def sync_call_with_timeout("
        },
        {
          "line": 156,
          "content": "    \"\"\""
        },
        {
          "line": 173,
          "content": "    \"\"\""
        },
        {
          "line": 174,
          "content": "    import asyncio"
        },
        {
          "line": 175,
          "content": "    from asyncio import TimeoutError"
        },
        {
          "line": 192,
          "content": "        return result"
        },
        {
          "line": 206,
          "content": "def timeout_decorator(timeout: int = 30, model_name: str = \"unknown\"):"
        },
        {
          "line": 207,
          "content": "    \"\"\""
        },
        {
          "line": 214,
          "content": "    \"\"\""
        },
        {
          "line": 215,
          "content": "    def decorator(func: Callable) -> Callable:"
        },
        {
          "line": 217,
          "content": "        async def wrapper(*args, **kwargs):"
        },
        {
          "line": 218,
          "content": "            return await call_with_timeout("
        },
        {
          "line": 225,
          "content": "        return wrapper"
        },
        {
          "line": 226,
          "content": "    return decorator"
        },
        {
          "line": 229,
          "content": "class AITimeoutManager:"
        },
        {
          "line": 230,
          "content": "    \"\"\""
        },
        {
          "line": 241,
          "content": "    \"\"\""
        },
        {
          "line": 260,
          "content": "    def _get_lock(cls):"
        },
        {
          "line": 261,
          "content": "        \"\"\"获取线程锁（延迟初始化）\"\"\""
        },
        {
          "line": 269,
          "content": "        \"\"\"获取指定模型的超时配置（线程安全）\"\"\""
        },
        {
          "line": 274,
          "content": "        if question:"
        },
        {
          "line": 276,
          "content": "            if length < 20:"
        },
        {
          "line": 278,
          "content": "            elif length > 50:"
        },
        {
          "line": 281,
          "content": "        return base_timeout"
        },
        {
          "line": 284,
          "content": "    def set_timeout(cls, model_name: str, timeout: int):"
        },
        {
          "line": 285,
          "content": "        \"\"\"设置指定模型的超时配置（线程安全）\"\"\""
        },
        {
          "line": 292,
          "content": "        \"\"\"获取所有超时配置（线程安全）\"\"\""
        },
        {
          "line": 295,
          "content": "            return cls.DEFAULT_TIMEOUTS.copy()"
        },
        {
          "line": 302,
          "content": "def get_timeout_manager() -> AITimeoutManager:"
        },
        {
          "line": 303,
          "content": "    \"\"\""
        },
        {
          "line": 307,
          "content": "    \"\"\""
        },
        {
          "line": 311,
          "content": "    if _timeout_manager is not None:"
        },
        {
          "line": 312,
          "content": "        return _timeout_manager"
        },
        {
          "line": 315,
          "content": "    import threading"
        },
        {
          "line": 316,
          "content": "    if _timeout_manager_lock is None:"
        },
        {
          "line": 322,
          "content": "        if _timeout_manager is None:"
        },
        {
          "line": 325,
          "content": "        return _timeout_manager"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/audit_decorator.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "    \"\"\""
        },
        {
          "line": 25,
          "content": "        def assign_user_role(user_id):"
        },
        {
          "line": 27,
          "content": "    \"\"\""
        },
        {
          "line": 109,
          "content": "    \"\"\""
        },
        {
          "line": 120,
          "content": "        def batch_user_action():"
        },
        {
          "line": 122,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/cruise_controller.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 21,
          "content": "    \"\"\"自动化巡航控制器\"\"\""
        },
        {
          "line": 23,
          "content": "    def __init__(self):"
        },
        {
          "line": 29,
          "content": "    def _init_scheduler(self):"
        },
        {
          "line": 30,
          "content": "        \"\"\"初始化调度器\"\"\""
        },
        {
          "line": 64,
          "content": "        \"\"\""
        },
        {
          "line": 77,
          "content": "        \"\"\""
        },
        {
          "line": 105,
          "content": "        \"\"\"取消已调度的任务\"\"\""
        },
        {
          "line": 113,
          "content": "    def get_scheduled_tasks(self) -> List[Dict[str, Any]]:"
        },
        {
          "line": 114,
          "content": "        \"\"\"获取所有已调度的任务\"\"\""
        },
        {
          "line": 126,
          "content": "        \"\"\""
        },
        {
          "line": 135,
          "content": "        \"\"\""
        },
        {
          "line": 181,
          "content": "        \"\"\""
        },
        {
          "line": 190,
          "content": "        \"\"\""
        },
        {
          "line": 229,
          "content": "        \"\"\"根据ID获取测试记录\"\"\""
        },
        {
          "line": 237,
          "content": "        ''', (record_id,))"
        },
        {
          "line": 255,
          "content": "        \"\"\"获取指定品牌在指定日期之前的最新测试记录\"\"\""
        },
        {
          "line": 265,
          "content": "        ''', (brand_name, current_date))"
        },
        {
          "line": 283,
          "content": "        \"\"\"从测试记录中提取用于比较的数据\"\"\""
        },
        {
          "line": 300,
          "content": "        for detail in detailed_results:"
        },
        {
          "line": 302,
          "content": "            if brand not in brand_stats:"
        },
        {
          "line": 310,
          "content": "            if sentiment:"
        },
        {
          "line": 316,
          "content": "                if any(keyword in response for keyword in ['不好', '差', '问题', '缺点', '负面', '糟糕', '失望']):"
        },
        {
          "line": 325,
          "content": "        for brand, stats in brand_stats.items():"
        },
        {
          "line": 326,
          "content": "            if stats['count'] > 0:"
        },
        {
          "line": 334,
          "content": "        if 'ranking_list' in results_summary:"
        },
        {
          "line": 337,
          "content": "        return comparison_data"
        },
        {
          "line": 339,
          "content": "    def _extract_rank(self, result: Dict[str, Any]) -> Optional[int]:"
        },
        {
          "line": 340,
          "content": "        \"\"\"从结果中提取排名\"\"\""
        },
        {
          "line": 369,
          "content": "        \"\"\"统计负面证据数量\"\"\""
        },
        {
          "line": 372,
          "content": "            return len(evidence_chain)  # 简单计数所有证据项"
        },
        {
          "line": 375,
          "content": "            return None"
        },
        {
          "line": 377,
          "content": "    def _extract_sentiment_score(self, result: Dict[str, Any]) -> Optional[float]:"
        },
        {
          "line": 378,
          "content": "        \"\"\"从结果中提取情感分数\"\"\""
        },
        {
          "line": 395,
          "content": "        \"\"\""
        },
        {
          "line": 404,
          "content": "        \"\"\""
        },
        {
          "line": 420,
          "content": "        ''', (brand_name, start_date))"
        },
        {
          "line": 423,
          "content": "        for row in records_data:"
        },
        {
          "line": 427,
          "content": "            detailed_results = json.loads(detailed_results_str) if detailed_results_str else []"
        },
        {
          "line": 428,
          "content": "            results_summary = json.loads(results_summary_str) if results_summary_str else {}"
        },
        {
          "line": 444,
          "content": "        return trend_data"
        },
        {
          "line": 446,
          "content": "    def _calculate_avg_sentiment(self, detailed_results: List[Dict[str, Any]]) -> Optional[float]:"
        },
        {
          "line": 447,
          "content": "        \"\"\"从详细结果中计算平均情感分数\"\"\""
        },
        {
          "line": 462,
          "content": "        \"\"\"从详细结果中提取特定品牌的排名\"\"\""
        },
        {
          "line": 465,
          "content": "        if not detailed_results:"
        },
        {
          "line": 466,
          "content": "            return None"
        },
        {
          "line": 470,
          "content": "        for result in detailed_results:"
        },
        {
          "line": 471,
          "content": "            if result.get('brand', '').lower() == brand_name.lower():"
        },
        {
          "line": 475,
          "content": "        if brand_count > 0:"
        },
        {
          "line": 478,
          "content": "            return max(1, 11 - min(brand_count, 10))  # 返回1-10之间的排名"
        },
        {
          "line": 480,
          "content": "        return None"
        },
        {
          "line": 482,
          "content": "    def shutdown(self):"
        },
        {
          "line": 483,
          "content": "        \"\"\"关闭调度器\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/nxm_concurrent_engine_v2.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        },
        {
          "line": 75,
          "content": "    \"\"\"AI 调用任务\"\"\""
        },
        {
          "line": 77,
          "content": "    def __init__("
        },
        {
          "line": 95,
          "content": "    def to_dict(self) -> Dict[str, Any]:"
        },
        {
          "line": 96,
          "content": "        return {"
        },
        {
          "line": 107,
          "content": "class AIResult:"
        },
        {
          "line": 108,
          "content": "    \"\"\"AI 调用结果\"\"\""
        },
        {
          "line": 146,
          "content": "    \"\"\""
        },
        {
          "line": 154,
          "content": "    \"\"\""
        },
        {
          "line": 190,
          "content": "        \"\"\""
        },
        {
          "line": 203,
          "content": "        \"\"\""
        },
        {
          "line": 268,
          "content": "        \"\"\"构建所有 AI 调用任务\"\"\""
        },
        {
          "line": 272,
          "content": "        for brand in all_brands:"
        },
        {
          "line": 273,
          "content": "            current_competitors = [b for b in all_brands if b != brand]"
        },
        {
          "line": 275,
          "content": "            for q_idx, question in enumerate(raw_questions):"
        },
        {
          "line": 276,
          "content": "                for model_info in selected_models:"
        },
        {
          "line": 280,
          "content": "                    if not self.scheduler.is_model_available(model_name):"
        },
        {
          "line": 291,
          "content": "                        competitors=', '.join(current_competitors) if current_competitors else '无',"
        },
        {
          "line": 307,
          "content": "        return tasks"
        },
        {
          "line": 309,
          "content": "    def _execute_single_task(self, task: AITask) -> AIResult:"
        },
        {
          "line": 310,
          "content": "        \"\"\"执行单个 AI 调用任务\"\"\""
        },
        {
          "line": 354,
          "content": "        \"\"\"处理 AI 调用结果\"\"\""
        },
        {
          "line": 360,
          "content": "            if result.success and result.data:"
        },
        {
          "line": 368,
          "content": "                if result.success:"
        },
        {
          "line": 381,
          "content": "                'error': parse_error or (result.error_message if not result.success else None),"
        },
        {
          "line": 393,
          "content": "                if self.completed % PROGRESS_UPDATE_INTERVAL == 0:"
        },
        {
          "line": 401,
          "content": "                if self.completed % BATCH_WRITE_THRESHOLD == 0:"
        },
        {
          "line": 404,
          "content": "    def _handle_error(self, task: AITask, error: str):"
        },
        {
          "line": 405,
          "content": "        \"\"\"处理任务错误\"\"\""
        },
        {
          "line": 429,
          "content": "        \"\"\"批量写入数据库\"\"\""
        },
        {
          "line": 432,
          "content": "            from wechat_backend.repositories import save_dimension_result"
        },
        {
          "line": 436,
          "content": "                for result in self.results[-BATCH_WRITE_THRESHOLD:]:"
        },
        {
          "line": 438,
          "content": "                        dim_status = \"success\" if result.get('geo_data') else \"failed\""
        },
        {
          "line": 446,
          "content": "                            data=result.get('geo_data') if dim_status == 'success' else None,"
        },
        {
          "line": 447,
          "content": "                            error_message=result.get('error') if dim_status == 'failed' else None"
        },
        {
          "line": 455,
          "content": "    def _aggregate_results(self, execution_time: float) -> Dict[str, Any]:"
        },
        {
          "line": 456,
          "content": "        \"\"\"聚合结果\"\"\""
        },
        {
          "line": 516,
          "content": "        \"\"\""
        },
        {
          "line": 527,
          "content": "        \"\"\""
        },
        {
          "line": 591,
          "content": "    \"\"\""
        },
        {
          "line": 609,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/nxm_circuit_breaker.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 31,
          "content": "    \"\"\""
        },
        {
          "line": 47,
          "content": "        \"\"\"从持久化存储加载状态\"\"\""
        },
        {
          "line": 49,
          "content": "            if CIRCUIT_BREAKER_STORE_PATH.exists():"
        },
        {
          "line": 55,
          "content": "                    k: v for k, v in data.get('model_suspended', {}).items()"
        },
        {
          "line": 56,
          "content": "                    if v"
        },
        {
          "line": 59,
          "content": "                for model_name, timestamp_str in data.get('model_last_failure', {}).items():"
        },
        {
          "line": 73,
          "content": "    def _save_to_storage(self):"
        },
        {
          "line": 74,
          "content": "        \"\"\"保存状态到持久化存储\"\"\""
        },
        {
          "line": 93,
          "content": "        \"\"\"检查是否有模型应该恢复\"\"\""
        },
        {
          "line": 97,
          "content": "        for model_name, suspended in self.model_suspended.items():"
        },
        {
          "line": 98,
          "content": "            if suspended:"
        },
        {
          "line": 100,
          "content": "                if last_failure and (now - last_failure).total_seconds() > self.recovery_timeout:"
        },
        {
          "line": 105,
          "content": "        if recovered:"
        },
        {
          "line": 107,
          "content": "            if self.persist:"
        },
        {
          "line": 110,
          "content": "    def is_available(self, model_name: str) -> bool:"
        },
        {
          "line": 111,
          "content": "        \"\"\"检查模型是否可用\"\"\""
        },
        {
          "line": 117,
          "content": "        \"\"\"记录成功\"\"\""
        },
        {
          "line": 119,
          "content": "            if model_name in self.model_failures:"
        },
        {
          "line": 122,
          "content": "            if model_name in self.model_suspended:"
        },
        {
          "line": 125,
          "content": "            if self.persist:"
        },
        {
          "line": 128,
          "content": "    def record_failure(self, model_name: str):"
        },
        {
          "line": 129,
          "content": "        \"\"\"记录失败\"\"\""
        },
        {
          "line": 142,
          "content": "        \"\"\"获取熔断器状态\"\"\""
        },
        {
          "line": 143,
          "content": "        return {"
        },
        {
          "line": 147,
          "content": "                k: v.isoformat() for k, v in self.model_last_failure.items()"
        },
        {
          "line": 156,
          "content": "def get_circuit_breaker() -> ModelCircuitBreaker:"
        },
        {
          "line": 157,
          "content": "    \"\"\"获取全局熔断器实例\"\"\""
        },
        {
          "line": 165,
          "content": "    \"\"\"重置熔断器（用于测试）\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/realtime_persistence.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "\"\"\""
        },
        {
          "line": 52,
          "content": "    \"\"\""
        },
        {
          "line": 59,
          "content": "    \"\"\""
        },
        {
          "line": 83,
          "content": "    \"\"\""
        },
        {
          "line": 91,
          "content": "    \"\"\""
        },
        {
          "line": 94,
          "content": "        \"\"\""
        },
        {
          "line": 100,
          "content": "        \"\"\""
        },
        {
          "line": 133,
          "content": "        \"\"\""
        },
        {
          "line": 144,
          "content": "        \"\"\""
        },
        {
          "line": 235,
          "content": "        \"\"\""
        },
        {
          "line": 246,
          "content": "        \"\"\""
        },
        {
          "line": 295,
          "content": "                        ''', ("
        },
        {
          "line": 301,
          "content": "                        api_logger.info(f\"Updated aggregated results for execution: {self.execution_id}\")"
        },
        {
          "line": 309,
          "content": "                        ''', ("
        },
        {
          "line": 332,
          "content": "        \"\"\""
        },
        {
          "line": 343,
          "content": "        \"\"\""
        },
        {
          "line": 379,
          "content": "                            ''', ("
        },
        {
          "line": 390,
          "content": "                            ''', ("
        },
        {
          "line": 411,
          "content": "        \"\"\"获取已保存的任务数量\"\"\""
        },
        {
          "line": 412,
          "content": "        return len(self.saved_tasks)"
        },
        {
          "line": 414,
          "content": "    def _get_task_key(self, task_data: Dict[str, Any]) -> str:"
        },
        {
          "line": 415,
          "content": "        \"\"\"生成任务键\"\"\""
        },
        {
          "line": 423,
          "content": "        \"\"\""
        },
        {
          "line": 427,
          "content": "        \"\"\""
        },
        {
          "line": 459,
          "content": "        \"\"\""
        },
        {
          "line": 467,
          "content": "        \"\"\""
        },
        {
          "line": 484,
          "content": "                    ''', (cutoff_date.isoformat(),))"
        },
        {
          "line": 494,
          "content": "                    ''', (cutoff_date.isoformat(),))"
        },
        {
          "line": 528,
          "content": "        \"\"\""
        },
        {
          "line": 536,
          "content": "        \"\"\""
        },
        {
          "line": 554,
          "content": "        \"\"\""
        },
        {
          "line": 559,
          "content": "        \"\"\""
        },
        {
          "line": 564,
          "content": "        \"\"\""
        },
        {
          "line": 569,
          "content": "        \"\"\""
        },
        {
          "line": 573,
          "content": "        \"\"\""
        },
        {
          "line": 578,
          "content": "        \"\"\""
        },
        {
          "line": 588,
          "content": "        \"\"\""
        },
        {
          "line": 593,
          "content": "        \"\"\""
        },
        {
          "line": 608,
          "content": "    \"\"\"获取指定执行 ID 的持久化服务\"\"\""
        },
        {
          "line": 609,
          "content": "    return _persistence_services.get(execution_id)"
        },
        {
          "line": 612,
          "content": "def create_persistence_service("
        },
        {
          "line": 616,
          "content": "    \"\"\"创建并注册持久化服务\"\"\""
        },
        {
          "line": 624,
          "content": "    \"\"\"移除持久化服务\"\"\""
        },
        {
          "line": 625,
          "content": "    if execution_id in _persistence_services:"
        },
        {
          "line": 627,
          "content": "        api_logger.info(f\"Removed RealtimePersistence for execution: {execution_id}, saved {stats['saved_tasks']} tasks\")"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/result_processor.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Result Processor for GEO Content Quality Validator"
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 20,
          "content": "# The following class is kept for backward compatibility but won't be used"
        },
        {
          "line": 22,
          "content": "    \"\"\"Analyzes semantic drift between brand preset terms and AI responses (Legacy)\"\"\""
        },
        {
          "line": 24,
          "content": "    def __init__(self):"
        },
        {
          "line": 27,
          "content": "    def calculate_semantic_drift("
        },
        {
          "line": 32,
          "content": "        \"\"\""
        },
        {
          "line": 41,
          "content": "        \"\"\""
        },
        {
          "line": 42,
          "content": "        # Combine all responses for analysis"
        },
        {
          "line": 45,
          "content": "        # Extract keywords from responses"
        },
        {
          "line": 50,
          "content": "        for term in brand_preset_terms:"
        },
        {
          "line": 52,
          "content": "            for keyword in response_keywords:"
        },
        {
          "line": 56,
          "content": "            if term_similarities:"
        },
        {
          "line": 61,
          "content": "                    'matched_keywords': [kw for kw, sim in zip(response_keywords, term_similarities) if sim > 0.3]"
        },
        {
          "line": 65,
          "content": "        if similarities:"
        },
        {
          "line": 66,
          "content": "            avg_similarity = sum(s['similarity'] for s in similarities) / len(similarities)"
        },
        {
          "line": 69,
          "content": "            drift_score = 100  # Maximum drift if no terms matched"
        },
        {
          "line": 71,
          "content": "        return {"
        },
        {
          "line": 78,
          "content": "    def _extract_keywords(self, text: str) -> List[str]:"
        },
        {
          "line": 79,
          "content": "        \"\"\"Extract keywords from text using jieba segmentation\"\"\""
        },
        {
          "line": 87,
          "content": "        # Remove duplicates while preserving order"
        },
        {
          "line": 93,
          "content": "        \"\"\"Calculate similarity between two words using character overlap\"\"\""
        },
        {
          "line": 100,
          "content": "        if not union:"
        },
        {
          "line": 101,
          "content": "            return 0.0"
        },
        {
          "line": 103,
          "content": "        return len(intersection) / len(union)"
        },
        {
          "line": 105,
          "content": "    def _classify_drift_severity(self, drift_score: float) -> str:"
        },
        {
          "line": 106,
          "content": "        \"\"\"Classify drift severity based on score\"\"\""
        },
        {
          "line": 118,
          "content": "    \"\"\"Processes test results with advanced analytics\"\"\""
        },
        {
          "line": 120,
          "content": "    def __init__(self):"
        },
        {
          "line": 128,
          "content": "    def process_detailed_results("
        },
        {
          "line": 134,
          "content": "        official_definition: str = None  # New parameter for official brand definition"
        },
        {
          "line": 136,
          "content": "        \"\"\""
        },
        {
          "line": 148,
          "content": "        \"\"\""
        },
        {
          "line": 159,
          "content": "        if official_definition or brand_preset_terms:"
        },
        {
          "line": 161,
          "content": "            ai_responses = [result['response'] for result in test_results]"
        },
        {
          "line": 162,
          "content": "            response_sources = []  # Extract sources from responses if available"
        },
        {
          "line": 164,
          "content": "            # Use official definition if provided, otherwise fall back to preset terms"
        },
        {
          "line": 167,
          "content": "            if definition_to_use.strip():"
        },
        {
          "line": 175,
          "content": "                # Perform attribution analysis if sources are available"
        },
        {
          "line": 176,
          "content": "                if response_sources:"
        },
        {
          "line": 186,
          "content": "        if competitor_brands:"
        },
        {
          "line": 193,
          "content": "                for result in test_results"
        },
        {
          "line": 221,
          "content": "        if semantic_analysis:"
        },
        {
          "line": 222,
          "content": "            api_logger.info(f\"Semantic analysis completed for {brand_name}: drift_score={semantic_analysis.get('semantic_drift_score', 'N/A')}\")"
        },
        {
          "line": 224,
          "content": "        if attribution_analysis:"
        },
        {
          "line": 225,
          "content": "            api_logger.info(f\"Attribution analysis completed for {brand_name}: risk_score={attribution_analysis.get('attribution_metrics', {}).get('risk_score', 'N/A')}\")"
        },
        {
          "line": 227,
          "content": "        return result"
        },
        {
          "line": 229,
          "content": "    def _process_basic_scoring(self, test_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:"
        },
        {
          "line": 230,
          "content": "        \"\"\"Process basic scoring for each result\"\"\""
        },
        {
          "line": 261,
          "content": "        \"\"\"Advanced evaluation of AI response\"\"\""
        },
        {
          "line": 262,
          "content": "        if not response_content or len(response_content) < 10:"
        },
        {
          "line": 263,
          "content": "            return {"
        },
        {
          "line": 273,
          "content": "        has_brand_mention = bool(re.search(r'.*', response_content))  # Placeholder for actual brand detection"
        },
        {
          "line": 278,
          "content": "        has_authoritative_indicators = any(indicator in response_content.lower() for indicator in ["
        },
        {
          "line": 283,
          "content": "        if has_brand_mention: authority_score += 20"
        },
        {
          "line": 284,
          "content": "        if has_facts: authority_score += 15"
        },
        {
          "line": 285,
          "content": "        if is_structured: authority_score += 10"
        },
        {
          "line": 286,
          "content": "        if has_authoritative_indicators: authority_score += 15"
        },
        {
          "line": 293,
          "content": "        if length > 500: visibility_score = 95"
        },
        {
          "line": 294,
          "content": "        elif length > 300: visibility_score = 85"
        },
        {
          "line": 295,
          "content": "        elif length > 100: visibility_score = 70"
        },
        {
          "line": 296,
          "content": "        elif length > 50: visibility_score = 50"
        },
        {
          "line": 309,
          "content": "        pos_count = sum(1 for k in positive_keywords if k in response_content.lower())"
        },
        {
          "line": 310,
          "content": "        neg_count = sum(1 for k in negative_keywords if k in response_content.lower())"
        },
        {
          "line": 321,
          "content": "        confidence_level = 'high' if score >= 70 else 'medium' if score >= 50 else 'low'"
        },
        {
          "line": 323,
          "content": "        return {"
        },
        {
          "line": 332,
          "content": "    def _calculate_digital_vitality(self, processed_results: List[Dict[str, Any]]) -> Dict[str, float]:"
        },
        {
          "line": 333,
          "content": "        \"\"\"Calculate digital vitality index from processed results\"\"\""
        },
        {
          "line": 367,
          "content": "        \"\"\"Generate actionable insights from analysis results\"\"\""
        },
        {
          "line": 373,
          "content": "            'attribution_risks': [],  # New category for attribution risks"
        },
        {
          "line": 374,
          "content": "            'source_recommendations': []  # New category for source recommendations"
        },
        {
          "line": 378,
          "content": "        low_authority_responses = [r for r in processed_results if r['authority_score'] < 60]"
        },
        {
          "line": 379,
          "content": "        if low_authority_responses:"
        },
        {
          "line": 387,
          "content": "        if digital_vitality['visibility'] < 60:"
        },
        {
          "line": 390,
          "content": "        if digital_vitality['authority'] < 60:"
        },
        {
          "line": 393,
          "content": "        if digital_vitality['sentiment'] < 60:"
        },
        {
          "line": 396,
          "content": "        # Add semantic drift insights if available"
        },
        {
          "line": 397,
          "content": "        if semantic_analysis:"
        },
        {
          "line": 398,
          "content": "            if semantic_analysis['semantic_drift_score'] > 50:"
        },
        {
          "line": 405,
          "content": "        # Add attribution analysis insights if available"
        },
        {
          "line": 406,
          "content": "        if attribution_analysis:"
        },
        {
          "line": 411,
          "content": "            if pollution_sources:"
        },
        {
          "line": 420,
          "content": "            if source_purity < 50:"
        },
        {
          "line": 431,
          "content": "        # Add competitor warnings if available"
        },
        {
          "line": 432,
          "content": "        if competitive_analysis:"
        },
        {
          "line": 433,
          "content": "            # Check if competitors are outperforming in any metric"
        },
        {
          "line": 437,
          "content": "            if target_brand and competitor_scores:"
        },
        {
          "line": 439,
          "content": "                for metric in ['authority_score', 'visibility_score', 'sentiment_score']:"
        },
        {
          "line": 441,
          "content": "                    max_competitor_val = max([scores.get(metric, 0) for scores in competitor_scores.values()] or [0])"
        },
        {
          "line": 443,
          "content": "                    if target_val < max_competitor_val:"
        },
        {
          "line": 449,
          "content": "        return insights"
        },
        {
          "line": 453,
          "content": "if __name__ == \"__main__\":"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/nxm_scheduler.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 27,
          "content": "        \"\"\"空实现的 SSE 推送函数\"\"\""
        },
        {
          "line": 31,
          "content": "class NxMScheduler:"
        },
        {
          "line": 32,
          "content": "    \"\"\""
        },
        {
          "line": 39,
          "content": "    \"\"\""
        },
        {
          "line": 41,
          "content": "    def __init__(self, execution_id: str, execution_store: Dict[str, Any]):"
        },
        {
          "line": 50,
          "content": "    def initialize_execution(self, total_tasks: int):"
        },
        {
          "line": 51,
          "content": "        \"\"\"初始化执行状态\"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\""
        },
        {
          "line": 78,
          "content": "        \"\"\""
        },
        {
          "line": 161,
          "content": "        \"\"\"添加结果\"\"\""
        },
        {
          "line": 163,
          "content": "            if self.execution_id in self.execution_store:"
        },
        {
          "line": 166,
          "content": "    def complete_execution(self):"
        },
        {
          "line": 167,
          "content": "        \"\"\"完成执行（P0 修复：强制写入数据库）\"\"\""
        },
        {
          "line": 207,
          "content": "        \"\"\""
        },
        {
          "line": 212,
          "content": "        \"\"\""
        },
        {
          "line": 270,
          "content": "        \"\"\"启动超时计时器\"\"\""
        },
        {
          "line": 271,
          "content": "        def on_timeout():"
        },
        {
          "line": 279,
          "content": "    def cancel_timeout_timer(self):"
        },
        {
          "line": 280,
          "content": "        \"\"\"取消超时计时器\"\"\""
        },
        {
          "line": 286,
          "content": "        \"\"\"检查模型是否可用\"\"\""
        },
        {
          "line": 287,
          "content": "        return self.circuit_breaker.is_available(model_name)"
        },
        {
          "line": 289,
          "content": "    def record_model_success(self, model_name: str):"
        },
        {
          "line": 290,
          "content": "        \"\"\"记录模型成功\"\"\""
        },
        {
          "line": 294,
          "content": "        \"\"\"记录模型失败\"\"\""
        },
        {
          "line": 298,
          "content": "def create_scheduler(execution_id: str, execution_store: Dict[str, Any]) -> NxMScheduler:"
        },
        {
          "line": 299,
          "content": "    \"\"\"创建调度器实例\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/digital_asset_protection.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "\"\"\""
        },
        {
          "line": 48,
          "content": "    \"\"\"事务上下文管理器\"\"\""
        },
        {
          "line": 62,
          "content": "def calculate_checksum(data: Dict[str, Any]) -> str:"
        },
        {
          "line": 63,
          "content": "    \"\"\"计算数据校验和\"\"\""
        },
        {
          "line": 76,
          "content": "    \"\"\""
        },
        {
          "line": 88,
          "content": "    \"\"\""
        },
        {
          "line": 109,
          "content": "            ''', ("
        },
        {
          "line": 128,
          "content": "            ''', ("
        },
        {
          "line": 152,
          "content": "    \"\"\""
        },
        {
          "line": 156,
          "content": "    \"\"\""
        },
        {
          "line": 182,
          "content": "    \"\"\""
        },
        {
          "line": 189,
          "content": "    \"\"\""
        },
        {
          "line": 201,
          "content": "        ''', (execution_id,))"
        },
        {
          "line": 206,
          "content": "        if row:"
        },
        {
          "line": 211,
          "content": "            return result"
        },
        {
          "line": 220,
          "content": "        ''', (execution_id,))"
        },
        {
          "line": 252,
          "content": "    \"\"\""
        },
        {
          "line": 256,
          "content": "    \"\"\""
        },
        {
          "line": 281,
          "content": "    \"\"\""
        },
        {
          "line": 286,
          "content": "    \"\"\""
        },
        {
          "line": 341,
          "content": "    \"\"\""
        },
        {
          "line": 345,
          "content": "    \"\"\""
        },
        {
          "line": 384,
          "content": "    \"\"\"初始化数据库表\"\"\""
        },
        {
          "line": 401,
          "content": "        ''')"
        },
        {
          "line": 414,
          "content": "        ''')"
        },
        {
          "line": 420,
          "content": "        ''')"
        },
        {
          "line": 425,
          "content": "        ''')"
        },
        {
          "line": 430,
          "content": "        ''')"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/circuit_breaker.py",
      "lines": [
        {
          "line": 9,
          "content": "    \"\"\"Circuit breaker states\"\"\""
        },
        {
          "line": 12,
          "content": "    HALF_OPEN = \"half_open\" # Testing if service recovered"
        },
        {
          "line": 15,
          "content": "class CircuitBreakerError(Exception):"
        },
        {
          "line": 16,
          "content": "    \"\"\"Base exception for circuit breaker\"\"\""
        },
        {
          "line": 21,
          "content": "    \"\"\"Exception raised when circuit breaker is open\"\"\""
        },
        {
          "line": 25,
          "content": "class CircuitBreaker:"
        },
        {
          "line": 26,
          "content": "    \"\"\""
        },
        {
          "line": 28,
          "content": "    \"\"\""
        },
        {
          "line": 29,
          "content": "    def __init__("
        },
        {
          "line": 37,
          "content": "        \"\"\""
        },
        {
          "line": 46,
          "content": "        \"\"\""
        },
        {
          "line": 53,
          "content": "        if expected_exceptions is None:"
        },
        {
          "line": 54,
          "content": "            import requests"
        },
        {
          "line": 75,
          "content": "        self._lock = threading.RLock()  # Using RLock for recursive locking if needed"
        },
        {
          "line": 80,
          "content": "    def call(self, func: Callable, *args, **kwargs) -> Any:"
        },
        {
          "line": 81,
          "content": "        \"\"\""
        },
        {
          "line": 95,
          "content": "        \"\"\""
        },
        {
          "line": 97,
          "content": "            if self.state == CircuitBreakerState.OPEN:"
        },
        {
          "line": 98,
          "content": "                if self._allow_recovery():"
        },
        {
          "line": 100,
          "content": "                    api_logger.info(f\"Circuit breaker '{self.name}' transitioning to HALF_OPEN for recovery test\")"
        },
        {
          "line": 103,
          "content": "                    api_logger.warning(f\"Circuit breaker '{self.name}' OPEN - rejecting request for {remaining_time:.1f}s\")"
        },
        {
          "line": 108,
          "content": "            if self.state == CircuitBreakerState.HALF_OPEN:"
        },
        {
          "line": 109,
          "content": "                if self.half_open_calls >= self.half_open_max_calls:"
        },
        {
          "line": 121,
          "content": "            return result"
        },
        {
          "line": 124,
          "content": "            # Check if exception should trigger circuit breaker"
        },
        {
          "line": 125,
          "content": "            should_trigger = any(isinstance(e, exc_type) for exc_type in self.expected_exceptions)"
        },
        {
          "line": 127,
          "content": "            if should_trigger:"
        },
        {
          "line": 130,
          "content": "                api_logger.debug(f\"Exception {type(e).__name__} does not trigger circuit breaker for '{self.name}'\")"
        },
        {
          "line": 134,
          "content": "    def _on_success(self):"
        },
        {
          "line": 135,
          "content": "        \"\"\"Handle successful call\"\"\""
        },
        {
          "line": 147,
          "content": "        \"\"\"Handle failed call\"\"\""
        },
        {
          "line": 155,
          "content": "            if self.failure_count >= self.failure_threshold:"
        },
        {
          "line": 159,
          "content": "    def _to_open(self):"
        },
        {
          "line": 160,
          "content": "        \"\"\"Transition to OPEN state\"\"\""
        },
        {
          "line": 166,
          "content": "        \"\"\"Transition to HALF_OPEN state\"\"\""
        },
        {
          "line": 170,
          "content": "    def _to_closed(self):"
        },
        {
          "line": 171,
          "content": "        \"\"\"Transition to CLOSED state\"\"\""
        },
        {
          "line": 178,
          "content": "        \"\"\"Check if enough time has passed to allow recovery\"\"\""
        },
        {
          "line": 179,
          "content": "        if self.last_failure_time is None:"
        },
        {
          "line": 180,
          "content": "            return False"
        },
        {
          "line": 181,
          "content": "        return time.time() - self.last_failure_time >= self.recovery_timeout"
        },
        {
          "line": 183,
          "content": "    def _get_remaining_time(self) -> float:"
        },
        {
          "line": 184,
          "content": "        \"\"\"Get remaining time until recovery attempt\"\"\""
        },
        {
          "line": 191,
          "content": "        \"\"\"Get current state information\"\"\""
        },
        {
          "line": 192,
          "content": "        return {"
        },
        {
          "line": 197,
          "content": "            'remaining_time': self._get_remaining_time() if self.state == CircuitBreakerState.OPEN else 0,"
        },
        {
          "line": 203,
          "content": "    def force_open(self):"
        },
        {
          "line": 204,
          "content": "        \"\"\"Force the circuit breaker to OPEN state\"\"\""
        },
        {
          "line": 210,
          "content": "        \"\"\"Force the circuit breaker to CLOSED state\"\"\""
        },
        {
          "line": 216,
          "content": "# Global circuit breaker instances for different AI platforms"
        },
        {
          "line": 220,
          "content": "def get_circuit_breaker(platform_name: str, model_name: str = None) -> CircuitBreaker:"
        },
        {
          "line": 221,
          "content": "    \"\"\""
        },
        {
          "line": 230,
          "content": "    \"\"\""
        },
        {
          "line": 231,
          "content": "    # Create a unique name for the circuit breaker"
        },
        {
          "line": 232,
          "content": "    name = f\"{platform_name}_{model_name}\" if model_name else platform_name"
        },
        {
          "line": 234,
          "content": "    if name not in _circuit_breakers:"
        },
        {
          "line": 236,
          "content": "        if platform_name.lower() in ['doubao', 'doubao', 'bean']:"
        },
        {
          "line": 240,
          "content": "                failure_threshold=3,    # Lower threshold for Doubao"
        },
        {
          "line": 244,
          "content": "        elif platform_name.lower() in ['deepseek', 'deepseek', 'deepseek-coder']:"
        },
        {
          "line": 256,
          "content": "                failure_threshold=3,  # Lower threshold for better protection"
        },
        {
          "line": 261,
          "content": "    return _circuit_breakers[name]"
        },
        {
          "line": 264,
          "content": "def reset_circuit_breaker(platform_name: str, model_name: str = None):"
        },
        {
          "line": 265,
          "content": "    \"\"\""
        },
        {
          "line": 271,
          "content": "    \"\"\""
        },
        {
          "line": 272,
          "content": "    name = f\"{platform_name}_{model_name}\" if model_name else platform_name"
        },
        {
          "line": 273,
          "content": "    if name in _circuit_breakers:"
        },
        {
          "line": 275,
          "content": "        api_logger.info(f\"Circuit breaker for {name} reset to CLOSED state\")"
        },
        {
          "line": 278,
          "content": "def reset_all_circuit_breakers():"
        },
        {
          "line": 279,
          "content": "    \"\"\""
        },
        {
          "line": 281,
          "content": "    \"\"\""
        },
        {
          "line": 282,
          "content": "    for name, circuit_breaker in _circuit_breakers.items():"
        },
        {
          "line": 288,
          "content": "def get_all_circuit_breaker_states():"
        },
        {
          "line": 289,
          "content": "    \"\"\""
        },
        {
          "line": 294,
          "content": "    \"\"\""
        },
        {
          "line": 296,
          "content": "    for name, circuit_breaker in _circuit_breakers.items():"
        },
        {
          "line": 298,
          "content": "    return states"
        },
        {
          "line": 301,
          "content": "# Decorator for easy integration"
        },
        {
          "line": 302,
          "content": "def circuit_breaker(platform_name: str, model_name: str = None):"
        },
        {
          "line": 303,
          "content": "    \"\"\""
        },
        {
          "line": 309,
          "content": "    \"\"\""
        },
        {
          "line": 310,
          "content": "    def decorator(func):"
        },
        {
          "line": 311,
          "content": "        def wrapper(*args, **kwargs):"
        },
        {
          "line": 313,
          "content": "            return cb.call(func, *args, **kwargs)"
        },
        {
          "line": 314,
          "content": "        return wrapper"
        },
        {
          "line": 315,
          "content": "    return decorator"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/database_core.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 39,
          "content": "    \"\"\"获取数据库连接（从连接池）\"\"\""
        },
        {
          "line": 40,
          "content": "    return get_db_pool().get_connection()"
        },
        {
          "line": 43,
          "content": "def return_connection(conn: sqlite3.Connection):"
        },
        {
          "line": 44,
          "content": "    \"\"\"归还数据库连接\"\"\""
        },
        {
          "line": 49,
          "content": "    \"\"\"关闭数据库连接池\"\"\""
        },
        {
          "line": 55,
          "content": "def init_db():"
        },
        {
          "line": 56,
          "content": "    \"\"\"初始化数据库表结构\"\"\""
        },
        {
          "line": 77,
          "content": "        ''')"
        },
        {
          "line": 94,
          "content": "        ''')"
        },
        {
          "line": 106,
          "content": "        ''')"
        },
        {
          "line": 116,
          "content": "        ''')"
        },
        {
          "line": 129,
          "content": "        ''')"
        },
        {
          "line": 143,
          "content": "        ''')"
        },
        {
          "line": 157,
          "content": "        ''')"
        },
        {
          "line": 168,
          "content": "        ''')"
        },
        {
          "line": 184,
          "content": "    \"\"\"初始化同步数据库表（兼容旧接口）\"\"\""
        },
        {
          "line": 191,
          "content": "def get_database_metrics() -> Dict[str, Any]:"
        },
        {
          "line": 192,
          "content": "    \"\"\"获取数据库监控指标\"\"\""
        },
        {
          "line": 201,
          "content": "    \"\"\"重置数据库监控指标\"\"\""
        },
        {
          "line": 207,
          "content": "def get_or_create_user_by_unionid("
        },
        {
          "line": 211,
          "content": "    \"\"\""
        },
        {
          "line": 215,
          "content": "    \"\"\""
        },
        {
          "line": 216,
          "content": "    from wechat_backend.database_repositories import get_db_connection"
        },
        {
          "line": 225,
          "content": "        if row:"
        },
        {
          "line": 226,
          "content": "            return row['id'], False"
        },
        {
          "line": 231,
          "content": "        ''', (openid, union_id))"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/cruise_executor.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 22,
          "content": "    \"\"\""
        },
        {
          "line": 33,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/app.py",
      "lines": [
        {
          "line": 38,
          "content": "# Conditionally import auth module to handle JWT dependency"
        },
        {
          "line": 75,
          "content": "    \"\"\"Get access token from WeChat API\"\"\""
        },
        {
          "line": 78,
          "content": "    # Check if token is still valid"
        },
        {
          "line": 79,
          "content": "    if access_token and token_expiration_time and datetime.now() < datetime.fromtimestamp(token_expiration_time):"
        },
        {
          "line": 81,
          "content": "        return access_token"
        },
        {
          "line": 90,
          "content": "    app_logger.info(f\"Requesting new access token for app_id: {APP_ID}\")"
        },
        {
          "line": 94,
          "content": "    if 'access_token' in data:"
        },
        {
          "line": 99,
          "content": "        return access_token"
        },
        {
          "line": 124,
          "content": "from wechat_backend.views import wechat_bp"
        },
        {
          "line": 128,
          "content": "from wechat_backend.views.diagnosis_api import register_diagnosis_api"
        },
        {
          "line": 132,
          "content": "from wechat_backend.views_geo_analysis import init_geo_analysis_routes"
        },
        {
          "line": 136,
          "content": "from wechat_backend.views_p1_analysis import init_p1_analysis_routes"
        },
        {
          "line": 140,
          "content": "from wechat_backend.views_p2_optimization import init_p2_optimization_routes"
        },
        {
          "line": 144,
          "content": "from wechat_backend.views_permission import init_permission_routes, init_permission_db"
        },
        {
          "line": 149,
          "content": "from wechat_backend.views_admin import init_admin_routes"
        },
        {
          "line": 153,
          "content": "from wechat_backend.views_analytics import init_analytics_routes"
        },
        {
          "line": 157,
          "content": "from wechat_backend.views_audit import init_audit_routes"
        },
        {
          "line": 161,
          "content": "from wechat_backend.views_intelligence import register_blueprints as register_intelligence_blueprints"
        },
        {
          "line": 165,
          "content": "from wechat_backend.views_sync import register_blueprints as register_sync_blueprints"
        },
        {
          "line": 169,
          "content": "from wechat_backend.views_analytics_behavior import register_blueprints as register_analytics_blueprints"
        },
        {
          "line": 173,
          "content": "from wechat_backend.views_audit_full import register_blueprints as register_audit_full_blueprints"
        },
        {
          "line": 177,
          "content": "from wechat_backend.views_pdf_export import register_blueprints as register_pdf_export_blueprints"
        },
        {
          "line": 181,
          "content": "from wechat_backend.views_pdf_export_v2 import register_blueprints as register_pdf_export_blueprints_v2"
        },
        {
          "line": 185,
          "content": "from wechat_backend.cache.api_cache import cache_bp, start_cache_maintenance"
        },
        {
          "line": 190,
          "content": "from wechat_backend.database.query_optimizer import init_recommended_indexes"
        },
        {
          "line": 200,
          "content": "def csrf_exempt_api():"
        },
        {
          "line": 201,
          "content": "    if request.path.startswith('/api/') or request.path.startswith('/test/'):"
        },
        {
          "line": 206,
          "content": "def after_request(response):"
        },
        {
          "line": 207,
          "content": "    \"\"\"Add security headers to all responses\"\"\""
        },
        {
          "line": 224,
          "content": "    \"\"\"预热所有已注册的API适配器\"\"\""
        },
        {
          "line": 225,
          "content": "    from wechat_backend.logging_config import api_logger"
        },
        {
          "line": 226,
          "content": "    from wechat_backend.ai_adapters.factory import AIAdapterFactory"
        },
        {
          "line": 233,
          "content": "    for adapter_name in adapters_to_warm:"
        },
        {
          "line": 235,
          "content": "            # Try to create a minimal instance for health check"
        },
        {
          "line": 236,
          "content": "            # We'll use a dummy API key for the warm-up, as the actual key will be validated later"
        },
        {
          "line": 237,
          "content": "            from config import Config  # P0-1 修复"
        },
        {
          "line": 241,
          "content": "            if api_key:"
        },
        {
          "line": 242,
          "content": "                # Create adapter with actual API key if available"
        },
        {
          "line": 246,
          "content": "                if hasattr(adapter, '_health_check'):"
        },
        {
          "line": 261,
          "content": "import threading"
        },
        {
          "line": 266,
          "content": "    from wechat_backend.services.sse_service_v2 import start_cleanup_thread as sse_start_cleanup, register_sse_routes"
        },
        {
          "line": 276,
          "content": "    import sys"
        },
        {
          "line": 277,
          "content": "    from pathlib import Path"
        },
        {
          "line": 281,
          "content": "    if str(backend_root) not in sys.path:"
        },
        {
          "line": 285,
          "content": "    import importlib.util"
        },
        {
          "line": 300,
          "content": "    import traceback"
        },
        {
          "line": 305,
          "content": "def index():"
        },
        {
          "line": 307,
          "content": "    return jsonify({"
        },
        {
          "line": 315,
          "content": "def health_check():"
        },
        {
          "line": 317,
          "content": "    return jsonify({"
        },
        {
          "line": 326,
          "content": "def get_config():"
        },
        {
          "line": 327,
          "content": "    \"\"\"Return basic configuration info\"\"\""
        },
        {
          "line": 343,
          "content": "    \"\"\""
        },
        {
          "line": 351,
          "content": "    \"\"\""
        },
        {
          "line": 381,
          "content": "    \"\"\""
        },
        {
          "line": 389,
          "content": "    \"\"\""
        },
        {
          "line": 415,
          "content": "    \"\"\""
        },
        {
          "line": 424,
          "content": "    \"\"\""
        },
        {
          "line": 473,
          "content": "    \"\"\""
        },
        {
          "line": 477,
          "content": "    \"\"\""
        },
        {
          "line": 505,
          "content": "    \"\"\""
        },
        {
          "line": 514,
          "content": "    \"\"\""
        },
        {
          "line": 571,
          "content": "    # Using standard Flask port 5000 for consistency"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_geo_analysis.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "\"\"\""
        },
        {
          "line": 37,
          "content": "    \"\"\"GEO 分析数据模型\"\"\""
        },
        {
          "line": 40,
          "content": "    def from_execution_id(execution_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 41,
          "content": "        \"\"\"从 execution_id 获取 GEO 分析数据\"\"\""
        },
        {
          "line": 50,
          "content": "        ''', (execution_id,))"
        },
        {
          "line": 52,
          "content": "        if not result:"
        },
        {
          "line": 53,
          "content": "            return None"
        },
        {
          "line": 63,
          "content": "        ''', (execution_id,))"
        },
        {
          "line": 94,
          "content": "    \"\"\"工作流结果数据模型\"\"\""
        },
        {
          "line": 97,
          "content": "    def from_execution_id(execution_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 98,
          "content": "        \"\"\"从 execution_id 获取工作流结果\"\"\""
        },
        {
          "line": 144,
          "content": "    \"\"\"ROI 指标数据模型\"\"\""
        },
        {
          "line": 147,
          "content": "    def from_execution_id(execution_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 148,
          "content": "        \"\"\"从 execution_id 获取 ROI 指标\"\"\""
        },
        {
          "line": 211,
          "content": "    \"\"\""
        },
        {
          "line": 228,
          "content": "    \"\"\""
        },
        {
          "line": 271,
          "content": "    \"\"\""
        },
        {
          "line": 287,
          "content": "    \"\"\""
        },
        {
          "line": 330,
          "content": "    \"\"\""
        },
        {
          "line": 346,
          "content": "    \"\"\""
        },
        {
          "line": 392,
          "content": "    \"\"\"初始化 GEO 分析路由\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/exceptions.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "    \"\"\"基础 API 异常类\"\"\""
        },
        {
          "line": 13,
          "content": "    def __init__("
        },
        {
          "line": 26,
          "content": "    def to_dict(self) -> Dict[str, Any]:"
        },
        {
          "line": 27,
          "content": "        \"\"\"转换为字典格式，便于返回给前端\"\"\""
        },
        {
          "line": 37,
          "content": "    \"\"\"输入验证错误\"\"\""
        },
        {
          "line": 39,
          "content": "    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):"
        },
        {
          "line": 48,
          "content": "class AIPlatformError(BaseAPIException):"
        },
        {
          "line": 49,
          "content": "    \"\"\"AI 平台调用错误\"\"\""
        },
        {
          "line": 69,
          "content": "    \"\"\"AI 配置错误（如 API Key 缺失）\"\"\""
        },
        {
          "line": 71,
          "content": "    def __init__(self, message: str, platform: Optional[str] = None):"
        },
        {
          "line": 80,
          "content": "class TaskExecutionError(BaseAPIException):"
        },
        {
          "line": 81,
          "content": "    \"\"\"任务执行错误\"\"\""
        },
        {
          "line": 101,
          "content": "    \"\"\"任务超时错误\"\"\""
        },
        {
          "line": 103,
          "content": "    def __init__("
        },
        {
          "line": 120,
          "content": "class NotFoundError(BaseAPIException):"
        },
        {
          "line": 121,
          "content": "    \"\"\"资源未找到错误\"\"\""
        },
        {
          "line": 133,
          "content": "    \"\"\"认证错误\"\"\""
        },
        {
          "line": 135,
          "content": "    def __init__(self, message: str = '认证失败，请重新登录'):"
        },
        {
          "line": 143,
          "content": "class PermissionError(BaseAPIException):"
        },
        {
          "line": 144,
          "content": "    \"\"\"权限错误\"\"\""
        },
        {
          "line": 155,
          "content": "    \"\"\"数据库错误\"\"\""
        },
        {
          "line": 157,
          "content": "    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):"
        },
        {
          "line": 166,
          "content": "class RateLimitError(BaseAPIException):"
        },
        {
          "line": 167,
          "content": "    \"\"\"请求频率限制错误\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/diagnosis_report_storage.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "\"\"\""
        },
        {
          "line": 62,
          "content": "    \"\"\"计算数据 SHA256 校验和\"\"\""
        },
        {
          "line": 65,
          "content": "    return hashlib.sha256(json_str.encode('utf-8')).hexdigest()"
        },
        {
          "line": 68,
          "content": "def verify_checksum(data: Dict[str, Any], checksum: str) -> bool:"
        },
        {
          "line": 69,
          "content": "    \"\"\"验证数据完整性\"\"\""
        },
        {
          "line": 74,
          "content": "    \"\"\"获取服务器版本号\"\"\""
        },
        {
          "line": 76,
          "content": "    return os.getenv('SERVER_VERSION', '2.0.0')"
        },
        {
          "line": 79,
          "content": "def get_file_archive_path(execution_id: str, created_at: datetime) -> str:"
        },
        {
          "line": 80,
          "content": "    \"\"\"获取文件归档路径\"\"\""
        },
        {
          "line": 95,
          "content": "    \"\"\"获取归档文件路径（压缩）\"\"\""
        },
        {
          "line": 97,
          "content": "    return os.path.join("
        },
        {
          "line": 106,
          "content": "class DiagnosisReportRepository:"
        },
        {
          "line": 107,
          "content": "    \"\"\"诊断报告仓库 - 统一数据访问层\"\"\""
        },
        {
          "line": 111,
          "content": "        \"\"\"获取数据库连接\"\"\""
        },
        {
          "line": 123,
          "content": "    def create_report(self, execution_id: str, user_id: str, config: Dict[str, Any]) -> int:"
        },
        {
          "line": 124,
          "content": "        \"\"\""
        },
        {
          "line": 134,
          "content": "        \"\"\""
        },
        {
          "line": 153,
          "content": "            ''', ("
        },
        {
          "line": 177,
          "content": "        \"\"\"更新报告状态\"\"\""
        },
        {
          "line": 187,
          "content": "            ''', ("
        },
        {
          "line": 196,
          "content": "        \"\"\"根据执行 ID 获取报告\"\"\""
        },
        {
          "line": 203,
          "content": "            ''', (execution_id,))"
        },
        {
          "line": 216,
          "content": "        \"\"\"获取用户历史报告\"\"\""
        },
        {
          "line": 227,
          "content": "            ''', (user_id, limit, offset))"
        },
        {
          "line": 238,
          "content": "        \"\"\"创建报告快照\"\"\""
        },
        {
          "line": 249,
          "content": "            ''', ("
        },
        {
          "line": 264,
          "content": "    \"\"\"诊断结果仓库\"\"\""
        },
        {
          "line": 267,
          "content": "    def get_connection(self):"
        },
        {
          "line": 268,
          "content": "        \"\"\"获取数据库连接\"\"\""
        },
        {
          "line": 281,
          "content": "        \"\"\"添加单个诊断结果（完整版 - Migration 004）"
        },
        {
          "line": 297,
          "content": "        \"\"\""
        },
        {
          "line": 325,
          "content": "            ''', ("
        },
        {
          "line": 331,
          "content": "                response.get('content', '') if isinstance(response, dict) else '',"
        },
        {
          "line": 332,
          "content": "                response.get('latency') if isinstance(response, dict) else None,"
        },
        {
          "line": 353,
          "content": "                1 if result.get('is_fallback', False) else 0,"
        },
        {
          "line": 359,
          "content": "            return result_id"
        },
        {
          "line": 361,
          "content": "    def get_results_by_execution_id(self, execution_id: str) -> List[Dict[str, Any]]:"
        },
        {
          "line": 362,
          "content": "        \"\"\"根据执行 ID 获取所有结果\"\"\""
        },
        {
          "line": 370,
          "content": "            ''', (execution_id,))"
        },
        {
          "line": 373,
          "content": "            for row in cursor.fetchall():"
        },
        {
          "line": 385,
          "content": "            return results"
        },
        {
          "line": 388,
          "content": "class DiagnosisAnalysisRepository:"
        },
        {
          "line": 389,
          "content": "    \"\"\"诊断分析仓库\"\"\""
        },
        {
          "line": 393,
          "content": "        \"\"\"获取数据库连接\"\"\""
        },
        {
          "line": 405,
          "content": "    def add_analysis(self, report_id: int, execution_id: str,"
        },
        {
          "line": 407,
          "content": "        \"\"\"添加分析数据\"\"\""
        },
        {
          "line": 418,
          "content": "            ''', ("
        },
        {
          "line": 428,
          "content": "            return analysis_id"
        },
        {
          "line": 430,
          "content": "    def get_analysis_by_execution_id(self, execution_id: str) -> Dict[str, Any]:"
        },
        {
          "line": 431,
          "content": "        \"\"\"根据执行 ID 获取所有分析数据\"\"\""
        },
        {
          "line": 439,
          "content": "            ''', (execution_id,))"
        },
        {
          "line": 442,
          "content": "            for row in cursor.fetchall():"
        },
        {
          "line": 447,
          "content": "            return analysis"
        },
        {
          "line": 450,
          "content": "class FileArchiveManager:"
        },
        {
          "line": 451,
          "content": "    \"\"\"文件归档管理器\"\"\""
        },
        {
          "line": 455,
          "content": "        \"\"\"保存报告到文件\"\"\""
        },
        {
          "line": 456,
          "content": "        if created_at is None:"
        },
        {
          "line": 469,
          "content": "        return filepath"
        },
        {
          "line": 471,
          "content": "    def archive_report(self, execution_id: str, report_data: Dict[str, Any]) -> str:"
        },
        {
          "line": 472,
          "content": "        \"\"\"归档报告（压缩）\"\"\""
        },
        {
          "line": 488,
          "content": "        \"\"\"从文件读取报告\"\"\""
        },
        {
          "line": 491,
          "content": "        if not os.path.exists(filepath):"
        },
        {
          "line": 494,
          "content": "            if os.path.exists(archive_path):"
        },
        {
          "line": 496,
          "content": "                    return json.load(f)"
        },
        {
          "line": 497,
          "content": "            return None"
        },
        {
          "line": 500,
          "content": "            return json.load(f)"
        },
        {
          "line": 502,
          "content": "    def cleanup_old_files(self, days: int = ARCHIVE_THRESHOLD_DAYS) -> Dict[str, Any]:"
        },
        {
          "line": 503,
          "content": "        \"\"\"清理旧文件（移动到归档）\"\"\""
        },
        {
          "line": 568,
          "content": "    \"\"\"诊断报告服务 - 统一业务逻辑\"\"\""
        },
        {
          "line": 570,
          "content": "    def __init__(self):"
        },
        {
          "line": 576,
          "content": "    def create_report(self, execution_id: str, user_id: str, config: Dict[str, Any]) -> int:"
        },
        {
          "line": 577,
          "content": "        \"\"\"创建诊断报告\"\"\""
        },
        {
          "line": 581,
          "content": "        \"\"\"添加诊断结果\"\"\""
        },
        {
          "line": 582,
          "content": "        return self.result_repo.add_result(report_id, execution_id, result)"
        },
        {
          "line": 584,
          "content": "    def add_analysis(self, report_id: int, execution_id: str,"
        },
        {
          "line": 586,
          "content": "        \"\"\"添加分析数据\"\"\""
        },
        {
          "line": 590,
          "content": "        \"\"\"完成报告（创建快照、归档）\"\"\""
        },
        {
          "line": 598,
          "content": "        if not report:"
        },
        {
          "line": 600,
          "content": "            return False"
        },
        {
          "line": 616,
          "content": "        return True"
        },
        {
          "line": 618,
          "content": "    def get_full_report(self, execution_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 619,
          "content": "        \"\"\"获取完整报告\"\"\""
        },
        {
          "line": 654,
          "content": "        \"\"\"获取用户历史\"\"\""
        },
        {
          "line": 658,
          "content": "        return {"
        },
        {
          "line": 671,
          "content": "def init_database_tables():"
        },
        {
          "line": 672,
          "content": "    \"\"\"初始化数据库表\"\"\""
        },
        {
          "line": 697,
          "content": "        ''')"
        },
        {
          "line": 719,
          "content": "        ''')"
        },
        {
          "line": 733,
          "content": "        ''')"
        },
        {
          "line": 747,
          "content": "        ''')"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/incremental_aggregator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "\"\"\""
        },
        {
          "line": 27,
          "content": "    \"\"\"增量结果聚合器\"\"\""
        },
        {
          "line": 29,
          "content": "    def __init__(self, main_brand: str, all_brands: List[str], questions: List[str]):"
        },
        {
          "line": 30,
          "content": "        \"\"\""
        },
        {
          "line": 37,
          "content": "        \"\"\""
        },
        {
          "line": 63,
          "content": "        for brand in all_brands:"
        },
        {
          "line": 64,
          "content": "            if brand != main_brand:"
        },
        {
          "line": 76,
          "content": "        for question in questions:"
        },
        {
          "line": 85,
          "content": "    def add_result(self, result: Dict[str, Any]) -> Dict[str, Any]:"
        },
        {
          "line": 86,
          "content": "        \"\"\""
        },
        {
          "line": 94,
          "content": "        \"\"\""
        },
        {
          "line": 112,
          "content": "        return self.get_aggregated_results()"
        },
        {
          "line": 114,
          "content": "    def _extract_geo_data(self, response: str, brand: str) -> Dict[str, Any]:"
        },
        {
          "line": 115,
          "content": "        \"\"\""
        },
        {
          "line": 120,
          "content": "        \"\"\""
        },
        {
          "line": 139,
          "content": "        if competitors_mentioned:"
        },
        {
          "line": 142,
          "content": "        return geo_data"
        },
        {
          "line": 144,
          "content": "    def _extract_rank(self, response: str, brand: str) -> int:"
        },
        {
          "line": 145,
          "content": "        \"\"\"提取排名\"\"\""
        },
        {
          "line": 164,
          "content": "        \"\"\"估算情感分数\"\"\""
        },
        {
          "line": 179,
          "content": "        positive_count = sum(1 for word in positive_words if word in response)"
        },
        {
          "line": 180,
          "content": "        negative_count = sum(1 for word in negative_words if word in response)"
        },
        {
          "line": 182,
          "content": "        if positive_count > negative_count:"
        },
        {
          "line": 184,
          "content": "        elif negative_count > positive_count:"
        },
        {
          "line": 187,
          "content": "        return min(max(score, 0.0), 1.0)"
        },
        {
          "line": 189,
          "content": "    def _extract_competitors(self, response: str) -> List[str]:"
        },
        {
          "line": 190,
          "content": "        \"\"\"提取提及的竞品\"\"\""
        },
        {
          "line": 206,
          "content": "        \"\"\"更新聚合统计\"\"\""
        },
        {
          "line": 212,
          "content": "        if brand == self.main_brand:"
        },
        {
          "line": 215,
          "content": "            if success:"
        },
        {
          "line": 219,
          "content": "            if geo_data['brand_mentioned']:"
        },
        {
          "line": 221,
          "content": "            if rank > 0:"
        },
        {
          "line": 227,
          "content": "                for stats in self.aggregated_stats['competitors'].values()"
        },
        {
          "line": 230,
          "content": "            if total_responses > 0:"
        },
        {
          "line": 236,
          "content": "            if main_stats['geo_mentioned_count'] > 0:"
        },
        {
          "line": 242,
          "content": "        if brand in self.aggregated_stats['competitors']:"
        },
        {
          "line": 245,
          "content": "            if success:"
        },
        {
          "line": 251,
          "content": "        if model not in self.aggregated_stats['models']:"
        },
        {
          "line": 260,
          "content": "        if success:"
        },
        {
          "line": 270,
          "content": "        if question in self.aggregated_stats['questions']:"
        },
        {
          "line": 274,
          "content": "            if brand == self.main_brand and geo_data['brand_mentioned']:"
        },
        {
          "line": 277,
          "content": "            if brand != self.main_brand:"
        },
        {
          "line": 278,
          "content": "                if brand not in q_stats['competitor_mentions']:"
        },
        {
          "line": 282,
          "content": "    def get_aggregated_results(self) -> Dict[str, Any]:"
        },
        {
          "line": 283,
          "content": "        \"\"\""
        },
        {
          "line": 288,
          "content": "        \"\"\""
        },
        {
          "line": 300,
          "content": "        for result in self.results:"
        },
        {
          "line": 317,
          "content": "        return {"
        },
        {
          "line": 322,
          "content": "                'avgSentiment': round(main_stats['sentiment_sum'] / main_stats['total_responses'], 2) if main_stats['total_responses'] > 0 else 0,"
        },
        {
          "line": 325,
          "content": "                'successRate': round(main_stats['success_count'] / main_stats['total_responses'] * 100, 2) if main_stats['total_responses'] > 0 else 0"
        },
        {
          "line": 336,
          "content": "    def _calculate_brand_rankings(self) -> List[Dict[str, Any]]:"
        },
        {
          "line": 337,
          "content": "        \"\"\"计算品牌排名\"\"\""
        },
        {
          "line": 378,
          "content": "        \"\"\"计算问题统计\"\"\""
        },
        {
          "line": 381,
          "content": "        for question, q_stats in self.aggregated_stats['questions'].items():"
        },
        {
          "line": 388,
          "content": "                ) if q_stats['total_responses'] > 0 else 0,"
        },
        {
          "line": 392,
          "content": "        return stats"
        },
        {
          "line": 394,
          "content": "    def _calculate_model_stats(self) -> List[Dict[str, Any]]:"
        },
        {
          "line": 395,
          "content": "        \"\"\"计算模型统计\"\"\""
        },
        {
          "line": 412,
          "content": "        \"\"\""
        },
        {
          "line": 422,
          "content": "        \"\"\""
        },
        {
          "line": 442,
          "content": "        \"\"\"获取摘要\"\"\""
        },
        {
          "line": 445,
          "content": "        return {"
        },
        {
          "line": 450,
          "content": "            'avg_sentiment': round(main_stats['sentiment_sum'] / main_stats['total_responses'], 2) if main_stats['total_responses'] > 0 else 0,"
        },
        {
          "line": 461,
          "content": "def get_aggregator(execution_id: str) -> IncrementalAggregator:"
        },
        {
          "line": 462,
          "content": "    \"\"\"获取指定执行 ID 的聚合器\"\"\""
        },
        {
          "line": 472,
          "content": "    \"\"\"创建并注册聚合器\"\"\""
        },
        {
          "line": 475,
          "content": "    return aggregator"
        },
        {
          "line": 478,
          "content": "def remove_aggregator(execution_id: str):"
        },
        {
          "line": 479,
          "content": "    \"\"\"移除聚合器\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/nxm_result_aggregator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\"生成结果哈希用于去重\"\"\""
        },
        {
          "line": 21,
          "content": "    return hashlib.md5(content.encode('utf-8')).hexdigest()"
        },
        {
          "line": 24,
          "content": "def normalize_brand_mentioned(value: Any) -> bool:"
        },
        {
          "line": 25,
          "content": "    \"\"\"标准化 brand_mentioned 字段\"\"\""
        },
        {
          "line": 36,
          "content": "    \"\"\"从文本中提取拦截信息\"\"\""
        },
        {
          "line": 37,
          "content": "    if not text:"
        },
        {
          "line": 38,
          "content": "        return ''"
        },
        {
          "line": 43,
          "content": "    for keyword in keywords:"
        },
        {
          "line": 44,
          "content": "        if keyword in text_lower:"
        },
        {
          "line": 45,
          "content": "            return f'检测到{keyword}'"
        },
        {
          "line": 47,
          "content": "    return ''"
        },
        {
          "line": 50,
          "content": "def parse_geo_with_validation("
        },
        {
          "line": 56,
          "content": "    \"\"\""
        },
        {
          "line": 62,
          "content": "    \"\"\""
        },
        {
          "line": 65,
          "content": "        from wechat_backend.ai_adapters.base_adapter import AIResponse"
        },
        {
          "line": 66,
          "content": "        if isinstance(response_text, AIResponse):"
        },
        {
          "line": 68,
          "content": "            if response_text.success and response_text.content:"
        },
        {
          "line": 71,
          "content": "                return {"
        },
        {
          "line": 84,
          "content": "        if geo_data.get('_error'):"
        },
        {
          "line": 86,
          "content": "            return geo_data, geo_data.get('_error')"
        },
        {
          "line": 88,
          "content": "        if not geo_data:"
        },
        {
          "line": 90,
          "content": "            return {"
        },
        {
          "line": 101,
          "content": "        if 'brand_mentioned' not in geo_data:"
        },
        {
          "line": 106,
          "content": "        if 'rank' not in geo_data:"
        },
        {
          "line": 109,
          "content": "        if 'sentiment' not in geo_data:"
        },
        {
          "line": 112,
          "content": "        if 'cited_sources' not in geo_data:"
        },
        {
          "line": 115,
          "content": "        if 'interception' not in geo_data:"
        },
        {
          "line": 118,
          "content": "        return geo_data, None"
        },
        {
          "line": 122,
          "content": "        return {"
        },
        {
          "line": 133,
          "content": "def verify_completion("
        },
        {
          "line": 137,
          "content": "    \"\"\""
        },
        {
          "line": 144,
          "content": "    \"\"\""
        },
        {
          "line": 147,
          "content": "    if actual_count == expected_total:"
        },
        {
          "line": 148,
          "content": "        return {"
        },
        {
          "line": 157,
          "content": "    return {"
        },
        {
          "line": 164,
          "content": "def calculate_result_quality(geo_data: Optional[Dict[str, Any]]) -> Dict[str, Any]:"
        },
        {
          "line": 165,
          "content": "    \"\"\""
        },
        {
          "line": 181,
          "content": "    \"\"\""
        },
        {
          "line": 183,
          "content": "    if geo_data is None:"
        },
        {
          "line": 184,
          "content": "        return {"
        },
        {
          "line": 201,
          "content": "    if geo_data.get('brand_mentioned'):"
        },
        {
          "line": 209,
          "content": "    if rank > 0:"
        },
        {
          "line": 217,
          "content": "    if sentiment != 0.0:"
        },
        {
          "line": 225,
          "content": "    if sources and len(sources) > 0:"
        },
        {
          "line": 234,
          "content": "    if interception and len(interception.strip()) > 0:"
        },
        {
          "line": 242,
          "content": "    if score >= 80:"
        },
        {
          "line": 244,
          "content": "    elif score >= 60:"
        },
        {
          "line": 246,
          "content": "    elif score >= 30:"
        },
        {
          "line": 251,
          "content": "    return {"
        },
        {
          "line": 258,
          "content": "def deduplicate_results(results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:"
        },
        {
          "line": 259,
          "content": "    \"\"\"去重结果\"\"\""
        },
        {
          "line": 286,
          "content": "    \"\"\"按品牌聚合结果\"\"\""
        },
        {
          "line": 287,
          "content": "    brand_results = [r for r in results if r.get('brand') == brand_name]"
        },
        {
          "line": 289,
          "content": "    if not brand_results:"
        },
        {
          "line": 290,
          "content": "        return {"
        },
        {
          "line": 301,
          "content": "    ranks = [r.get('geo_data', {}).get('rank', -1) for r in brand_results]"
        },
        {
          "line": 302,
          "content": "    sentiments = [r.get('geo_data', {}).get('sentiment', 0.0) for r in brand_results]"
        },
        {
          "line": 304,
          "content": "    valid_ranks = [r for r in ranks if r > 0]"
        },
        {
          "line": 305,
          "content": "    avg_rank = sum(valid_ranks) / len(valid_ranks) if valid_ranks else -1"
        },
        {
          "line": 307,
          "content": "    positive_count = sum(1 for s in sentiments if s > 0.5)"
        },
        {
          "line": 308,
          "content": "    negative_count = sum(1 for s in sentiments if s < -0.5)"
        },
        {
          "line": 312,
          "content": "    for r in brand_results:"
        },
        {
          "line": 313,
          "content": "        if r.get('error'):"
        },
        {
          "line": 321,
          "content": "    return {"
        },
        {
          "line": 324,
          "content": "        'avg_rank': round(avg_rank, 2) if avg_rank > 0 else -1,"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/error_handler.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 29,
          "content": "    \"\"\""
        },
        {
          "line": 33,
          "content": "    \"\"\""
        },
        {
          "line": 100,
          "content": "    \"\"\""
        },
        {
          "line": 104,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/API_INTEGRATION_PATCH.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "    from wechat_backend.views.diagnosis_api import register_diagnosis_api"
        },
        {
          "line": 23,
          "content": "    from wechat_backend.diagnosis_report_service import get_report_service"
        },
        {
          "line": 42,
          "content": "    if 'competitive_analysis' in execution_store[execution_id]:"
        },
        {
          "line": 44,
          "content": "    if 'brand_scores' in execution_store[execution_id]:"
        },
        {
          "line": 64,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/nxm_concurrent_engine.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "\"\"\""
        },
        {
          "line": 41,
          "content": "    \"\"\""
        },
        {
          "line": 49,
          "content": "    \"\"\""
        },
        {
          "line": 199,
          "content": "    \"\"\""
        },
        {
          "line": 216,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_pdf_export.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "\"\"\""
        },
        {
          "line": 29,
          "content": "    \"\"\""
        },
        {
          "line": 37,
          "content": "    \"\"\""
        },
        {
          "line": 75,
          "content": "                \"\"\")"
        },
        {
          "line": 79,
          "content": "                for row in rows:"
        },
        {
          "line": 90,
          "content": "                        if is_compressed and results_summary_raw:"
        },
        {
          "line": 93,
          "content": "                        elif results_summary_raw:"
        },
        {
          "line": 102,
          "content": "                    if summary_exec_id == execution_id:"
        },
        {
          "line": 108,
          "content": "                            if is_detailed_compressed and detailed_results_raw:"
        },
        {
          "line": 111,
          "content": "                            elif detailed_results_raw:"
        },
        {
          "line": 145,
          "content": "                        if results_summary:"
        },
        {
          "line": 151,
          "content": "        if not deep_result:"
        },
        {
          "line": 152,
          "content": "            return jsonify({'error': 'Test result not found', 'code': 'RESULT_NOT_FOUND'}), 404"
        },
        {
          "line": 156,
          "content": "        if isinstance(detailed_results, list):"
        },
        {
          "line": 157,
          "content": "            for result in detailed_results:"
        },
        {
          "line": 158,
          "content": "                if isinstance(result, dict):"
        },
        {
          "line": 191,
          "content": "        from wechat_backend.services.pdf_export_service import get_pdf_export_service"
        },
        {
          "line": 198,
          "content": "        return Response("
        },
        {
          "line": 210,
          "content": "        return jsonify({'error': 'Data format error', 'code': 'JSON_ERROR'}), 500"
        },
        {
          "line": 213,
          "content": "        return jsonify({'error': 'Failed to generate PDF report', 'details': str(e), 'code': 'PDF_GENERATION_ERROR'}), 500"
        },
        {
          "line": 219,
          "content": "def export_html_report():"
        },
        {
          "line": 220,
          "content": "    \"\"\""
        },
        {
          "line": 228,
          "content": "    \"\"\""
        },
        {
          "line": 232,
          "content": "    if not execution_id:"
        },
        {
          "line": 233,
          "content": "        return jsonify({'error': 'executionId is required'}), 400"
        },
        {
          "line": 237,
          "content": "        from wechat_backend.models import get_deep_intelligence_result"
        },
        {
          "line": 240,
          "content": "        if not deep_result:"
        },
        {
          "line": 241,
          "content": "            return jsonify({'error': 'Test result not found'}), 404"
        },
        {
          "line": 246,
          "content": "        return Response("
        },
        {
          "line": 256,
          "content": "        return jsonify({'error': 'Failed to generate HTML report', 'details': str(e)}), 500"
        },
        {
          "line": 259,
          "content": "def generate_html_report(data: Dict[str, Any], execution_id: str) -> str:"
        },
        {
          "line": 260,
          "content": "    \"\"\"生成 HTML 报告内容\"\"\""
        },
        {
          "line": 321,
          "content": "\"\"\""
        },
        {
          "line": 325,
          "content": "def register_blueprints(app):"
        },
        {
          "line": 326,
          "content": "    \"\"\"注册 PDF 导出 Blueprint\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/competitive_analysis.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Competitive Analysis Module for GEO Content Quality Validator"
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\"Types of brand mentions in AI responses\"\"\""
        },
        {
          "line": 23,
          "content": "class BrandMention:"
        },
        {
          "line": 24,
          "content": "    \"\"\"Represents a mention of a brand in an AI response\"\"\""
        },
        {
          "line": 36,
          "content": "    \"\"\"Result of competitor analysis\"\"\""
        },
        {
          "line": 42,
          "content": "    summary_insights: List[str]  # Key insights from the analysis"
        },
        {
          "line": 45,
          "content": "class MarketShareAnalyzer:"
        },
        {
          "line": 46,
          "content": "    \"\"\"Analyzes market share of mind in AI responses\"\"\""
        },
        {
          "line": 56,
          "content": "        \"\"\""
        },
        {
          "line": 65,
          "content": "        \"\"\""
        },
        {
          "line": 72,
          "content": "            # Count mentions for each brand"
        },
        {
          "line": 74,
          "content": "                # Case-insensitive search for brand mentions"
        },
        {
          "line": 79,
          "content": "                # Also check for variations (e.g., \"Apple\" vs \"Apple Inc.\")"
        },
        {
          "line": 103,
          "content": "    \"\"\"Analyzes why AI recommends certain brands over others\"\"\""
        },
        {
          "line": 105,
          "content": "    def __init__(self):"
        },
        {
          "line": 108,
          "content": "    def analyze_recommendation_weights("
        },
        {
          "line": 113,
          "content": "        \"\"\""
        },
        {
          "line": 122,
          "content": "        \"\"\""
        },
        {
          "line": 123,
          "content": "        weights = {brand: 0.0 for brand in brand_names}"
        },
        {
          "line": 139,
          "content": "        for response_data in responses:"
        },
        {
          "line": 143,
          "content": "            for brand in brand_names:"
        },
        {
          "line": 146,
          "content": "                # Check if brand is mentioned in the response"
        },
        {
          "line": 147,
          "content": "                if brand_lower in response_text:"
        },
        {
          "line": 150,
          "content": "                    # Check for recommendation keywords near the brand mention"
        },
        {
          "line": 151,
          "content": "                    for keyword in recommendation_keywords:"
        },
        {
          "line": 152,
          "content": "                        if keyword in response_text:"
        },
        {
          "line": 158,
          "content": "                            if abs(brand_pos - keyword_pos) < 100:  # Within 100 characters"
        },
        {
          "line": 161,
          "content": "                    # Check for positive indicators near the brand mention"
        },
        {
          "line": 162,
          "content": "                    for indicator in positive_indicators:"
        },
        {
          "line": 163,
          "content": "                        if indicator in response_text:"
        },
        {
          "line": 167,
          "content": "                            if abs(brand_pos - indicator_pos) < 100:"
        },
        {
          "line": 170,
          "content": "                    # Check if the brand appears in a comparative context"
        },
        {
          "line": 176,
          "content": "                    for context in comparative_contexts:"
        },
        {
          "line": 177,
          "content": "                        if context in response_text:"
        },
        {
          "line": 181,
          "content": "                            if abs(brand_pos - context_pos) < 150:  # Within 150 characters"
        },
        {
          "line": 188,
          "content": "                    if response_length > 0:"
        },
        {
          "line": 195,
          "content": "        max_weight = max(weights.values()) if weights.values() else 1"
        },
        {
          "line": 196,
          "content": "        if max_weight > 0:"
        },
        {
          "line": 197,
          "content": "            for brand in weights:"
        },
        {
          "line": 201,
          "content": "        return weights"
        },
        {
          "line": 204,
          "content": "class CompetitorIntelligenceAnalyzer:"
        },
        {
          "line": 205,
          "content": "    \"\"\"Analyzes competitor intelligence from AI responses\"\"\""
        },
        {
          "line": 215,
          "content": "        \"\"\""
        },
        {
          "line": 216,
          "content": "        Analyze competitor intelligence from AI responses"
        },
        {
          "line": 224,
          "content": "        \"\"\""
        },
        {
          "line": 252,
          "content": "                # Check if this brand is mentioned"
        },
        {
          "line": 259,
          "content": "                    # Look for comparative statements"
        },
        {
          "line": 308,
          "content": "    \"\"\"Main class for performing competitive analysis\"\"\""
        },
        {
          "line": 310,
          "content": "    def __init__(self):"
        },
        {
          "line": 316,
          "content": "    def perform_competitive_analysis("
        },
        {
          "line": 322,
          "content": "        \"\"\""
        },
        {
          "line": 332,
          "content": "        \"\"\""
        },
        {
          "line": 361,
          "content": "        api_logger.info(f\"Competitive analysis completed for target brand: {target_brand}\")"
        },
        {
          "line": 362,
          "content": "        return result"
        },
        {
          "line": 364,
          "content": "    def _analyze_category_performance("
        },
        {
          "line": 369,
          "content": "        \"\"\"Analyze performance by category/aspect\"\"\""
        },
        {
          "line": 407,
          "content": "        \"\"\"Generate summary insights from the analysis\"\"\""
        },
        {
          "line": 412,
          "content": "        max_competitor_share = max([market_share.get(comp, 0) for comp in competitor_brands], default=0)"
        },
        {
          "line": 414,
          "content": "        if target_share > max_competitor_share:"
        },
        {
          "line": 416,
          "content": "        elif target_share < max_competitor_share:"
        },
        {
          "line": 423,
          "content": "        max_competitor_weight = max([recommendation_weights.get(comp, 0) for comp in competitor_brands], default=0)"
        },
        {
          "line": 425,
          "content": "        if target_weight > max_competitor_weight:"
        },
        {
          "line": 427,
          "content": "        elif target_weight < max_competitor_weight:"
        },
        {
          "line": 434,
          "content": "        if target_positive > target_negative:"
        },
        {
          "line": 436,
          "content": "        elif target_negative > target_positive:"
        },
        {
          "line": 439,
          "content": "        return insights"
        },
        {
          "line": 443,
          "content": "if __name__ == \"__main__\":"
        },
        {
          "line": 444,
          "content": "    # Sample data for testing"
        },
        {
          "line": 454,
          "content": "            \"response\": \"iPhone is known for its premium build quality and ecosystem integration, while Samsung Galaxy offers more customization options. Both are excellent choices, but iPhone tends to hold value better.\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_audit_full.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "\"\"\""
        },
        {
          "line": 36,
          "content": "    \"\"\""
        },
        {
          "line": 58,
          "content": "    \"\"\""
        },
        {
          "line": 106,
          "content": "    \"\"\""
        },
        {
          "line": 124,
          "content": "    \"\"\""
        },
        {
          "line": 177,
          "content": "    \"\"\""
        },
        {
          "line": 192,
          "content": "    \"\"\""
        },
        {
          "line": 227,
          "content": "    \"\"\""
        },
        {
          "line": 237,
          "content": "    \"\"\""
        },
        {
          "line": 264,
          "content": "    \"\"\""
        },
        {
          "line": 278,
          "content": "    \"\"\""
        },
        {
          "line": 305,
          "content": "    \"\"\""
        },
        {
          "line": 310,
          "content": "        def create_report():"
        },
        {
          "line": 312,
          "content": "    \"\"\""
        },
        {
          "line": 354,
          "content": "    \"\"\"创建审计记录\"\"\""
        },
        {
          "line": 364,
          "content": "    if has_request_context():"
        },
        {
          "line": 373,
          "content": "    return {"
        },
        {
          "line": 388,
          "content": "def _save_audit_log(audit_record: Dict[str, Any]):"
        },
        {
          "line": 389,
          "content": "    \"\"\"保存审计日志\"\"\""
        },
        {
          "line": 406,
          "content": "    \"\"\"更新索引\"\"\""
        },
        {
          "line": 411,
          "content": "    if user_id not in _audit_indexes:"
        },
        {
          "line": 417,
          "content": "    if action not in _audit_indexes:"
        },
        {
          "line": 422,
          "content": "def _rebuild_index():"
        },
        {
          "line": 423,
          "content": "    \"\"\"重建索引\"\"\""
        },
        {
          "line": 434,
          "content": "    \"\"\"查询审计日志\"\"\""
        },
        {
          "line": 437,
          "content": "    for record in _audit_logs:"
        },
        {
          "line": 439,
          "content": "        if user_id and record.get('user_id') != user_id:"
        },
        {
          "line": 441,
          "content": "        if action and record.get('action') != action:"
        },
        {
          "line": 443,
          "content": "        if resource and record.get('resource') != resource:"
        },
        {
          "line": 445,
          "content": "        if severity and record.get('severity') != severity:"
        },
        {
          "line": 447,
          "content": "        if start_time and record.get('timestamp', '') < start_time:"
        },
        {
          "line": 449,
          "content": "        if end_time and record.get('timestamp', '') > end_time:"
        },
        {
          "line": 457,
          "content": "    return results"
        },
        {
          "line": 460,
          "content": "def _queue_audit_log(user_id: str, action: str, resource: str = None,"
        },
        {
          "line": 462,
          "content": "    \"\"\"异步记录审计日志（队列方式）\"\"\""
        },
        {
          "line": 478,
          "content": "    \"\"\"计算审计日期范围\"\"\""
        },
        {
          "line": 481,
          "content": "    if period == 'today':"
        },
        {
          "line": 482,
          "content": "        return {'start': today.isoformat(), 'end': today.isoformat()}"
        },
        {
          "line": 483,
          "content": "    elif period == 'week':"
        },
        {
          "line": 485,
          "content": "        return {'start': start.isoformat(), 'end': today.isoformat()}"
        },
        {
          "line": 486,
          "content": "    elif period == 'month':"
        },
        {
          "line": 488,
          "content": "        return {'start': start.isoformat(), 'end': today.isoformat()}"
        },
        {
          "line": 489,
          "content": "    elif period == 'custom' and start_date and end_date:"
        },
        {
          "line": 490,
          "content": "        return {'start': start_date, 'end': end_date}"
        },
        {
          "line": 492,
          "content": "        return {'start': today.isoformat(), 'end': today.isoformat()}"
        },
        {
          "line": 495,
          "content": "def _generate_audit_report(date_range: Dict[str, str], group_by: str) -> Dict[str, Any]:"
        },
        {
          "line": 496,
          "content": "    \"\"\"生成审计报告\"\"\""
        },
        {
          "line": 539,
          "content": "    \"\"\"按字段计数\"\"\""
        },
        {
          "line": 541,
          "content": "    for log in logs:"
        },
        {
          "line": 544,
          "content": "    return counts"
        },
        {
          "line": 547,
          "content": "def _group_by_field(logs: List[Dict], field: str) -> Dict[str, Any]:"
        },
        {
          "line": 548,
          "content": "    \"\"\"按字段分组\"\"\""
        },
        {
          "line": 559,
          "content": "    \"\"\"计算每日趋势\"\"\""
        },
        {
          "line": 562,
          "content": "    for log in logs:"
        },
        {
          "line": 566,
          "content": "    return ["
        },
        {
          "line": 568,
          "content": "        for date, count in sorted(daily_counts.items())"
        },
        {
          "line": 572,
          "content": "def _perform_compliance_check(check_type: str) -> Dict[str, Any]:"
        },
        {
          "line": 573,
          "content": "    \"\"\"执行合规性检查\"\"\""
        },
        {
          "line": 625,
          "content": "    \"\"\"判断是否为非工作时间\"\"\""
        },
        {
          "line": 629,
          "content": "        return dt.weekday() >= 5 or dt.hour < 9 or dt.hour > 18"
        },
        {
          "line": 633,
          "content": "        return False"
        },
        {
          "line": 636,
          "content": "def _get_user_activity(user_id: str, days: int) -> Dict[str, Any]:"
        },
        {
          "line": 637,
          "content": "    \"\"\"获取用户活动\"\"\""
        },
        {
          "line": 670,
          "content": "    \"\"\"计算风险评分\"\"\""
        },
        {
          "line": 675,
          "content": "    for log in logs:"
        },
        {
          "line": 676,
          "content": "        if log.get('action') in sensitive_actions:"
        },
        {
          "line": 678,
          "content": "        if log.get('severity') == 'warning':"
        },
        {
          "line": 680,
          "content": "        if log.get('severity') == 'error':"
        },
        {
          "line": 682,
          "content": "        if log.get('severity') == 'critical':"
        },
        {
          "line": 685,
          "content": "    return min(score, 100)  # 最高 100 分"
        },
        {
          "line": 688,
          "content": "def _get_risk_level(score: int) -> str:"
        },
        {
          "line": 689,
          "content": "    \"\"\"获取风险等级\"\"\""
        },
        {
          "line": 704,
          "content": "    \"\"\"注册审计 Blueprint\"\"\""
        },
        {
          "line": 705,
          "content": "    from wechat_backend.logging_config import api_logger"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/admin_system.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 26,
          "content": "    \"\"\"检查用户是否为管理员\"\"\""
        },
        {
          "line": 27,
          "content": "    if not user_id or user_id == 'anonymous':"
        },
        {
          "line": 28,
          "content": "        return False"
        },
        {
          "line": 36,
          "content": "        ''', (user_id,))"
        },
        {
          "line": 45,
          "content": "    \"\"\"装饰器：要求管理员权限\"\"\""
        },
        {
          "line": 46,
          "content": "    from functools import wraps"
        },
        {
          "line": 49,
          "content": "    def decorated_function(*args, **kwargs):"
        },
        {
          "line": 51,
          "content": "        if not is_admin_user(user_id):"
        },
        {
          "line": 52,
          "content": "            return jsonify({'error': 'Admin access required'}), 403"
        },
        {
          "line": 53,
          "content": "        return f(*args, **kwargs)"
        },
        {
          "line": 55,
          "content": "    return decorated_function"
        },
        {
          "line": 61,
          "content": "def admin_dashboard():"
        },
        {
          "line": 62,
          "content": "    \"\"\"获取管理员仪表盘数据\"\"\""
        },
        {
          "line": 91,
          "content": "        ''')"
        },
        {
          "line": 92,
          "content": "        pending_tasks = {row[0]: row[1] for row in cursor.fetchall()}"
        },
        {
          "line": 99,
          "content": "        ''')"
        },
        {
          "line": 142,
          "content": "    \"\"\"获取系统状态\"\"\""
        },
        {
          "line": 148,
          "content": "        db_size = os.path.getsize(DB_PATH) if db_exists else 0"
        },
        {
          "line": 155,
          "content": "        log_files = list(log_dir.glob('*.log')) if log_dir.exists() else []"
        },
        {
          "line": 157,
          "content": "        return jsonify({"
        },
        {
          "line": 165,
          "content": "                'files': [f.name for f in log_files],"
        },
        {
          "line": 173,
          "content": "        return jsonify({'error': str(e)}), 500"
        },
        {
          "line": 179,
          "content": "def get_system_logs():"
        },
        {
          "line": 180,
          "content": "    \"\"\"获取系统日志\"\"\""
        },
        {
          "line": 212,
          "content": "    \"\"\"获取系统配置\"\"\""
        },
        {
          "line": 216,
          "content": "        from wechat_backend.config import Config"
        },
        {
          "line": 226,
          "content": "        return jsonify({'config': config})"
        },
        {
          "line": 230,
          "content": "        return jsonify({'error': str(e)}), 500"
        },
        {
          "line": 233,
          "content": "def init_system_management_routes(app):"
        },
        {
          "line": 234,
          "content": "    \"\"\"注册系统管理路由\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/nxm_streaming_aggregator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        },
        {
          "line": 29,
          "content": "    \"\"\""
        },
        {
          "line": 37,
          "content": "    \"\"\""
        },
        {
          "line": 78,
          "content": "        \"\"\"生成结果哈希（用于去重）\"\"\""
        },
        {
          "line": 84,
          "content": "        return hashlib.md5("
        },
        {
          "line": 88,
          "content": "    def _calculate_result_quality(self, geo_data: Dict[str, Any]) -> Dict[str, Any]:"
        },
        {
          "line": 89,
          "content": "        \"\"\"计算单个结果的质量评分\"\"\""
        },
        {
          "line": 146,
          "content": "        \"\"\""
        },
        {
          "line": 155,
          "content": "        \"\"\""
        },
        {
          "line": 163,
          "content": "        \"\"\"内部添加逻辑（无锁）\"\"\""
        },
        {
          "line": 166,
          "content": "        if result_hash in self.seen_hashes:"
        },
        {
          "line": 168,
          "content": "            return None"
        },
        {
          "line": 174,
          "content": "        if geo_data:"
        },
        {
          "line": 187,
          "content": "        if send_sse:"
        },
        {
          "line": 192,
          "content": "        return result"
        },
        {
          "line": 194,
          "content": "    def _update_stats(self, result: Dict[str, Any]):"
        },
        {
          "line": 195,
          "content": "        \"\"\"更新统计信息\"\"\""
        },
        {
          "line": 240,
          "content": "        \"\"\"发送部分结果更新（SSE 推送）\"\"\""
        },
        {
          "line": 250,
          "content": "                'progress': int((self.completed / self.total_tasks) * 100) if self.total_tasks > 0 else 0,"
        },
        {
          "line": 258,
          "content": "            if self.completed % 5 == 0:"
        },
        {
          "line": 269,
          "content": "    def get_partial_results(self) -> List[Dict[str, Any]]:"
        },
        {
          "line": 270,
          "content": "        \"\"\"获取当前已聚合的结果\"\"\""
        },
        {
          "line": 278,
          "content": "        \"\"\"获取品牌统计\"\"\""
        },
        {
          "line": 279,
          "content": "        if self.lock:"
        },
        {
          "line": 281,
          "content": "                if brand:"
        },
        {
          "line": 282,
          "content": "                    return dict(self.brand_stats.get(brand, {}))"
        },
        {
          "line": 284,
          "content": "                    return {k: dict(v) for k, v in self.brand_stats.items()}"
        },
        {
          "line": 286,
          "content": "            if brand:"
        },
        {
          "line": 287,
          "content": "                return dict(self.brand_stats.get(brand, {}))"
        },
        {
          "line": 289,
          "content": "                return {k: dict(v) for k, v in self.brand_stats.items()}"
        },
        {
          "line": 291,
          "content": "    def get_model_stats(self, model: str = None) -> Dict[str, Any]:"
        },
        {
          "line": 292,
          "content": "        \"\"\"获取模型统计\"\"\""
        },
        {
          "line": 306,
          "content": "        \"\"\"获取进度信息\"\"\""
        },
        {
          "line": 307,
          "content": "        if self.lock:"
        },
        {
          "line": 309,
          "content": "                return {"
        },
        {
          "line": 312,
          "content": "                    'progress': int((self.completed / self.total_tasks) * 100) if self.total_tasks > 0 else 0,"
        },
        {
          "line": 315,
          "content": "                    'success_rate': self.success_count / self.completed if self.completed > 0 else 0"
        },
        {
          "line": 318,
          "content": "            return {"
        },
        {
          "line": 321,
          "content": "                'progress': int((self.completed / self.total_tasks) * 100) if self.total_tasks > 0 else 0,"
        },
        {
          "line": 324,
          "content": "                'success_rate': self.success_count / self.completed if self.completed > 0 else 0"
        },
        {
          "line": 327,
          "content": "    def finalize(self) -> Dict[str, Any]:"
        },
        {
          "line": 328,
          "content": "        \"\"\""
        },
        {
          "line": 333,
          "content": "        \"\"\""
        },
        {
          "line": 338,
          "content": "        for brand in self.brand_stats.keys():"
        },
        {
          "line": 344,
          "content": "        for scores in self.brand_stats.values():"
        },
        {
          "line": 348,
          "content": "            'avg_score': sum(all_scores) / len(all_scores) if all_scores else 0,"
        },
        {
          "line": 350,
          "content": "            'success_rate': self.success_count / self.completed if self.completed > 0 else 0"
        },
        {
          "line": 353,
          "content": "        return {"
        },
        {
          "line": 364,
          "content": "    def _aggregate_brand_data(self, brand: str) -> Dict[str, Any]:"
        },
        {
          "line": 365,
          "content": "        \"\"\"聚合单个品牌的数据\"\"\""
        },
        {
          "line": 394,
          "content": "    \"\"\""
        },
        {
          "line": 398,
          "content": "        for partial_result in stream_aggregate_results(results_iterator, execution_id):"
        },
        {
          "line": 409,
          "content": "    \"\"\""
        },
        {
          "line": 436,
          "content": "    \"\"\"创建流式聚合器\"\"\""
        },
        {
          "line": 437,
          "content": "    return StreamingResultAggregator(execution_id, total_tasks)"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_audit.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 24,
          "content": "    \"\"\"装饰器：要求管理员权限\"\"\""
        },
        {
          "line": 25,
          "content": "    from functools import wraps"
        },
        {
          "line": 28,
          "content": "    def decorated_function(*args, **kwargs):"
        },
        {
          "line": 32,
          "content": "        if not user_id or user_id == 'anonymous':"
        },
        {
          "line": 33,
          "content": "            return jsonify({'error': 'Admin access required'}), 403"
        },
        {
          "line": 38,
          "content": "        return f(*args, **kwargs)"
        },
        {
          "line": 40,
          "content": "    return decorated_function"
        },
        {
          "line": 51,
          "content": "def query_audit_logs():"
        },
        {
          "line": 52,
          "content": "    \"\"\""
        },
        {
          "line": 63,
          "content": "    \"\"\""
        },
        {
          "line": 90,
          "content": "        return jsonify({"
        },
        {
          "line": 97,
          "content": "        return jsonify({'error': 'Failed to query audit logs'}), 500"
        },
        {
          "line": 108,
          "content": "def get_audit_stats():"
        },
        {
          "line": 109,
          "content": "    \"\"\""
        },
        {
          "line": 114,
          "content": "    \"\"\""
        },
        {
          "line": 126,
          "content": "        return jsonify({"
        },
        {
          "line": 133,
          "content": "        return jsonify({'error': 'Failed to get statistics'}), 500"
        },
        {
          "line": 144,
          "content": "def get_suspicious():"
        },
        {
          "line": 145,
          "content": "    \"\"\""
        },
        {
          "line": 151,
          "content": "    \"\"\""
        },
        {
          "line": 161,
          "content": "        return jsonify({"
        },
        {
          "line": 173,
          "content": "        return jsonify({'error': 'Failed to get suspicious activities'}), 500"
        },
        {
          "line": 184,
          "content": "def export_logs():"
        },
        {
          "line": 185,
          "content": "    \"\"\""
        },
        {
          "line": 193,
          "content": "    \"\"\""
        },
        {
          "line": 212,
          "content": "        if format_type == 'json':"
        },
        {
          "line": 213,
          "content": "            return Response("
        },
        {
          "line": 221,
          "content": "            return Response("
        },
        {
          "line": 231,
          "content": "        return jsonify({'error': 'Failed to export audit logs'}), 500"
        },
        {
          "line": 242,
          "content": "def get_admin_statistics():"
        },
        {
          "line": 243,
          "content": "    \"\"\""
        },
        {
          "line": 248,
          "content": "    \"\"\""
        },
        {
          "line": 266,
          "content": "        return jsonify({"
        },
        {
          "line": 273,
          "content": "        return jsonify({'error': 'Failed to get admin statistics'}), 500"
        },
        {
          "line": 276,
          "content": "def init_audit_routes(app):"
        },
        {
          "line": 277,
          "content": "    \"\"\"初始化审计日志路由\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/audit_logs.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\"初始化审计日志表\"\"\""
        },
        {
          "line": 24,
          "content": "    ''')"
        },
        {
          "line": 58,
          "content": "            ''')"
        },
        {
          "line": 79,
          "content": "        ''')"
        },
        {
          "line": 86,
          "content": "    ''')"
        },
        {
          "line": 91,
          "content": "    ''')"
        },
        {
          "line": 96,
          "content": "    ''')"
        },
        {
          "line": 101,
          "content": "    ''')"
        },
        {
          "line": 111,
          "content": "    \"\"\""
        },
        {
          "line": 125,
          "content": "    \"\"\""
        },
        {
          "line": 136,
          "content": "        ''', ("
        },
        {
          "line": 139,
          "content": "            json.dumps(request_data) if request_data else None,"
        },
        {
          "line": 152,
          "content": "def get_audit_logs(admin_id=None, action=None, resource=None,"
        },
        {
          "line": 154,
          "content": "    \"\"\""
        },
        {
          "line": 168,
          "content": "    \"\"\""
        },
        {
          "line": 176,
          "content": "    if admin_id:"
        },
        {
          "line": 180,
          "content": "    if action:"
        },
        {
          "line": 184,
          "content": "    if resource:"
        },
        {
          "line": 188,
          "content": "    if start_date:"
        },
        {
          "line": 192,
          "content": "    if end_date:"
        },
        {
          "line": 196,
          "content": "    where_clause = ' WHERE ' + ' AND '.join(conditions) if conditions else ''"
        },
        {
          "line": 211,
          "content": "    ''', params + [page_size, offset])"
        },
        {
          "line": 245,
          "content": "    \"\"\""
        },
        {
          "line": 253,
          "content": "    \"\"\""
        },
        {
          "line": 262,
          "content": "    ''', (start_date,))"
        },
        {
          "line": 272,
          "content": "    ''', (start_date,))"
        },
        {
          "line": 286,
          "content": "    ''', (start_date,))"
        },
        {
          "line": 289,
          "content": "        for row in cursor.fetchall()"
        },
        {
          "line": 296,
          "content": "    ''', (start_date,))"
        },
        {
          "line": 307,
          "content": "    ''', (start_date,))"
        },
        {
          "line": 310,
          "content": "        for row in cursor.fetchall()"
        },
        {
          "line": 315,
          "content": "    return {"
        },
        {
          "line": 318,
          "content": "        'error_rate': round(error_count / total_actions * 100, 2) if total_actions > 0 else 0,"
        },
        {
          "line": 329,
          "content": "def get_suspicious_activities(threshold=10, minutes=5):"
        },
        {
          "line": 330,
          "content": "    \"\"\""
        },
        {
          "line": 339,
          "content": "    \"\"\""
        },
        {
          "line": 355,
          "content": "    ''', (time_window, threshold))"
        },
        {
          "line": 376,
          "content": "    ''', (time_window, threshold // 2))"
        },
        {
          "line": 378,
          "content": "    for row in cursor.fetchall():"
        },
        {
          "line": 387,
          "content": "    return suspicious"
        },
        {
          "line": 390,
          "content": "def export_audit_logs(format='csv', admin_id=None, start_date=None, end_date=None):"
        },
        {
          "line": 391,
          "content": "    \"\"\""
        },
        {
          "line": 402,
          "content": "    \"\"\""
        },
        {
          "line": 414,
          "content": "    if format == 'json':"
        },
        {
          "line": 415,
          "content": "        return json.dumps(logs, indent=2, ensure_ascii=False)"
        },
        {
          "line": 418,
          "content": "        import csv"
        },
        {
          "line": 419,
          "content": "        import io"
        },
        {
          "line": 431,
          "content": "        for log in logs:"
        },
        {
          "line": 445,
          "content": "        return output.getvalue()"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/alerting.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 25,
          "content": "    \"\"\"告警级别\"\"\""
        },
        {
          "line": 34,
          "content": "class AlertConfig:"
        },
        {
          "line": 35,
          "content": "    \"\"\"告警配置\"\"\""
        },
        {
          "line": 65,
          "content": "    \"\"\"生成告警唯一标识（用于频率限制）\"\"\""
        },
        {
          "line": 67,
          "content": "    return hashlib.md5(content.encode('utf-8')).hexdigest()"
        },
        {
          "line": 70,
          "content": "def _should_send_alert(alert_type: str, message: str, level: str) -> bool:"
        },
        {
          "line": 71,
          "content": "    \"\"\""
        },
        {
          "line": 76,
          "content": "    \"\"\""
        },
        {
          "line": 86,
          "content": "    if alert_hash in _alert_history:"
        },
        {
          "line": 88,
          "content": "        if now - last_alert_time < rate_limit:"
        },
        {
          "line": 93,
          "content": "            return False"
        },
        {
          "line": 101,
          "content": "        k: v for k, v in _alert_history.items()"
        },
        {
          "line": 102,
          "content": "        if v > expiry_time"
        },
        {
          "line": 105,
          "content": "    return True"
        },
        {
          "line": 108,
          "content": "def _record_alert_count(level: str):"
        },
        {
          "line": 109,
          "content": "    \"\"\"记录告警次数（用于告警风暴检测）\"\"\""
        },
        {
          "line": 135,
          "content": "    \"\"\""
        },
        {
          "line": 140,
          "content": "    \"\"\""
        },
        {
          "line": 173,
          "content": "        \"\"\".strip()"
        },
        {
          "line": 195,
          "content": "        if response.status_code == 200:"
        },
        {
          "line": 197,
          "content": "            if result.get('errcode') == 0:"
        },
        {
          "line": 208,
          "content": "def send_wechat_work_alert(title: str, content: str, level: str):"
        },
        {
          "line": 209,
          "content": "    \"\"\""
        },
        {
          "line": 214,
          "content": "    \"\"\""
        },
        {
          "line": 215,
          "content": "    if not AlertConfig.WECHAT_WORK_WEBHOOK:"
        },
        {
          "line": 220,
          "content": "        import requests"
        },
        {
          "line": 223,
          "content": "        if level == AlertLevel.CRITICAL:"
        },
        {
          "line": 225,
          "content": "        elif level == AlertLevel.ERROR:"
        },
        {
          "line": 227,
          "content": "        elif level == AlertLevel.WARNING:"
        },
        {
          "line": 238,
          "content": "        \"\"\".strip()"
        },
        {
          "line": 277,
          "content": "    \"\"\""
        },
        {
          "line": 291,
          "content": "    \"\"\""
        },
        {
          "line": 334,
          "content": "    \"\"\""
        },
        {
          "line": 346,
          "content": "    \"\"\""
        },
        {
          "line": 375,
          "content": "    \"\"\""
        },
        {
          "line": 387,
          "content": "    \"\"\""
        },
        {
          "line": 411,
          "content": "    \"\"\""
        },
        {
          "line": 416,
          "content": "    \"\"\""
        },
        {
          "line": 438,
          "content": "    \"\"\""
        },
        {
          "line": 443,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/database_repositories.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 22,
          "content": "    \"\"\"获取数据库连接上下文管理器\"\"\""
        },
        {
          "line": 37,
          "content": "def save_test_record("
        },
        {
          "line": 47,
          "content": "    \"\"\"保存测试记录\"\"\""
        },
        {
          "line": 56,
          "content": "        ''', ("
        },
        {
          "line": 61,
          "content": "        return cursor.lastrowid"
        },
        {
          "line": 64,
          "content": "def get_user_test_history("
        },
        {
          "line": 69,
          "content": "    \"\"\"获取用户测试历史\"\"\""
        },
        {
          "line": 78,
          "content": "        ''', (user_openid, limit, offset))"
        },
        {
          "line": 79,
          "content": "        return [dict(row) for row in cursor.fetchall()]"
        },
        {
          "line": 82,
          "content": "def get_test_record_by_id(record_id: int) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 83,
          "content": "    \"\"\"根据 ID 获取测试记录\"\"\""
        },
        {
          "line": 95,
          "content": "    \"\"\"保存用户数据\"\"\""
        },
        {
          "line": 103,
          "content": "        ''', ("
        },
        {
          "line": 118,
          "content": "    \"\"\"获取用户数据\"\"\""
        },
        {
          "line": 123,
          "content": "        if since_timestamp:"
        },
        {
          "line": 128,
          "content": "            ''', (user_id, since_timestamp))"
        },
        {
          "line": 134,
          "content": "            ''', (user_id,))"
        },
        {
          "line": 137,
          "content": "        for row in cursor.fetchall():"
        },
        {
          "line": 142,
          "content": "        return results"
        },
        {
          "line": 145,
          "content": "def delete_user_data(user_id: int, result_id: str) -> bool:"
        },
        {
          "line": 146,
          "content": "    \"\"\"删除用户数据\"\"\""
        },
        {
          "line": 152,
          "content": "        ''', (user_id, result_id))"
        },
        {
          "line": 153,
          "content": "        return cursor.rowcount > 0"
        },
        {
          "line": 158,
          "content": "def save_verification_code(phone: str, code: str):"
        },
        {
          "line": 159,
          "content": "    \"\"\"保存验证码\"\"\""
        },
        {
          "line": 165,
          "content": "        ''', ("
        },
        {
          "line": 173,
          "content": "def verify_code(phone: str, code: str) -> bool:"
        },
        {
          "line": 174,
          "content": "    \"\"\"验证验证码\"\"\""
        },
        {
          "line": 180,
          "content": "        ''', (phone, code, datetime.now().isoformat()))"
        },
        {
          "line": 181,
          "content": "        return cursor.fetchone() is not None"
        },
        {
          "line": 186,
          "content": "def save_refresh_token(user_id: str, refresh_token: str):"
        },
        {
          "line": 187,
          "content": "    \"\"\"保存刷新令牌\"\"\""
        },
        {
          "line": 193,
          "content": "        ''', (user_id, refresh_token, datetime.now().isoformat()))"
        },
        {
          "line": 196,
          "content": "def verify_refresh_token(refresh_token: str) -> Optional[str]:"
        },
        {
          "line": 197,
          "content": "    \"\"\"验证刷新令牌\"\"\""
        },
        {
          "line": 203,
          "content": "        ''', (refresh_token,))"
        },
        {
          "line": 205,
          "content": "        return row['user_id'] if row else None"
        },
        {
          "line": 208,
          "content": "def revoke_refresh_token(refresh_token: str):"
        },
        {
          "line": 209,
          "content": "    \"\"\"撤销刷新令牌\"\"\""
        },
        {
          "line": 215,
          "content": "        ''', (refresh_token,))"
        },
        {
          "line": 218,
          "content": "def revoke_all_user_tokens(user_id: str):"
        },
        {
          "line": 219,
          "content": "    \"\"\"撤销用户所有令牌\"\"\""
        },
        {
          "line": 225,
          "content": "        ''', (user_id,))"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views_intelligence.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 29,
          "content": "    \"\"\""
        },
        {
          "line": 42,
          "content": "    \"\"\""
        },
        {
          "line": 102,
          "content": "    \"\"\""
        },
        {
          "line": 106,
          "content": "    \"\"\""
        },
        {
          "line": 119,
          "content": "        \"\"\"生成 SSE 事件流\"\"\""
        },
        {
          "line": 130,
          "content": "            while True:"
        },
        {
          "line": 132,
          "content": "                if time.time() - last_check > 300:  # 5 分钟超时"
        },
        {
          "line": 137,
          "content": "                if subscriber_queue:"
        },
        {
          "line": 152,
          "content": "            if execution_id in _pipeline_subscribers:"
        },
        {
          "line": 155,
          "content": "    return Response("
        },
        {
          "line": 168,
          "content": "def add_intelligence_item():"
        },
        {
          "line": 169,
          "content": "    \"\"\""
        },
        {
          "line": 184,
          "content": "    \"\"\""
        },
        {
          "line": 188,
          "content": "        if not data:"
        },
        {
          "line": 189,
          "content": "            return jsonify({"
        },
        {
          "line": 196,
          "content": "        if not execution_id:"
        },
        {
          "line": 197,
          "content": "            return jsonify({"
        },
        {
          "line": 219,
          "content": "        if execution_id not in _intelligence_cache:"
        },
        {
          "line": 227,
          "content": "        if execution_id in _pipeline_subscribers:"
        },
        {
          "line": 228,
          "content": "            for subscriber_queue in _pipeline_subscribers[execution_id]:"
        },
        {
          "line": 234,
          "content": "        return jsonify({"
        },
        {
          "line": 244,
          "content": "        return jsonify({"
        },
        {
          "line": 253,
          "content": "def update_intelligence_item():"
        },
        {
          "line": 254,
          "content": "    \"\"\""
        },
        {
          "line": 267,
          "content": "    \"\"\""
        },
        {
          "line": 275,
          "content": "        if not execution_id or not item_id or not new_status:"
        },
        {
          "line": 276,
          "content": "            return jsonify({"
        },
        {
          "line": 286,
          "content": "        for item in items:"
        },
        {
          "line": 287,
          "content": "            if item['id'] == item_id:"
        },
        {
          "line": 290,
          "content": "                if 'preview' in data:"
        },
        {
          "line": 292,
          "content": "                if 'error' in data:"
        },
        {
          "line": 294,
          "content": "                if 'latency' in data:"
        },
        {
          "line": 301,
          "content": "        if not updated:"
        },
        {
          "line": 302,
          "content": "            return jsonify({"
        },
        {
          "line": 309,
          "content": "        if execution_id in _pipeline_subscribers:"
        },
        {
          "line": 310,
          "content": "            for subscriber_queue in _pipeline_subscribers[execution_id]:"
        },
        {
          "line": 317,
          "content": "        return jsonify({"
        },
        {
          "line": 328,
          "content": "        return jsonify({"
        },
        {
          "line": 337,
          "content": "def clear_intelligence_pipeline():"
        },
        {
          "line": 338,
          "content": "    \"\"\""
        },
        {
          "line": 346,
          "content": "    \"\"\""
        },
        {
          "line": 351,
          "content": "        if not execution_id:"
        },
        {
          "line": 352,
          "content": "            return jsonify({"
        },
        {
          "line": 359,
          "content": "        if execution_id in _intelligence_cache:"
        },
        {
          "line": 367,
          "content": "        if execution_id in _pipeline_subscribers:"
        },
        {
          "line": 368,
          "content": "            for subscriber_queue in _pipeline_subscribers[execution_id]:"
        },
        {
          "line": 374,
          "content": "        return jsonify({"
        },
        {
          "line": 384,
          "content": "        return jsonify({"
        },
        {
          "line": 391,
          "content": "def _calculate_pipeline_stats(items: List[Dict[str, Any]]) -> Dict[str, Any]:"
        },
        {
          "line": 392,
          "content": "    \"\"\""
        },
        {
          "line": 394,
          "content": "    \"\"\""
        },
        {
          "line": 408,
          "content": "    for item in items:"
        },
        {
          "line": 411,
          "content": "        if status == 'success':"
        },
        {
          "line": 414,
          "content": "        elif status == 'processing':"
        },
        {
          "line": 416,
          "content": "        elif status == 'error':"
        },
        {
          "line": 419,
          "content": "        elif status == 'pending':"
        },
        {
          "line": 422,
          "content": "        if item.get('latency'):"
        },
        {
          "line": 425,
          "content": "    if completed_count > 0:"
        },
        {
          "line": 428,
          "content": "    if stats['successCount'] > 0:"
        },
        {
          "line": 431,
          "content": "    return stats"
        },
        {
          "line": 434,
          "content": "def _generate_mock_intelligence_data(brand_name: str, limit: int = 50) -> List[Dict[str, Any]]:"
        },
        {
          "line": 435,
          "content": "    \"\"\""
        },
        {
          "line": 437,
          "content": "    \"\"\""
        },
        {
          "line": 438,
          "content": "    import random"
        },
        {
          "line": 454,
          "content": "    for i in range(limit):"
        },
        {
          "line": 466,
          "content": "            'latency': random.randint(200, 2000) if status == 'success' else None,"
        },
        {
          "line": 467,
          "content": "            'preview': f'{model} 对{brand_name}的分析结果...' if status == 'success' else None,"
        },
        {
          "line": 468,
          "content": "            'error': '请求超时' if status == 'error' else None,"
        },
        {
          "line": 470,
          "content": "                'tokens_used': random.randint(100, 500) if status == 'success' else 0,"
        },
        {
          "line": 480,
          "content": "    return items"
        },
        {
          "line": 484,
          "content": "def register_blueprints(app):"
        },
        {
          "line": 485,
          "content": "    \"\"\"注册情报流水线 Blueprint\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views.py",
      "lines": [
        {
          "line": 62,
          "content": "# Global store for execution progress (in production, use Redis or database)"
        },
        {
          "line": 66,
          "content": "    \"\"\"Verify the signature from WeChat server\"\"\""
        },
        {
          "line": 72,
          "content": "    return calculated_signature == signature"
        },
        {
          "line": 75,
          "content": "def wechat_verify():"
        },
        {
          "line": 76,
          "content": "    \"\"\"Handle WeChat server verification\"\"\""
        },
        {
          "line": 112,
          "content": "    \"\"\"Handle login with WeChat Mini Program code\"\"\""
        },
        {
          "line": 113,
          "content": "    from wechat_backend.app import APP_ID, APP_SECRET"
        },
        {
          "line": 114,
          "content": "    from wechat_backend.security.auth import jwt_manager"
        },
        {
          "line": 117,
          "content": "    if not data:"
        },
        {
          "line": 118,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 121,
          "content": "    if not js_code or not InputValidator.validate_alphanumeric(js_code, min_length=1, max_length=50):"
        },
        {
          "line": 122,
          "content": "        return jsonify({'error': 'Valid code is required'}), 400"
        },
        {
          "line": 135,
          "content": "        if 'openid' in result:"
        },
        {
          "line": 144,
          "content": "            if jwt_manager:"
        },
        {
          "line": 152,
          "content": "                return jsonify({'error': 'Authentication service temporarily unavailable'}), 500"
        },
        {
          "line": 154,
          "content": "            return jsonify({"
        },
        {
          "line": 160,
          "content": "            api_logger.warning(f\"WeChat login failed for code: {js_code[:10]}...\")"
        },
        {
          "line": 161,
          "content": "            return jsonify({'error': 'Failed to login', 'details': result}), 400"
        },
        {
          "line": 164,
          "content": "        return jsonify({'error': 'Login service temporarily unavailable'}), 500"
        },
        {
          "line": 169,
          "content": "def test_api():"
        },
        {
          "line": 171,
          "content": "    if request.method == 'OPTIONS':"
        },
        {
          "line": 174,
          "content": "        return response, 200"
        },
        {
          "line": 175,
          "content": "    return jsonify({'message': 'Backend is working correctly!', 'status': 'success'})"
        },
        {
          "line": 184,
          "content": "import signal"
        },
        {
          "line": 186,
          "content": "def timeout_handler(signum, frame):"
        },
        {
          "line": 194,
          "content": "def mvp_deepseek_test():"
        },
        {
          "line": 195,
          "content": "    \"\"\""
        },
        {
          "line": 198,
          "content": "    \"\"\""
        },
        {
          "line": 201,
          "content": "    if not data:"
        },
        {
          "line": 202,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 209,
          "content": "        if not brand_list or not questions:"
        },
        {
          "line": 210,
          "content": "            return jsonify({'error': 'brand_list and customQuestions are required'}), 400"
        },
        {
          "line": 229,
          "content": "        api_logger.info(f\"[DeepSeek MVP] Starting brand test for {main_brand} with {len(questions)} questions\")"
        },
        {
          "line": 235,
          "content": "        if not api_key:"
        },
        {
          "line": 242,
          "content": "        for idx, question in enumerate(questions):"
        },
        {
          "line": 254,
          "content": "                if len(brand_list) > 1:"
        },
        {
          "line": 267,
          "content": "                from utils.ai_response_logger_v3 import log_ai_response"
        },
        {
          "line": 269,
          "content": "                if ai_response.success:"
        },
        {
          "line": 289,
          "content": "                            competitor=brand_list[1] if len(brand_list) > 1 else None,"
        },
        {
          "line": 309,
          "content": "                                'response_length': len(ai_response.content) if ai_response.content else 0"
        },
        {
          "line": 354,
          "content": "                    'question': actual_question if 'actual_question' in locals() else question,"
        },
        {
          "line": 371,
          "content": "        api_logger.info(f\"[DeepSeek MVP] Test completed for {main_brand}, {len([r for r in results if r.get('success')])}/{len(results)} successful\")"
        },
        {
          "line": 373,
          "content": "        return jsonify({"
        },
        {
          "line": 382,
          "content": "        return jsonify({'error': f'Test failed: {str(e)}'}), 500"
        },
        {
          "line": 389,
          "content": "def mvp_qwen_test():"
        },
        {
          "line": 390,
          "content": "    \"\"\""
        },
        {
          "line": 393,
          "content": "    \"\"\""
        },
        {
          "line": 396,
          "content": "    if not data:"
        },
        {
          "line": 397,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 404,
          "content": "        if not brand_list or not questions:"
        },
        {
          "line": 405,
          "content": "            return jsonify({'error': 'brand_list and customQuestions are required'}), 400"
        },
        {
          "line": 424,
          "content": "        api_logger.info(f\"[Qwen MVP] Starting brand test for {main_brand} with {len(questions)} questions\")"
        },
        {
          "line": 430,
          "content": "        if not api_key:"
        },
        {
          "line": 437,
          "content": "        for idx, question in enumerate(questions):"
        },
        {
          "line": 449,
          "content": "                if len(brand_list) > 1:"
        },
        {
          "line": 462,
          "content": "                from utils.ai_response_logger_v3 import log_ai_response"
        },
        {
          "line": 464,
          "content": "                if ai_response.success:"
        },
        {
          "line": 484,
          "content": "                            competitor=brand_list[1] if len(brand_list) > 1 else None,"
        },
        {
          "line": 504,
          "content": "                                'response_length': len(ai_response.content) if ai_response.content else 0"
        },
        {
          "line": 549,
          "content": "                    'question': actual_question if 'actual_question' in locals() else question,"
        },
        {
          "line": 566,
          "content": "        api_logger.info(f\"[Qwen MVP] Test completed for {main_brand}, {len([r for r in results if r.get('success')])}/{len(results)} successful\")"
        },
        {
          "line": 568,
          "content": "        return jsonify({"
        },
        {
          "line": 577,
          "content": "        return jsonify({'error': f'Test failed: {str(e)}'}), 500"
        },
        {
          "line": 584,
          "content": "def mvp_zhipu_test():"
        },
        {
          "line": 585,
          "content": "    \"\"\""
        },
        {
          "line": 588,
          "content": "    \"\"\""
        },
        {
          "line": 591,
          "content": "    if not data:"
        },
        {
          "line": 592,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 599,
          "content": "        if not brand_list or not questions:"
        },
        {
          "line": 600,
          "content": "            return jsonify({'error': 'brand_list and customQuestions are required'}), 400"
        },
        {
          "line": 619,
          "content": "        api_logger.info(f\"[Zhipu MVP] Starting brand test for {main_brand} with {len(questions)} questions\")"
        },
        {
          "line": 625,
          "content": "        if not api_key:"
        },
        {
          "line": 632,
          "content": "        for idx, question in enumerate(questions):"
        },
        {
          "line": 644,
          "content": "                if len(brand_list) > 1:"
        },
        {
          "line": 657,
          "content": "                from utils.ai_response_logger_v3 import log_ai_response"
        },
        {
          "line": 659,
          "content": "                if ai_response.success:"
        },
        {
          "line": 679,
          "content": "                            competitor=brand_list[1] if len(brand_list) > 1 else None,"
        },
        {
          "line": 699,
          "content": "                                'response_length': len(ai_response.content) if ai_response.content else 0"
        },
        {
          "line": 744,
          "content": "                    'question': actual_question if 'actual_question' in locals() else question,"
        },
        {
          "line": 761,
          "content": "        api_logger.info(f\"[Zhipu MVP] Test completed for {main_brand}, {len([r for r in results if r.get('success')])}/{len(results)} successful\")"
        },
        {
          "line": 763,
          "content": "        return jsonify({"
        },
        {
          "line": 772,
          "content": "        return jsonify({'error': f'Test failed: {str(e)}'}), 500"
        },
        {
          "line": 779,
          "content": "def mvp_brand_test():"
        },
        {
          "line": 780,
          "content": "    \"\"\""
        },
        {
          "line": 783,
          "content": "    \"\"\""
        },
        {
          "line": 786,
          "content": "    if not data:"
        },
        {
          "line": 787,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 794,
          "content": "        if not brand_list or not questions:"
        },
        {
          "line": 795,
          "content": "            return jsonify({'error': 'brand_list and customQuestions are required'}), 400"
        },
        {
          "line": 813,
          "content": "        api_logger.info(f\"[MVP] Starting brand test for {main_brand} with {len(questions)} questions\")"
        },
        {
          "line": 817,
          "content": "        for idx, question in enumerate(questions):"
        },
        {
          "line": 829,
          "content": "                if len(brand_list) > 1:"
        },
        {
          "line": 835,
          "content": "                from wechat_backend.ai_adapters.factory import AIAdapterFactory"
        },
        {
          "line": 836,
          "content": "                from wechat_backend.ai_adapters.base_adapter import AIPlatformType"
        },
        {
          "line": 839,
          "content": "                from wechat_backend.config_manager import config_manager"
        },
        {
          "line": 842,
          "content": "                import os"
        },
        {
          "line": 847,
          "content": "                if not api_key:"
        },
        {
          "line": 858,
          "content": "                from utils.ai_response_logger_v3 import log_ai_response"
        },
        {
          "line": 860,
          "content": "                if ai_response.success:"
        },
        {
          "line": 883,
          "content": "                            competitor=brand_list[1] if len(brand_list) > 1 else None,"
        },
        {
          "line": 915,
          "content": "                                'response_length': len(ai_response.content) if ai_response.content else 0"
        },
        {
          "line": 961,
          "content": "                    'question': actual_question if 'actual_question' in locals() else question,"
        },
        {
          "line": 978,
          "content": "        api_logger.info(f\"[MVP] Test completed for {main_brand}, {len([r for r in results if r.get('success')])}/{len(results)} successful\")"
        },
        {
          "line": 980,
          "content": "        return jsonify({"
        },
        {
          "line": 989,
          "content": "        return jsonify({'error': f'Test failed: {str(e)}'}), 500"
        },
        {
          "line": 991,
          "content": "def process_and_aggregate_results_with_ai_judge(raw_results, all_brands, main_brand, judge_platform=None, judge_model=None, judge_api_key=None):"
        },
        {
          "line": 992,
          "content": "    \"\"\""
        },
        {
          "line": 994,
          "content": "    \"\"\""
        },
        {
          "line": 1000,
          "content": "        signal.alarm(120)  # 2-minute timeout for the entire function"
        },
        {
          "line": 1001,
          "content": "        # Only create AIJudgeClient if judge parameters are provided"
        },
        {
          "line": 1003,
          "content": "        if judge_platform and judge_model and judge_api_key:"
        },
        {
          "line": 1006,
          "content": "            # Check if any judge parameters are provided (even partially)"
        },
        {
          "line": 1007,
          "content": "            if judge_platform or judge_model or judge_api_key:"
        },
        {
          "line": 1016,
          "content": "            from .intelligence_services.misunderstanding_analyzer import MisunderstandingAnalyzer"
        },
        {
          "line": 1033,
          "content": "        if isinstance(raw_results, dict) and 'tasks_results' in raw_results:"
        },
        {
          "line": 1036,
          "content": "        elif isinstance(raw_results, dict) and 'results' in raw_results:"
        },
        {
          "line": 1039,
          "content": "        elif isinstance(raw_results, list):"
        },
        {
          "line": 1046,
          "content": "        for result in actual_results:"
        },
        {
          "line": 1049,
          "content": "                if isinstance(result, dict):"
        },
        {
          "line": 1054,
          "content": "                    if result.get('success', False):"
        },
        {
          "line": 1057,
          "content": "                        if 'result' in result and isinstance(result['result'], dict):"
        },
        {
          "line": 1059,
          "content": "                        elif 'response' in result:"
        },
        {
          "line": 1061,
          "content": "                        elif 'content' in result:"
        },
        {
          "line": 1065,
          "content": "                        if not ai_response_content:"
        },
        {
          "line": 1070,
          "content": "                        # Only evaluate with AI judge if it's available"
        },
        {
          "line": 1071,
          "content": "                        if ai_judge:"
        },
        {
          "line": 1072,
          "content": "                            # Add timeout protection for individual AI judge calls"
        },
        {
          "line": 1074,
          "content": "                                # Temporarily disable the global alarm for this call"
        },
        {
          "line": 1077,
          "content": "                                # Set a shorter timeout for individual evaluations"
        },
        {
          "line": 1079,
          "content": "                                signal.alarm(30)  # 30-second timeout for individual evaluation"
        },
        {
          "line": 1086,
          "content": "                                signal.alarm(120)  # Resume the 2-minute timeout for the whole function"
        },
        {
          "line": 1091,
          "content": "                                signal.alarm(120)  # Resume the 2-minute timeout for the whole function"
        },
        {
          "line": 1093,
          "content": "                                api_logger.error(f\"AI judge evaluation timed out for brand {current_brand}\")"
        },
        {
          "line": 1099,
          "content": "                                signal.alarm(120)  # Resume the 2-minute timeout for the whole function"
        },
        {
          "line": 1101,
          "content": "                                api_logger.error(f\"AI judge evaluation failed for brand {current_brand}: {str(e)}\")"
        },
        {
          "line": 1104,
          "content": "                            if judge_result:"
        },
        {
          "line": 1114,
          "content": "                                    from gco_validator.scoring import ResponseEvaluator"
        },
        {
          "line": 1121,
          "content": "                                    api_logger.error(f\"Evaluation failed for {current_brand}: {str(eval_error)}\")"
        },
        {
          "line": 1127,
          "content": "                                if misunderstanding_analyzer:"
        },
        {
          "line": 1135,
          "content": "                                        api_logger.info(f\"Misunderstanding analysis completed for {current_brand}: {misunderstanding_result.has_issue}\")"
        },
        {
          "line": 1143,
          "content": "                                if not isinstance(authority_score, (int, float)):"
        },
        {
          "line": 1147,
          "content": "                                if not isinstance(visibility_score, (int, float)):"
        },
        {
          "line": 1151,
          "content": "                                if not isinstance(sentiment_score, (int, float)):"
        },
        {
          "line": 1155,
          "content": "                                if not isinstance(purity_score, (int, float)):"
        },
        {
          "line": 1159,
          "content": "                                if not isinstance(consistency_score, (int, float)):"
        },
        {
          "line": 1163,
          "content": "                                if not isinstance(score, (int, float)):"
        },
        {
          "line": 1180,
          "content": "                                        'accuracy_score': scoring_result.accuracy if scoring_result and isinstance(scoring_result.accuracy, (int, float)) else 0,"
        },
        {
          "line": 1181,
          "content": "                                        'completeness_score': scoring_result.completeness if scoring_result and isinstance(scoring_result.completeness, (int, float)) else 0,"
        },
        {
          "line": 1182,
          "content": "                                        'relevance_score': scoring_result.relevance if scoring_result and isinstance(scoring_result.relevance, (int, float)) else 0,"
        },
        {
          "line": 1183,
          "content": "                                        'coherence_score': scoring_result.coherence if scoring_result and isinstance(scoring_result.coherence, (int, float)) else 0,"
        },
        {
          "line": 1184,
          "content": "                                        'overall_quality_score': scoring_result.overall_score if scoring_result and isinstance(scoring_result.overall_score, (int, float)) else 0,"
        },
        {
          "line": 1185,
          "content": "                                        'detailed_feedback': scoring_result.detailed_feedback if scoring_result else {}"
        },
        {
          "line": 1186,
          "content": "                                    } if scoring_result else None,"
        },
        {
          "line": 1200,
          "content": "                                    } if misunderstanding_result else None,"
        },
        {
          "line": 1201,
          "content": "                                    'category': '国内' if result.get('model', result.get('ai_model', '')) in ['通义千问', '文心一言', '豆包', 'Kimi', '元宝', 'DeepSeek', '讯飞星火'] else '海外'"
        },
        {
          "line": 1219,
          "content": "                                from gco_validator.scoring import ResponseEvaluator"
        },
        {
          "line": 1226,
          "content": "                                api_logger.error(f\"Evaluation failed for {current_brand}: {str(eval_error)}\")"
        },
        {
          "line": 1231,
          "content": "                            authority_score = scoring_result.accuracy if scoring_result and isinstance(scoring_result.accuracy, (int, float)) else 0"
        },
        {
          "line": 1232,
          "content": "                            visibility_score = scoring_result.completeness if scoring_result and isinstance(scoring_result.completeness, (int, float)) else 0"
        },
        {
          "line": 1234,
          "content": "                            sentiment_score = scoring_result.relevance if scoring_result and isinstance(scoring_result.relevance, (int, float)) else 50"
        },
        {
          "line": 1236,
          "content": "                            purity_score = scoring_result.coherence if scoring_result and isinstance(scoring_result.coherence, (int, float)) else 0"
        },
        {
          "line": 1237,
          "content": "                            consistency_score = scoring_result.coherence if scoring_result and isinstance(scoring_result.coherence, (int, float)) else 0"
        },
        {
          "line": 1238,
          "content": "                            score = scoring_result.overall_score if scoring_result and isinstance(scoring_result.overall_score, (int, float)) else 0"
        },
        {
          "line": 1254,
          "content": "                                    'accuracy_score': scoring_result.accuracy if scoring_result and isinstance(scoring_result.accuracy, (int, float)) else 0,"
        },
        {
          "line": 1255,
          "content": "                                    'completeness_score': scoring_result.completeness if scoring_result and isinstance(scoring_result.completeness, (int, float)) else 0,"
        },
        {
          "line": 1256,
          "content": "                                    'relevance_score': scoring_result.relevance if scoring_result and isinstance(scoring_result.relevance, (int, float)) else 0,"
        },
        {
          "line": 1257,
          "content": "                                    'coherence_score': scoring_result.coherence if scoring_result and isinstance(scoring_result.coherence, (int, float)) else 0,"
        },
        {
          "line": 1258,
          "content": "                                    'overall_quality_score': scoring_result.overall_score if scoring_result and isinstance(scoring_result.overall_score, (int, float)) else 0,"
        },
        {
          "line": 1259,
          "content": "                                    'detailed_feedback': scoring_result.detailed_feedback if scoring_result else {}"
        },
        {
          "line": 1260,
          "content": "                                } if scoring_result else None,"
        },
        {
          "line": 1269,
          "content": "                                'category': '国内' if result.get('model', result.get('ai_model', '')) in ['通义千问', '文心一言', '豆包', 'Kimi', '元宝', 'DeepSeek', '讯飞星火'] else '海外'"
        },
        {
          "line": 1271,
          "content": "                            # Add a basic judge result with scores from evaluator for scoring calculations"
        },
        {
          "line": 1307,
          "content": "                    'brand': result.get('brand_name', result.get('brand', 'unknown')) if isinstance(result, dict) else 'unknown',"
        },
        {
          "line": 1308,
          "content": "                    'aiModel': result.get('model', result.get('ai_model', 'unknown')) if isinstance(result, dict) else 'unknown',"
        },
        {
          "line": 1309,
          "content": "                    'question': result.get('question', result.get('original_question', '')) if isinstance(result, dict) else 'unknown',"
        },
        {
          "line": 1323,
          "content": "                    'brand': result.get('brand_name', result.get('brand', 'unknown')) if isinstance(result, dict) else 'unknown',"
        },
        {
          "line": 1324,
          "content": "                    'aiModel': result.get('model', result.get('ai_model', 'unknown')) if isinstance(result, dict) else 'unknown',"
        },
        {
          "line": 1325,
          "content": "                    'question': result.get('question', result.get('original_question', '')) if isinstance(result, dict) else 'unknown',"
        },
        {
          "line": 1335,
          "content": "        for brand, judge_results in brand_results_map.items():"
        },
        {
          "line": 1336,
          "content": "            if judge_results and len(judge_results) > 0:  # 确保列表非空"
        },
        {
          "line": 1363,
          "content": "                    api_logger.error(f\"Scoring calculation failed for brand {brand}: {str(e)}\")"
        },
        {
          "line": 1398,
          "content": "        first_mention_by_platform = {platform: interception_analyst.calculate_first_mention_rate(results) for platform, results in platform_results_map.items()}"
        },
        {
          "line": 1401,
          "content": "        competitor_sources = {brand: generate_mock_source_intelligence_map(brand) for brand in all_brands if brand != main_brand}"
        },
        {
          "line": 1435,
          "content": "            'semantic_drift_data': semantic_drift_data if 'semantic_drift_data' in dir() else None,"
        },
        {
          "line": 1436,
          "content": "            'semantic_contrast_data': semantic_contrast_data if 'semantic_contrast_data' in dir() else None,"
        },
        {
          "line": 1437,
          "content": "            'recommendation_data': recommendation_data if 'recommendation_data' in dir() else None,"
        },
        {
          "line": 1438,
          "content": "            'negative_sources': negative_sources if 'negative_sources' in dir() else None"
        },
        {
          "line": 1443,
          "content": "        if old_handler:"
        },
        {
          "line": 1445,
          "content": "        return final_result"
        },
        {
          "line": 1452,
          "content": "        if old_handler:"
        },
        {
          "line": 1457,
          "content": "        for brand in all_brands:"
        },
        {
          "line": 1490,
          "content": "        for brand in all_brands:"
        },
        {
          "line": 1529,
          "content": "        # Print JSON sample for verification"
        },
        {
          "line": 1530,
          "content": "        import json"
        },
        {
          "line": 1535,
          "content": "        return timeout_result"
        },
        {
          "line": 1539,
          "content": "        if old_handler:"
        },
        {
          "line": 1547,
          "content": "        for brand in all_brands:"
        },
        {
          "line": 1580,
          "content": "        for brand in all_brands:"
        },
        {
          "line": 1619,
          "content": "        # Print JSON sample for verification"
        },
        {
          "line": 1620,
          "content": "        import json"
        },
        {
          "line": 1625,
          "content": "        return default_result"
        },
        {
          "line": 1628,
          "content": "def convert_to_dashboard_format(aggregate_result, all_brands, main_brand):"
        },
        {
          "line": 1629,
          "content": "    \"\"\""
        },
        {
          "line": 1639,
          "content": "    \"\"\""
        },
        {
          "line": 1645,
          "content": "            from wechat_backend.analytics.source_aggregator import SourceAggregator"
        },
        {
          "line": 1649,
          "content": "            for result in detailed_results:"
        },
        {
          "line": 1663,
          "content": "            for source in source_data.get('source_pool', []):"
        },
        {
          "line": 1672,
          "content": "                if domain_authority == 'Low' or (citation_count > 2 and model_coverage == 1):"
        },
        {
          "line": 1676,
          "content": "                        'model': list(model_coverage)[0] if isinstance(model_coverage, set) else 'multiple',"
        },
        {
          "line": 1688,
          "content": "            from wechat_backend.analytics.rank_analyzer import RankAnalyzer"
        },
        {
          "line": 1692,
          "content": "            for result in detailed_results:"
        },
        {
          "line": 1694,
          "content": "                if question not in question_map:"
        },
        {
          "line": 1705,
          "content": "            for question_text, q_data in question_map.items():"
        },
        {
          "line": 1712,
          "content": "                combined_response = ' '.join([r.get('response', '') for r in results])"
        },
        {
          "line": 1719,
          "content": "                brand_rank = ranking_list.index(main_brand) + 1 if main_brand in ranking_list else -1"
        },
        {
          "line": 1722,
          "content": "                ranked_results = [r for r in results if r.get('enhanced_scores', {}).get('geo_score', 0) > 0]"
        },
        {
          "line": 1723,
          "content": "                if ranked_results:"
        },
        {
          "line": 1724,
          "content": "                    geo_avg_rank = sum(r['enhanced_scores']['geo_score'] for r in ranked_results) / len(ranked_results)"
        },
        {
          "line": 1728,
          "content": "                    if brand_rank > 0:"
        },
        {
          "line": 1733,
          "content": "                    avg_rank = brand_rank if brand_rank > 0 else '未入榜'"
        },
        {
          "line": 1736,
          "content": "                sentiments = [r.get('sentiment_score', 0) for r in results if r.get('sentiment_score', 0) != 0]"
        },
        {
          "line": 1737,
          "content": "                avg_sentiment = round(sum(sentiments) / len(sentiments), 2) if sentiments else '0.00'"
        },
        {
          "line": 1741,
          "content": "                for result in results:"
        },
        {
          "line": 1743,
          "content": "                    if interception:"
        },
        {
          "line": 1751,
          "content": "                    'avgRank': str(avg_rank) if isinstance(avg_rank, float) else avg_rank,"
        },
        {
          "line": 1755,
          "content": "                    'status': 'risk' if has_risk else 'safe',"
        },
        {
          "line": 1764,
          "content": "            for result in detailed_results:"
        },
        {
          "line": 1766,
          "content": "                if question not in question_map:"
        },
        {
          "line": 1771,
          "content": "            for question_text, q_data in question_map.items():"
        },
        {
          "line": 1773,
          "content": "                ranked_results = [r for r in results if r.get('enhanced_scores', {}).get('geo_score', 0) > 0]"
        },
        {
          "line": 1774,
          "content": "                if ranked_results:"
        },
        {
          "line": 1775,
          "content": "                    avg_rank = sum(r['enhanced_scores']['geo_score'] for r in ranked_results) / len(ranked_results)"
        },
        {
          "line": 1780,
          "content": "                sentiments = [r.get('sentiment_score', 0) for r in results if r.get('sentiment_score', 0) != 0]"
        },
        {
          "line": 1781,
          "content": "                avg_sentiment = round(sum(sentiments) / len(sentiments), 2) if sentiments else '0.00'"
        },
        {
          "line": 1783,
          "content": "                intercepted_by = [r.get('interceptedBy', '') for r in results if r.get('interceptedBy', '')]"
        },
        {
          "line": 1788,
          "content": "                    'avgRank': str(avg_rank) if isinstance(avg_rank, float) else avg_rank,"
        },
        {
          "line": 1792,
          "content": "                    'status': 'risk' if has_risk else 'safe',"
        },
        {
          "line": 1797,
          "content": "        safe_questions = [q for q in question_cards if q['status'] == 'safe']"
        },
        {
          "line": 1798,
          "content": "        health_score = round((len(safe_questions) / len(question_cards)) * 100) if question_cards else 0"
        },
        {
          "line": 1802,
          "content": "        main_brand_mentions = len([r for r in detailed_results if r.get('brand') == main_brand])"
        },
        {
          "line": 1803,
          "content": "        sov = round((main_brand_mentions / total_mentions) * 100) if total_mentions > 0 else 0"
        },
        {
          "line": 1806,
          "content": "        all_sentiments = [r.get('sentiment_score', 0) for r in detailed_results if r.get('sentiment_score', 0) != 0]"
        },
        {
          "line": 1807,
          "content": "        avg_sentiment = round(sum(all_sentiments) / len(all_sentiments), 2) if all_sentiments else '0.00'"
        },
        {
          "line": 1822,
          "content": "        return dashboard_data"
        },
        {
          "line": 1827,
          "content": "        return {"
        },
        {
          "line": 1841,
          "content": "def generate_mock_source_intelligence_map(brand_name):"
        },
        {
          "line": 1842,
          "content": "    # This function is now replaced by the real processor, but we keep it for other potential uses"
        },
        {
          "line": 1847,
          "content": "    for source in selected_sources:"
        },
        {
          "line": 1851,
          "content": "        links.append({'source': 'brand', 'target': source['name'], 'contribution_score': weight / 10, 'sentiment_bias': (1 if sentiment == 'positive' else (-1 if sentiment == 'negative' else 0)) * random.random()})"
        },
        {
          "line": 1852,
          "content": "    if random.random() < 0.3:"
        },
        {
          "line": 1856,
          "content": "    return {'nodes': nodes, 'links': links}"
        },
        {
          "line": 1858,
          "content": "def generate_mock_semantic_contrast_data(brand_name):"
        },
        {
          "line": 1859,
          "content": "    # ... (This function remains the same)"
        },
        {
          "line": 1862,
          "content": "    return {'official_words': official_words, 'ai_generated_words': ai_generated_words}"
        },
        {
          "line": 1865,
          "content": "def get_source_intelligence():"
        },
        {
          "line": 1868,
          "content": "    return jsonify({'status': 'success', 'data': data})"
        },
        {
          "line": 1875,
          "content": "def get_platform_status():"
        },
        {
          "line": 1876,
          "content": "    \"\"\"获取所有AI平台的状态信息\"\"\""
        },
        {
          "line": 1928,
          "content": "    \"\"\""
        },
        {
          "line": 1934,
          "content": "    \"\"\""
        },
        {
          "line": 1979,
          "content": "    \"\"\""
        },
        {
          "line": 1990,
          "content": "    \"\"\""
        },
        {
          "line": 2009,
          "content": "    \"\"\"提交品牌AI诊断任务\"\"\""
        },
        {
          "line": 2014,
          "content": "    if not data:"
        },
        {
          "line": 2015,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 2020,
          "content": "        if not brand_list:"
        },
        {
          "line": 2021,
          "content": "            return jsonify({'error': 'brand_list is required'}), 400"
        },
        {
          "line": 2023,
          "content": "        for brand in brand_list:"
        },
        {
          "line": 2024,
          "content": "            if not validate_safe_text(brand, max_length=100):"
        },
        {
          "line": 2025,
          "content": "                return jsonify({'error': f'Invalid brand name: {brand}'}), 400"
        },
        {
          "line": 2030,
          "content": "        if not selected_models:"
        },
        {
          "line": 2031,
          "content": "            return jsonify({'error': 'At least one AI model must be selected'}), 400"
        },
        {
          "line": 2033,
          "content": "        for question in custom_questions:"
        },
        {
          "line": 2034,
          "content": "            if not validate_safe_text(question, max_length=500):"
        },
        {
          "line": 2035,
          "content": "                return jsonify({'error': f'Unsafe question content: {question}'}), 400"
        },
        {
          "line": 2039,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 2054,
          "content": "    def run_async_test():"
        },
        {
          "line": 2062,
          "content": "            cleaned_custom_questions_for_validation = [q.strip() for q in custom_questions if q.strip()]"
        },
        {
          "line": 2064,
          "content": "            if cleaned_custom_questions_for_validation:"
        },
        {
          "line": 2066,
          "content": "                if not validation_result['valid']:"
        },
        {
          "line": 2078,
          "content": "            for brand in brand_list:"
        },
        {
          "line": 2079,
          "content": "                brand_questions = [q.replace('{brandName}', brand) for q in raw_questions]"
        },
        {
          "line": 2083,
          "content": "            api_logger.info(f\"Starting async brand test '{task_id}' for brands: {brand_list} - Total test cases: {len(all_test_cases)}\")"
        },
        {
          "line": 2088,
          "content": "            api_logger.info(f\"[ExecutionStrategy] Using forced SEQUENTIAL execution with max_workers=1 for stability\")"
        },
        {
          "line": 2090,
          "content": "            def progress_callback(exec_id, progress):"
        },
        {
          "line": 2092,
          "content": "                calculated_progress = int((progress.completed_tests / progress.total_tests) * 100) if progress.total_tests > 0 else 0"
        },
        {
          "line": 2117,
          "content": "                def run_async_processing():"
        },
        {
          "line": 2121,
          "content": "                        return loop.run_until_complete("
        },
        {
          "line": 2140,
          "content": "            if 'detailed_results' in processed_results and processed_results['detailed_results']:"
        },
        {
          "line": 2143,
          "content": "                for result in processed_results['detailed_results']:"
        },
        {
          "line": 2146,
          "content": "                    if brand not in brand_responses:"
        },
        {
          "line": 2152,
          "content": "                ranking_list = [item[0] for item in sorted_brands]"
        },
        {
          "line": 2156,
          "content": "                for brand, char_count in sorted_brands:"
        },
        {
          "line": 2160,
          "content": "                        'sov_share': round(char_count / total_chars, 4) if total_chars > 0 else 0,"
        },
        {
          "line": 2167,
          "content": "            all_responses = \" \".join([result.get('response', '') for result in processed_results['detailed_results']])"
        },
        {
          "line": 2170,
          "content": "            for competitor in possible_competitors:"
        },
        {
          "line": 2171,
          "content": "                if competitor in all_responses and competitor not in brand_list:"
        },
        {
          "line": 2172,
          "content": "                    if competitor not in unlisted_competitors:"
        },
        {
          "line": 2180,
          "content": "            if source_intelligence_map and 'nodes' in source_intelligence_map:"
        },
        {
          "line": 2181,
          "content": "                for node in source_intelligence_map.get('nodes', []):"
        },
        {
          "line": 2182,
          "content": "                    if node.get('category') in ['social', 'wiki', 'tech', 'news', 'official']:"
        },
        {
          "line": 2189,
          "content": "                            'domain_authority': 'High' if node.get('value', 0) > 5 else 'Medium' if node.get('value', 0) > 2 else 'Low'"
        },
        {
          "line": 2197,
          "content": "            for result in processed_results['detailed_results']:"
        },
        {
          "line": 2201,
          "content": "                for indicator in negative_indicators:"
        },
        {
          "line": 2202,
          "content": "                    if indicator in response:"
        },
        {
          "line": 2204,
          "content": "                            'negative_fragment': response[:100] + '...' if len(response) > 100 else response,"
        },
        {
          "line": 2226,
          "content": "            from wechat_backend.models import DeepIntelligenceResult, BrandTestResult, save_brand_test_result"
        },
        {
          "line": 2261,
          "content": "    return jsonify({"
        },
        {
          "line": 2270,
          "content": "def get_task_status_api(task_id):"
        },
        {
          "line": 2271,
          "content": "    \"\"\"轮询任务进度与分阶段状态\"\"\""
        },
        {
          "line": 2331,
          "content": "                                   \"\"\", (task_id,))"
        },
        {
          "line": 2335,
          "content": "                    if db_row:"
        },
        {
          "line": 2338,
          "content": "                            if summary_comp and summary_raw:"
        },
        {
          "line": 2340,
          "content": "                            elif summary_raw:"
        },
        {
          "line": 2371,
          "content": "                    if cursor:"
        },
        {
          "line": 2373,
          "content": "                    if conn:"
        },
        {
          "line": 2379,
          "content": "                if response_data['status'] == 'completed' and response_data['stage'] != 'completed':"
        },
        {
          "line": 2382,
          "content": "                return jsonify(response_data), 200"
        },
        {
          "line": 2386,
          "content": "                return jsonify({'error': 'Task not found', 'suggestion': 'Please check execution ID or start a new diagnosis'}), 404"
        },
        {
          "line": 2388,
          "content": "            api_logger.error(f\"[TaskStatus] Error querying database for task {task_id}: {e}\", exc_info=True)"
        },
        {
          "line": 2390,
          "content": "            return jsonify({"
        },
        {
          "line": 2400,
          "content": "def get_task_result(task_id):"
        },
        {
          "line": 2401,
          "content": "    \"\"\"获取诊断任务的完整情报深度结果\"\"\""
        },
        {
          "line": 2443,
          "content": "    \"\"\""
        },
        {
          "line": 2478,
          "content": "    \"\"\""
        },
        {
          "line": 2568,
          "content": "    \"\"\""
        },
        {
          "line": 2577,
          "content": "    \"\"\""
        },
        {
          "line": 2678,
          "content": "    \"\"\"获取干预行动建议\"\"\""
        },
        {
          "line": 2683,
          "content": "    if not data:"
        },
        {
          "line": 2684,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 2692,
          "content": "        if not isinstance(source_intelligence, dict):"
        },
        {
          "line": 2693,
          "content": "            return jsonify({'error': 'source_intelligence must be a dictionary'}), 400"
        },
        {
          "line": 2695,
          "content": "        if not isinstance(evidence_chain, list):"
        },
        {
          "line": 2696,
          "content": "            return jsonify({'error': 'evidence_chain must be a list'}), 400"
        },
        {
          "line": 2700,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 2715,
          "content": "        for rec in recommendations:"
        },
        {
          "line": 2727,
          "content": "        return jsonify({"
        },
        {
          "line": 2735,
          "content": "        return jsonify({'error': 'Failed to generate recommendations', 'details': str(e)}), 500"
        },
        {
          "line": 2746,
          "content": "def configure_cruise_task():"
        },
        {
          "line": 2747,
          "content": "    \"\"\"配置定时诊断任务\"\"\""
        },
        {
          "line": 2806,
          "content": "    \"\"\"取消定时诊断任务\"\"\""
        },
        {
          "line": 2811,
          "content": "    if not data:"
        },
        {
          "line": 2812,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 2816,
          "content": "        if not job_id:"
        },
        {
          "line": 2817,
          "content": "            return jsonify({'error': 'job_id is required'}), 400"
        },
        {
          "line": 2821,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 2827,
          "content": "        return jsonify({"
        },
        {
          "line": 2835,
          "content": "        return jsonify({'error': 'Failed to cancel cruise task', 'details': str(e)}), 500"
        },
        {
          "line": 2842,
          "content": "def get_cruise_tasks():"
        },
        {
          "line": 2843,
          "content": "    \"\"\"获取所有已调度的巡航任务\"\"\""
        },
        {
          "line": 2867,
          "content": "    \"\"\"获取趋势数据\"\"\""
        },
        {
          "line": 2876,
          "content": "        if not brand_name:"
        },
        {
          "line": 2877,
          "content": "            return jsonify({'error': 'brand_name is required'}), 400"
        },
        {
          "line": 2879,
          "content": "        if days <= 0 or days > 365:"
        },
        {
          "line": 2880,
          "content": "            return jsonify({'error': 'days must be between 1 and 365'}), 400"
        },
        {
          "line": 2884,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 2890,
          "content": "        return jsonify({"
        },
        {
          "line": 2900,
          "content": "        return jsonify({'error': 'Failed to retrieve trend data', 'details': str(e)}), 500"
        },
        {
          "line": 2911,
          "content": "def get_market_benchmark():"
        },
        {
          "line": 2912,
          "content": "    \"\"\"获取市场基准对比数据\"\"\""
        },
        {
          "line": 2964,
          "content": "    \"\"\"获取品牌认知趋势预测和风险因素\"\"\""
        },
        {
          "line": 2974,
          "content": "        if not brand_name:"
        },
        {
          "line": 2975,
          "content": "            return jsonify({'error': 'brand_name is required'}), 400"
        },
        {
          "line": 2977,
          "content": "        if days <= 0 or days > 30:"
        },
        {
          "line": 2978,
          "content": "            return jsonify({'error': 'days must be between 1 and 30'}), 400"
        },
        {
          "line": 2980,
          "content": "        if history_days <= 0 or history_days > 365:"
        },
        {
          "line": 2981,
          "content": "            return jsonify({'error': 'history_days must be between 1 and 365'}), 400"
        },
        {
          "line": 2984,
          "content": "        if not sql_protector.validate_input(brand_name):"
        },
        {
          "line": 2985,
          "content": "            return jsonify({'error': 'Invalid brand_name'}), 400"
        },
        {
          "line": 2989,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 2995,
          "content": "        if not trend_data:"
        },
        {
          "line": 2996,
          "content": "            return jsonify({"
        },
        {
          "line": 2998,
          "content": "                'message': 'No historical data available for prediction',"
        },
        {
          "line": 3004,
          "content": "        from wechat_backend.analytics.prediction_engine import PredictionEngine"
        },
        {
          "line": 3009,
          "content": "        for data_point in trend_data:"
        },
        {
          "line": 3022,
          "content": "        for data_point in trend_data[-7:]:  # 使用最近7天的数据"
        },
        {
          "line": 3023,
          "content": "            if data_point.get('overall_score', 100) < 60:  # 假设分数低于60表示有问题"
        },
        {
          "line": 3032,
          "content": "        for entry in historical_data:"
        },
        {
          "line": 3033,
          "content": "            entry['evidence_chain'] = evidence_chain if entry['overall_score'] and entry['overall_score'] < 60 else []"
        },
        {
          "line": 3038,
          "content": "        return jsonify({"
        },
        {
          "line": 3047,
          "content": "        return jsonify({'error': 'Failed to generate prediction forecast', 'details': str(e)}), 500"
        },
        {
          "line": 3051,
          "content": "from wechat_backend.analytics.workflow_manager import WorkflowManager"
        },
        {
          "line": 3055,
          "content": "from wechat_backend.analytics.asset_intelligence_engine import AssetIntelligenceEngine"
        },
        {
          "line": 3063,
          "content": "def optimize_assets():"
        },
        {
          "line": 3064,
          "content": "    \"\"\"资产优化接口 - 分析官方资产与AI偏好的匹配度并提供优化建议\"\"\""
        },
        {
          "line": 3144,
          "content": "    \"\"\"获取枢纽摘要数据 - 品牌GEO运营分析汇总\"\"\""
        },
        {
          "line": 3153,
          "content": "        if not brand_name:"
        },
        {
          "line": 3154,
          "content": "            return jsonify({'error': 'brand_name is required'}), 400"
        },
        {
          "line": 3156,
          "content": "        if days <= 0 or days > 365:"
        },
        {
          "line": 3157,
          "content": "            return jsonify({'error': 'days must be between 1 and 365'}), 400"
        },
        {
          "line": 3160,
          "content": "        if not sql_protector.validate_input(brand_name):"
        },
        {
          "line": 3161,
          "content": "            return jsonify({'error': 'Invalid brand_name'}), 400"
        },
        {
          "line": 3165,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 3171,
          "content": "        return jsonify({"
        },
        {
          "line": 3178,
          "content": "        return jsonify({'error': 'Failed to generate hub summary', 'details': str(e)}), 500"
        },
        {
          "line": 3185,
          "content": "def get_executive_report():"
        },
        {
          "line": 3186,
          "content": "    \"\"\"获取高管视角报告\"\"\""
        },
        {
          "line": 3228,
          "content": "    \"\"\"获取PDF格式的报告\"\"\""
        },
        {
          "line": 3237,
          "content": "        if not brand_name:"
        },
        {
          "line": 3238,
          "content": "            return jsonify({'error': 'brand_name is required'}), 400"
        },
        {
          "line": 3240,
          "content": "        if days <= 0 or days > 365:"
        },
        {
          "line": 3241,
          "content": "            return jsonify({'error': 'days must be between 1 and 365'}), 400"
        },
        {
          "line": 3244,
          "content": "        if not sql_protector.validate_input(brand_name):"
        },
        {
          "line": 3245,
          "content": "            return jsonify({'error': 'Invalid brand_name'}), 400"
        },
        {
          "line": 3249,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 3256,
          "content": "        from flask import Response"
        },
        {
          "line": 3257,
          "content": "        return Response("
        },
        {
          "line": 3265,
          "content": "        return jsonify({'error': 'Failed to generate PDF report', 'details': str(e)}), 500"
        },
        {
          "line": 3269,
          "content": "from wechat_backend.ai_adapters.workflow_manager import WorkflowManager"
        },
        {
          "line": 3277,
          "content": "def create_workflow_task():"
        },
        {
          "line": 3278,
          "content": "    \"\"\"创建工作流任务 - 处理负面证据并分发到指定Webhook\"\"\""
        },
        {
          "line": 3379,
          "content": "    \"\"\"获取工作流任务状态\"\"\""
        },
        {
          "line": 3387,
          "content": "        if not status_info:"
        },
        {
          "line": 3388,
          "content": "            return jsonify({'error': 'Task not found'}), 404"
        },
        {
          "line": 3390,
          "content": "        return jsonify({"
        },
        {
          "line": 3397,
          "content": "        return jsonify({'error': 'Failed to get task status', 'details': str(e)}), 500"
        },
        {
          "line": 3403,
          "content": "def send_verification_code():"
        },
        {
          "line": 3404,
          "content": "    \"\"\"Send verification code to user\"\"\""
        },
        {
          "line": 3430,
          "content": "    # For development, log the code for testing"
        },
        {
          "line": 3433,
          "content": "    # For testing purposes, return the code in the response (remove in production!)"
        },
        {
          "line": 3438,
          "content": "        # REMOVE THIS IN PRODUCTION - for testing only!"
        },
        {
          "line": 3446,
          "content": "    \"\"\"Register new user with phone and password\"\"\""
        },
        {
          "line": 3450,
          "content": "    if not data:"
        },
        {
          "line": 3451,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 3457,
          "content": "    if not phone or not verification_code or not password:"
        },
        {
          "line": 3458,
          "content": "        return jsonify({'error': 'Phone, verification code, and password are required'}), 400"
        },
        {
          "line": 3461,
          "content": "    import re"
        },
        {
          "line": 3463,
          "content": "    if not re.match(phone_pattern, phone):"
        },
        {
          "line": 3464,
          "content": "        return jsonify({'error': 'Invalid phone number format'}), 400"
        },
        {
          "line": 3467,
          "content": "    if len(password) < 6:"
        },
        {
          "line": 3468,
          "content": "        return jsonify({'error': 'Password must be at least 6 characters long'}), 400"
        },
        {
          "line": 3471,
          "content": "    from wechat_backend.database import verify_code, create_user_with_phone"
        },
        {
          "line": 3472,
          "content": "    if not verify_code(phone, verification_code):"
        },
        {
          "line": 3473,
          "content": "        return jsonify({'error': 'Invalid or expired verification code'}), 400"
        },
        {
          "line": 3475,
          "content": "    # Check if phone already registered"
        },
        {
          "line": 3476,
          "content": "    from wechat_backend.database import get_user_by_phone"
        },
        {
          "line": 3478,
          "content": "    if existing_user:"
        },
        {
          "line": 3479,
          "content": "        return jsonify({'error': 'Phone number already registered'}), 409"
        },
        {
          "line": 3482,
          "content": "    import bcrypt"
        },
        {
          "line": 3487,
          "content": "    if user_id == -1:"
        },
        {
          "line": 3488,
          "content": "        return jsonify({'error': 'Failed to create user'}), 500"
        },
        {
          "line": 3491,
          "content": "    from wechat_backend.security.auth import jwt_manager"
        },
        {
          "line": 3496,
          "content": "    from wechat_backend.database import save_refresh_token"
        },
        {
          "line": 3501,
          "content": "    return jsonify({"
        },
        {
          "line": 3514,
          "content": "def login_by_phone():"
        },
        {
          "line": 3515,
          "content": "    \"\"\"Login with phone and password\"\"\""
        },
        {
          "line": 3576,
          "content": "    \"\"\"Validate access token\"\"\""
        },
        {
          "line": 3580,
          "content": "    if not data:"
        },
        {
          "line": 3581,
          "content": "        return jsonify({'status': 'invalid', 'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 3584,
          "content": "    if not token:"
        },
        {
          "line": 3585,
          "content": "        # Try to get token from Authorization header"
        },
        {
          "line": 3587,
          "content": "        if auth_header and auth_header.startswith('Bearer '):"
        },
        {
          "line": 3590,
          "content": "    if not token:"
        },
        {
          "line": 3591,
          "content": "        return jsonify({'status': 'invalid', 'error': 'Token not provided'}), 400"
        },
        {
          "line": 3594,
          "content": "        from wechat_backend.security.auth import jwt_manager"
        },
        {
          "line": 3595,
          "content": "        if not jwt_manager:"
        },
        {
          "line": 3596,
          "content": "            return jsonify({'status': 'invalid', 'error': 'JWT service unavailable'}), 500"
        },
        {
          "line": 3601,
          "content": "        return jsonify({"
        },
        {
          "line": 3609,
          "content": "        return jsonify({'status': 'invalid', 'error': str(e)}), 401"
        },
        {
          "line": 3614,
          "content": "def refresh_token():"
        },
        {
          "line": 3615,
          "content": "    \"\"\"Refresh access token using refresh token\"\"\""
        },
        {
          "line": 3625,
          "content": "        # Try to get refresh token from cookie or header"
        },
        {
          "line": 3650,
          "content": "        # Generate new refresh token (rotate refresh tokens for security)"
        },
        {
          "line": 3684,
          "content": "    \"\"\"Logout user (revoke refresh tokens)\"\"\""
        },
        {
          "line": 3690,
          "content": "    # Option 1: Logout from current device only"
        },
        {
          "line": 3692,
          "content": "    if refresh_token_str:"
        },
        {
          "line": 3693,
          "content": "        from wechat_backend.database import revoke_refresh_token"
        },
        {
          "line": 3696,
          "content": "    # Option 2: Logout from all devices (if requested)"
        },
        {
          "line": 3697,
          "content": "    if data.get('all_devices', False) and user_id:"
        },
        {
          "line": 3698,
          "content": "        from wechat_backend.database import revoke_all_user_tokens"
        },
        {
          "line": 3700,
          "content": "        api_logger.info(f\"All tokens revoked for user {user_id}\")"
        },
        {
          "line": 3702,
          "content": "        api_logger.info(f\"Token revoked for user {user_id or 'anonymous'}\")"
        },
        {
          "line": 3704,
          "content": "    return jsonify({"
        },
        {
          "line": 3713,
          "content": "def get_user_profile():"
        },
        {
          "line": 3714,
          "content": "    \"\"\"Get user profile information\"\"\""
        },
        {
          "line": 3718,
          "content": "    # Convert user_id to int if it's a string"
        },
        {
          "line": 3725,
          "content": "    # Fetch user profile from database"
        },
        {
          "line": 3733,
          "content": "    # Mask phone number for privacy"
        },
        {
          "line": 3759,
          "content": "    \"\"\"Update user profile information (PUT method)\"\"\""
        },
        {
          "line": 3760,
          "content": "    return update_user_profile_data()"
        },
        {
          "line": 3766,
          "content": "def update_user_profile():"
        },
        {
          "line": 3767,
          "content": "    \"\"\"Update user profile information\"\"\""
        },
        {
          "line": 3772,
          "content": "    \"\"\"Helper function to update user profile\"\"\""
        },
        {
          "line": 3776,
          "content": "    # Convert user_id to int if it's a string"
        },
        {
          "line": 3781,
          "content": "        return jsonify({'error': 'Invalid user ID'}), 400"
        },
        {
          "line": 3784,
          "content": "    if not data:"
        },
        {
          "line": 3785,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 3788,
          "content": "    from wechat_backend.database import update_user_profile"
        },
        {
          "line": 3791,
          "content": "    if success:"
        },
        {
          "line": 3795,
          "content": "        from wechat_backend.database import get_user_by_id"
        },
        {
          "line": 3798,
          "content": "        return jsonify({"
        },
        {
          "line": 3809,
          "content": "        return jsonify({'error': 'Failed to update profile'}), 500"
        },
        {
          "line": 3815,
          "content": "def sync_data():"
        },
        {
          "line": 3816,
          "content": "    \"\"\""
        },
        {
          "line": 3827,
          "content": "    \"\"\""
        },
        {
          "line": 3839,
          "content": "        return jsonify({'error': 'Invalid user ID'}), 400"
        },
        {
          "line": 3841,
          "content": "    # Initialize sync database if needed"
        },
        {
          "line": 3842,
          "content": "    from wechat_backend.database import init_sync_db, save_user_data, get_user_data"
        },
        {
          "line": 3847,
          "content": "    if local_results and len(local_results) > 0:"
        },
        {
          "line": 3848,
          "content": "        for result in local_results:"
        },
        {
          "line": 3850,
          "content": "            if result_id:"
        },
        {
          "line": 3853,
          "content": "    api_logger.info(f\"Uploaded {uploaded_count} results for user {user_id}\")"
        },
        {
          "line": 3858,
          "content": "    # 3. Get current timestamp for next sync"
        },
        {
          "line": 3859,
          "content": "    from datetime import datetime"
        },
        {
          "line": 3862,
          "content": "    api_logger.info(f\"Sync completed for user {user_id}: {len(cloud_results)} cloud results, {uploaded_count} uploaded\")"
        },
        {
          "line": 3864,
          "content": "    return jsonify({"
        },
        {
          "line": 3877,
          "content": "def download_data():"
        },
        {
          "line": 3878,
          "content": "    \"\"\""
        },
        {
          "line": 3887,
          "content": "    \"\"\""
        },
        {
          "line": 3898,
          "content": "        return jsonify({'error': 'Invalid user ID'}), 400"
        },
        {
          "line": 3900,
          "content": "    # Initialize sync database if needed"
        },
        {
          "line": 3901,
          "content": "    from wechat_backend.database import init_sync_db, get_user_data"
        },
        {
          "line": 3907,
          "content": "    # Get current timestamp for next sync"
        },
        {
          "line": 3908,
          "content": "    from datetime import datetime"
        },
        {
          "line": 3911,
          "content": "    api_logger.info(f\"Download completed for user {user_id}: {len(cloud_results)} results\")"
        },
        {
          "line": 3913,
          "content": "    return jsonify({"
        },
        {
          "line": 3925,
          "content": "def upload_result():"
        },
        {
          "line": 3926,
          "content": "    \"\"\""
        },
        {
          "line": 3938,
          "content": "    \"\"\""
        },
        {
          "line": 3945,
          "content": "    if not result:"
        },
        {
          "line": 3946,
          "content": "        return jsonify({'error': 'Result data is required'}), 400"
        },
        {
          "line": 3952,
          "content": "        return jsonify({'error': 'Invalid user ID'}), 400"
        },
        {
          "line": 3954,
          "content": "    # Initialize sync database if needed"
        },
        {
          "line": 3955,
          "content": "    from wechat_backend.database import init_sync_db, save_user_data"
        },
        {
          "line": 3961,
          "content": "    if result_id:"
        },
        {
          "line": 3962,
          "content": "        api_logger.info(f\"Result {result_id} uploaded for user {user_id}\")"
        },
        {
          "line": 3964,
          "content": "        return jsonify({"
        },
        {
          "line": 3971,
          "content": "        api_logger.error(f\"Failed to upload result for user {user_id}\")"
        },
        {
          "line": 3972,
          "content": "        return jsonify({'error': 'Failed to upload result'}), 500"
        },
        {
          "line": 3978,
          "content": "def delete_result():"
        },
        {
          "line": 3979,
          "content": "    \"\"\""
        },
        {
          "line": 3984,
          "content": "    \"\"\""
        },
        {
          "line": 3991,
          "content": "    if not result_id:"
        },
        {
          "line": 3992,
          "content": "        return jsonify({'error': 'Result ID is required'}), 400"
        },
        {
          "line": 3998,
          "content": "        return jsonify({'error': 'Invalid user ID'}), 400"
        },
        {
          "line": 4000,
          "content": "    # Initialize sync database if needed"
        },
        {
          "line": 4001,
          "content": "    from wechat_backend.database import init_sync_db, delete_user_data"
        },
        {
          "line": 4004,
          "content": "    # Delete result from cloud"
        },
        {
          "line": 4007,
          "content": "    if success:"
        },
        {
          "line": 4008,
          "content": "        api_logger.info(f\"Result {result_id} deleted for user {user_id}\")"
        },
        {
          "line": 4010,
          "content": "        return jsonify({"
        },
        {
          "line": 4017,
          "content": "        api_logger.warning(f\"Result {result_id} not found for user {user_id}\")"
        },
        {
          "line": 4018,
          "content": "        return jsonify({'error': 'Result not found'}), 404"
        },
        {
          "line": 4024,
          "content": "def competitive_analysis():"
        },
        {
          "line": 4025,
          "content": "    \"\"\"Perform competitive analysis (duplicate of action/recommendations for frontend compatibility)\"\"\""
        },
        {
          "line": 4070,
          "content": "        # If RecommendationGenerator is not available, return a mock response"
        },
        {
          "line": 4090,
          "content": "    \"\"\""
        },
        {
          "line": 4098,
          "content": "    \"\"\""
        },
        {
          "line": 4132,
          "content": "    \"\"\""
        },
        {
          "line": 4137,
          "content": "    \"\"\""
        },
        {
          "line": 4172,
          "content": "    \"\"\""
        },
        {
          "line": 4177,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/database_connection_pool.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 33,
          "content": "    \"\"\""
        },
        {
          "line": 41,
          "content": "    \"\"\""
        },
        {
          "line": 56,
          "content": "        \"\"\"获取数据库连接\"\"\""
        },
        {
          "line": 60,
          "content": "        while True:"
        },
        {
          "line": 63,
          "content": "                if self._pool:"
        },
        {
          "line": 71,
          "content": "                    return conn"
        },
        {
          "line": 74,
          "content": "                if self._created_count < self.max_connections:"
        },
        {
          "line": 85,
          "content": "                    return conn"
        },
        {
          "line": 88,
          "content": "                if (time.time() - start_time) >= timeout:"
        },
        {
          "line": 97,
          "content": "    def return_connection(self, conn: sqlite3.Connection):"
        },
        {
          "line": 98,
          "content": "        \"\"\"归还数据库连接\"\"\""
        },
        {
          "line": 108,
          "content": "        \"\"\"关闭所有连接\"\"\""
        },
        {
          "line": 110,
          "content": "            for conn in self._pool:"
        },
        {
          "line": 117,
          "content": "    def _update_metrics(self):"
        },
        {
          "line": 118,
          "content": "        \"\"\"更新监控指标\"\"\""
        },
        {
          "line": 131,
          "content": "        \"\"\"获取监控指标\"\"\""
        },
        {
          "line": 132,
          "content": "        return _db_pool_metrics.copy()"
        },
        {
          "line": 134,
          "content": "    def reset_metrics(self):"
        },
        {
          "line": 135,
          "content": "        \"\"\"重置监控指标\"\"\""
        },
        {
          "line": 153,
          "content": "    \"\"\"获取全局连接池实例\"\"\""
        },
        {
          "line": 155,
          "content": "    if _db_pool is None:"
        },
        {
          "line": 157,
          "content": "    return _db_pool"
        },
        {
          "line": 160,
          "content": "def get_db_pool_metrics() -> Dict[str, Any]:"
        },
        {
          "line": 161,
          "content": "    \"\"\"获取连接池指标\"\"\""
        },
        {
          "line": 166,
          "content": "    \"\"\"重置连接池指标\"\"\""
        },
        {
          "line": 170,
          "content": "def close_db_pool():"
        },
        {
          "line": 171,
          "content": "    \"\"\"关闭连接池\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/admin_user_management.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 24,
          "content": "    \"\"\"检查用户是否为管理员\"\"\""
        },
        {
          "line": 25,
          "content": "    if not user_id or user_id == 'anonymous':"
        },
        {
          "line": 26,
          "content": "        return False"
        },
        {
          "line": 35,
          "content": "        ''', (user_id,))"
        },
        {
          "line": 44,
          "content": "    \"\"\"装饰器：要求管理员权限\"\"\""
        },
        {
          "line": 45,
          "content": "    from functools import wraps"
        },
        {
          "line": 48,
          "content": "    def decorated_function(*args, **kwargs):"
        },
        {
          "line": 50,
          "content": "        if not is_admin_user(user_id):"
        },
        {
          "line": 51,
          "content": "            return jsonify({'error': 'Admin access required'}), 403"
        },
        {
          "line": 52,
          "content": "        return f(*args, **kwargs)"
        },
        {
          "line": 54,
          "content": "    return decorated_function"
        },
        {
          "line": 60,
          "content": "def get_all_users():"
        },
        {
          "line": 61,
          "content": "    \"\"\"获取所有用户列表\"\"\""
        },
        {
          "line": 78,
          "content": "        ''', (page_size, offset))"
        },
        {
          "line": 79,
          "content": "        users = [dict(row) for row in cursor.fetchall()]"
        },
        {
          "line": 87,
          "content": "        return jsonify({"
        },
        {
          "line": 97,
          "content": "        return jsonify({'error': str(e)}), 500"
        },
        {
          "line": 103,
          "content": "def get_user_detail(user_id):"
        },
        {
          "line": 104,
          "content": "    \"\"\"获取用户详情\"\"\""
        },
        {
          "line": 125,
          "content": "        ''', (user_id,))"
        },
        {
          "line": 126,
          "content": "        user['roles'] = [dict(row) for row in cursor.fetchall()]"
        },
        {
          "line": 134,
          "content": "        return jsonify({'user': user})"
        },
        {
          "line": 138,
          "content": "        return jsonify({'error': str(e)}), 500"
        },
        {
          "line": 144,
          "content": "def assign_user_role(user_id):"
        },
        {
          "line": 145,
          "content": "    \"\"\"分配用户角色\"\"\""
        },
        {
          "line": 171,
          "content": "        ''', (user_id, role_id, datetime.now().isoformat()))"
        },
        {
          "line": 177,
          "content": "        return jsonify({'message': 'Role assigned successfully'})"
        },
        {
          "line": 181,
          "content": "        return jsonify({'error': str(e)}), 500"
        },
        {
          "line": 187,
          "content": "def export_users():"
        },
        {
          "line": 188,
          "content": "    \"\"\"导出用户数据\"\"\""
        },
        {
          "line": 227,
          "content": "    \"\"\"注册用户管理路由\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/database/transaction.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "\"\"\""
        },
        {
          "line": 33,
          "content": "    \"\"\""
        },
        {
          "line": 48,
          "content": "    \"\"\""
        },
        {
          "line": 80,
          "content": "    \"\"\""
        },
        {
          "line": 93,
          "content": "    \"\"\""
        },
        {
          "line": 115,
          "content": "    \"\"\""
        },
        {
          "line": 123,
          "content": "    \"\"\""
        },
        {
          "line": 134,
          "content": "    \"\"\""
        },
        {
          "line": 150,
          "content": "    \"\"\""
        },
        {
          "line": 161,
          "content": "    \"\"\"事务统计信息\"\"\""
        },
        {
          "line": 163,
          "content": "    def __init__(self):"
        },
        {
          "line": 169,
          "content": "    def record_success(self):"
        },
        {
          "line": 173,
          "content": "    def record_failure(self):"
        },
        {
          "line": 177,
          "content": "    def get_stats(self) -> dict:"
        },
        {
          "line": 179,
          "content": "        return {"
        },
        {
          "line": 193,
          "content": "def get_transaction_stats() -> dict:"
        },
        {
          "line": 194,
          "content": "    \"\"\"获取事务统计信息\"\"\""
        },
        {
          "line": 200,
          "content": "    \"\"\""
        },
        {
          "line": 208,
          "content": "        def save_diagnosis_result(data):"
        },
        {
          "line": 210,
          "content": "    \"\"\""
        },
        {
          "line": 247,
          "content": "            \"\"\", ('test_openid_123', '测试用户')"
        },
        {
          "line": 260,
          "content": "            \"\"\", ('test_openid_456', '测试用户 2')"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/database/query_optimizer.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "\"\"\""
        },
        {
          "line": 38,
          "content": "    \"\"\""
        },
        {
          "line": 41,
          "content": "    \"\"\""
        },
        {
          "line": 51,
          "content": "        \"\"\"获取数据库连接\"\"\""
        },
        {
          "line": 59,
          "content": "    def optimize_query(self, sql: str, params: Tuple = None) -> Tuple[str, List[str]]:"
        },
        {
          "line": 60,
          "content": "        \"\"\""
        },
        {
          "line": 65,
          "content": "        \"\"\""
        },
        {
          "line": 73,
          "content": "        if 'SELECT *' in sql_upper:"
        },
        {
          "line": 77,
          "content": "        if ('UPDATE' in sql_upper or 'DELETE' in sql_upper) and 'WHERE' not in sql_upper:"
        },
        {
          "line": 81,
          "content": "        if \"LIKE '%\" in sql_upper:"
        },
        {
          "line": 85,
          "content": "        if 'ORDER BY' in sql_upper and 'LIMIT' not in sql_upper:"
        },
        {
          "line": 89,
          "content": "        if 'SELECT' in sql_upper[sql_upper.find('FROM'):] if 'FROM' in sql_upper else False:"
        },
        {
          "line": 92,
          "content": "        return optimized_sql, suggestions"
        },
        {
          "line": 94,
          "content": "    def analyze_query_performance(self, sql: str, params: Tuple = None) -> Dict[str, Any]:"
        },
        {
          "line": 95,
          "content": "        \"\"\""
        },
        {
          "line": 100,
          "content": "        \"\"\""
        },
        {
          "line": 111,
          "content": "                    'query_plan': [dict(row) for row in plan],"
        },
        {
          "line": 119,
          "content": "                for row in plan:"
        },
        {
          "line": 120,
          "content": "                    detail = row.get('detail', '') if isinstance(row, dict) else str(row)"
        },
        {
          "line": 122,
          "content": "                    if 'USING INDEX' in detail or 'USING COVERING INDEX' in detail:"
        },
        {
          "line": 125,
          "content": "                    if 'SCAN TABLE' in detail or 'SCAN CURSOR' in detail:"
        },
        {
          "line": 129,
          "content": "                        for i, part in enumerate(parts):"
        },
        {
          "line": 130,
          "content": "                            if part in ['TABLE', 'CURSOR'] and i + 1 < len(parts):"
        },
        {
          "line": 132,
          "content": "                                if table_name not in analysis['tables_accessed']:"
        },
        {
          "line": 136,
          "content": "                if analysis['full_table_scan'] and not analysis['uses_index']:"
        },
        {
          "line": 141,
          "content": "                return analysis"
        },
        {
          "line": 144,
          "content": "                return {"
        },
        {
          "line": 150,
          "content": "    def log_slow_query(self, sql: str, duration: float, params: Tuple = None):"
        },
        {
          "line": 151,
          "content": "        \"\"\"记录慢查询\"\"\""
        },
        {
          "line": 170,
          "content": "        \"\"\"获取慢查询列表\"\"\""
        },
        {
          "line": 171,
          "content": "        return sorted("
        },
        {
          "line": 177,
          "content": "    def get_query_stats(self) -> Dict[str, Any]:"
        },
        {
          "line": 178,
          "content": "        \"\"\"获取查询统计\"\"\""
        },
        {
          "line": 189,
          "content": "    \"\"\""
        },
        {
          "line": 192,
          "content": "    \"\"\""
        },
        {
          "line": 200,
          "content": "        \"\"\"获取数据库连接\"\"\""
        },
        {
          "line": 208,
          "content": "    def list_tables(self) -> List[str]:"
        },
        {
          "line": 209,
          "content": "        \"\"\"列出所有表\"\"\""
        },
        {
          "line": 218,
          "content": "        \"\"\"列出索引\"\"\""
        },
        {
          "line": 222,
          "content": "            if table:"
        },
        {
          "line": 232,
          "content": "            return [dict(row) for row in cursor.fetchall()]"
        },
        {
          "line": 234,
          "content": "    def create_index(self, table: str, columns: List[str],"
        },
        {
          "line": 236,
          "content": "        \"\"\""
        },
        {
          "line": 247,
          "content": "        \"\"\""
        },
        {
          "line": 248,
          "content": "        if not index_name:"
        },
        {
          "line": 252,
          "content": "        unique_str = 'UNIQUE ' if unique else ''"
        },
        {
          "line": 264,
          "content": "            return {"
        },
        {
          "line": 273,
          "content": "            return {"
        },
        {
          "line": 278,
          "content": "    def drop_index(self, index_name: str) -> Dict[str, Any]:"
        },
        {
          "line": 279,
          "content": "        \"\"\"删除索引\"\"\""
        },
        {
          "line": 302,
          "content": "        \"\"\""
        },
        {
          "line": 307,
          "content": "        \"\"\""
        },
        {
          "line": 356,
          "content": "        \"\"\"获取建议创建的索引\"\"\""
        },
        {
          "line": 359,
          "content": "        for table in self.list_tables():"
        },
        {
          "line": 361,
          "content": "            if analysis['suggestions']:"
        },
        {
          "line": 367,
          "content": "        return suggestions"
        },
        {
          "line": 369,
          "content": "    def optimize_database(self) -> Dict[str, Any]:"
        },
        {
          "line": 370,
          "content": "        \"\"\""
        },
        {
          "line": 375,
          "content": "        \"\"\""
        },
        {
          "line": 405,
          "content": "                results['integrity_check'] = result[0] if result else 'unknown'"
        },
        {
          "line": 409,
          "content": "        return results"
        },
        {
          "line": 414,
          "content": "def monitor_query_performance(func):"
        },
        {
          "line": 415,
          "content": "    \"\"\""
        },
        {
          "line": 422,
          "content": "    \"\"\""
        },
        {
          "line": 423,
          "content": "    import functools"
        },
        {
          "line": 426,
          "content": "    def wrapper(*args, **kwargs):"
        },
        {
          "line": 431,
          "content": "            return result"
        },
        {
          "line": 435,
          "content": "            if duration >= SLOW_QUERY_THRESHOLD:"
        },
        {
          "line": 442,
          "content": "    return wrapper"
        },
        {
          "line": 451,
          "content": "def get_query_optimizer() -> QueryOptimizer:"
        },
        {
          "line": 452,
          "content": "    \"\"\"获取查询优化器实例\"\"\""
        },
        {
          "line": 457,
          "content": "    \"\"\"获取索引管理器实例\"\"\""
        },
        {
          "line": 458,
          "content": "    return _index_manager"
        },
        {
          "line": 463,
          "content": "def init_recommended_indexes():"
        },
        {
          "line": 464,
          "content": "    \"\"\"初始化推荐索引（增强版）\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/database/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Database module - re-exports from database_core.py for package compatibility"
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "# Import from database_core module"
        },
        {
          "line": 23,
          "content": "# Import from database_connection_pool for compatibility"
        },
        {
          "line": 30,
          "content": "# Import from database_query_optimizer for compatibility"
        },
        {
          "line": 57,
          "content": "    \"\"\""
        },
        {
          "line": 61,
          "content": "    \"\"\""
        },
        {
          "line": 70,
          "content": "    \"\"\""
        },
        {
          "line": 74,
          "content": "    \"\"\""
        },
        {
          "line": 83,
          "content": "    \"\"\""
        },
        {
          "line": 87,
          "content": "    \"\"\""
        },
        {
          "line": 96,
          "content": "    \"\"\""
        },
        {
          "line": 100,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/database/audit_logs.py",
      "lines": [
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 29,
          "content": "        \"\"\"审计日志模型\"\"\""
        },
        {
          "line": 43,
          "content": "        def to_dict(self) -> Dict:"
        },
        {
          "line": 44,
          "content": "            \"\"\"转换为字典\"\"\""
        },
        {
          "line": 60,
          "content": "        \"\"\"初始化审计日志数据库表\"\"\""
        },
        {
          "line": 68,
          "content": "    def get_db_session():"
        },
        {
          "line": 69,
          "content": "        \"\"\"获取数据库会话\"\"\""
        },
        {
          "line": 81,
          "content": "        \"\"\"初始化审计日志（内存版本）\"\"\""
        },
        {
          "line": 84,
          "content": "    def get_db_session():"
        },
        {
          "line": 85,
          "content": "        \"\"\"获取会话（内存版本）\"\"\""
        },
        {
          "line": 106,
          "content": "    \"\"\""
        },
        {
          "line": 121,
          "content": "    \"\"\""
        },
        {
          "line": 179,
          "content": "    \"\"\""
        },
        {
          "line": 193,
          "content": "    \"\"\""
        },
        {
          "line": 241,
          "content": "    \"\"\""
        },
        {
          "line": 249,
          "content": "    \"\"\""
        },
        {
          "line": 269,
          "content": "    \"\"\""
        },
        {
          "line": 277,
          "content": "    \"\"\""
        },
        {
          "line": 318,
          "content": "    \"\"\"记录 API 访问日志\"\"\""
        },
        {
          "line": 319,
          "content": "    return create_audit_log("
        },
        {
          "line": 329,
          "content": "def log_security_event(user_id: str, event_type: str, description: str, ip: str = None):"
        },
        {
          "line": 330,
          "content": "    \"\"\"记录安全事件\"\"\""
        },
        {
          "line": 341,
          "content": "    \"\"\"记录数据访问\"\"\""
        },
        {
          "line": 342,
          "content": "    return create_audit_log("
        },
        {
          "line": 351,
          "content": "if __name__ == '__main__':"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/database/data_retention.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "\"\"\""
        },
        {
          "line": 34,
          "content": "    \"\"\""
        },
        {
          "line": 46,
          "content": "    \"\"\""
        },
        {
          "line": 74,
          "content": "                \"\"\", (soft_delete_cutoff.isoformat(),))"
        },
        {
          "line": 82,
          "content": "                \"\"\", (soft_delete_cutoff.isoformat(),))"
        },
        {
          "line": 96,
          "content": "                \"\"\", (cutoff_date.isoformat(),))"
        },
        {
          "line": 104,
          "content": "                \"\"\", (cutoff_date.isoformat(),))"
        },
        {
          "line": 118,
          "content": "                \"\"\", (datetime.now().isoformat(), cutoff_date.isoformat()))"
        },
        {
          "line": 126,
          "content": "                \"\"\", (datetime.now().isoformat(), cutoff_date.isoformat()))"
        },
        {
          "line": 140,
          "content": "                \"\"\", (audit_cutoff.isoformat(),))"
        },
        {
          "line": 147,
          "content": "                \"\"\", (audit_cutoff.isoformat(),))"
        },
        {
          "line": 181,
          "content": "    \"\"\""
        },
        {
          "line": 189,
          "content": "    \"\"\""
        },
        {
          "line": 208,
          "content": "            \"\"\")"
        },
        {
          "line": 211,
          "content": "            if not has_archive_table:"
        },
        {
          "line": 213,
          "content": "                return stats"
        },
        {
          "line": 217,
          "content": "            if dry_run:"
        },
        {
          "line": 222,
          "content": "                \"\"\", (archive_date.isoformat(),))"
        },
        {
          "line": 231,
          "content": "                \"\"\", (archive_date.isoformat(),))"
        },
        {
          "line": 250,
          "content": "    return stats"
        },
        {
          "line": 253,
          "content": "def get_storage_stats() -> dict:"
        },
        {
          "line": 254,
          "content": "    \"\"\""
        },
        {
          "line": 259,
          "content": "    \"\"\""
        },
        {
          "line": 275,
          "content": "            for table in tables:"
        },
        {
          "line": 285,
          "content": "            \"\"\")"
        },
        {
          "line": 293,
          "content": "            \"\"\", (cutoff_date,))"
        },
        {
          "line": 299,
          "content": "    return stats"
        },
        {
          "line": 302,
          "content": "def schedule_daily_cleanup():"
        },
        {
          "line": 303,
          "content": "    \"\"\""
        },
        {
          "line": 307,
          "content": "    \"\"\""
        },
        {
          "line": 309,
          "content": "        from apscheduler.schedulers.background import BackgroundScheduler"
        },
        {
          "line": 339,
          "content": "        return scheduler"
        },
        {
          "line": 343,
          "content": "        return None"
        },
        {
          "line": 346,
          "content": "if __name__ == '__main__':"
        },
        {
          "line": 356,
          "content": "    if 'table_counts' in stats:"
        },
        {
          "line": 358,
          "content": "        for table, count in stats['table_counts'].items():"
        },
        {
          "line": 360,
          "content": "    if 'soft_deleted_count' in stats:"
        },
        {
          "line": 362,
          "content": "    if 'expired_task_count' in stats:"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/cache/api_cache.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 32,
          "content": "    \"\"\"缓存配置\"\"\""
        },
        {
          "line": 64,
          "content": "class MemoryCache:"
        },
        {
          "line": 65,
          "content": "    \"\"\""
        },
        {
          "line": 68,
          "content": "    \"\"\""
        },
        {
          "line": 70,
          "content": "    def __init__(self, max_size: int = CacheConfig.MAX_ENTRIES):"
        },
        {
          "line": 77,
          "content": "    def get(self, key: str) -> Optional[Any]:"
        },
        {
          "line": 78,
          "content": "        \"\"\"获取缓存\"\"\""
        },
        {
          "line": 98,
          "content": "        \"\"\"设置缓存\"\"\""
        },
        {
          "line": 100,
          "content": "        if len(self.cache) >= self.max_size:"
        },
        {
          "line": 104,
          "content": "        expires_at = time.time() + ttl if ttl > 0 else None"
        },
        {
          "line": 110,
          "content": "            'size': len(json.dumps(value)) if value else 0"
        },
        {
          "line": 115,
          "content": "    def delete(self, key: str) -> bool:"
        },
        {
          "line": 116,
          "content": "        \"\"\"删除缓存\"\"\""
        },
        {
          "line": 123,
          "content": "        \"\"\"清空缓存\"\"\""
        },
        {
          "line": 127,
          "content": "    def delete_pattern(self, pattern: str) -> int:"
        },
        {
          "line": 128,
          "content": "        \"\"\""
        },
        {
          "line": 131,
          "content": "        \"\"\""
        },
        {
          "line": 132,
          "content": "        import fnmatch"
        },
        {
          "line": 136,
          "content": "            key for key in self.cache.keys()"
        },
        {
          "line": 137,
          "content": "            if fnmatch.fnmatch(key, pattern)"
        },
        {
          "line": 140,
          "content": "        for key in keys_to_delete:"
        },
        {
          "line": 144,
          "content": "        return deleted_count"
        },
        {
          "line": 146,
          "content": "    def stats(self) -> Dict[str, Any]:"
        },
        {
          "line": 147,
          "content": "        \"\"\"获取缓存统计\"\"\""
        },
        {
          "line": 166,
          "content": "        \"\"\"获取缓存监控指标\"\"\""
        },
        {
          "line": 167,
          "content": "        total_size = sum(entry.get('size', 0) for entry in self.cache.values())"
        },
        {
          "line": 170,
          "content": "        return {"
        },
        {
          "line": 185,
          "content": "    def cleanup_expired(self) -> int:"
        },
        {
          "line": 186,
          "content": "        \"\"\"清理过期条目\"\"\""
        },
        {
          "line": 202,
          "content": "    \"\"\""
        },
        {
          "line": 211,
          "content": "    \"\"\""
        },
        {
          "line": 221,
          "content": "        \"\"\"获取数据库连接（上下文管理器）\"\"\""
        },
        {
          "line": 234,
          "content": "    def _init_db(self):"
        },
        {
          "line": 235,
          "content": "        \"\"\"初始化数据库表\"\"\""
        },
        {
          "line": 247,
          "content": "            ''')"
        },
        {
          "line": 251,
          "content": "    def _compress(self, data: bytes) -> bytes:"
        },
        {
          "line": 252,
          "content": "        \"\"\"压缩数据\"\"\""
        },
        {
          "line": 258,
          "content": "        \"\"\"解压缩数据\"\"\""
        },
        {
          "line": 260,
          "content": "            return gzip.decompress(data)"
        },
        {
          "line": 263,
          "content": "            return data"
        },
        {
          "line": 265,
          "content": "    def get(self, key: str) -> Optional[Any]:"
        },
        {
          "line": 266,
          "content": "        \"\"\"获取持久化缓存\"\"\""
        },
        {
          "line": 273,
          "content": "            ''', (key,))"
        },
        {
          "line": 277,
          "content": "            if not row:"
        },
        {
          "line": 278,
          "content": "                return None"
        },
        {
          "line": 283,
          "content": "            if expires_at and time.time() > expires_at:"
        },
        {
          "line": 285,
          "content": "                return None"
        },
        {
          "line": 288,
          "content": "            if is_compressed:"
        },
        {
          "line": 292,
          "content": "                return json.loads(value_bytes.decode('utf-8'))"
        },
        {
          "line": 294,
          "content": "                return None"
        },
        {
          "line": 296,
          "content": "    def set(self, key: str, value: Any, ttl: int = CacheConfig.DEFAULT_TTL):"
        },
        {
          "line": 297,
          "content": "        \"\"\"设置持久化缓存\"\"\""
        },
        {
          "line": 315,
          "content": "                ''', (key, value_bytes, expires_at, time.time(), is_compressed, len(value_bytes)))"
        },
        {
          "line": 320,
          "content": "    def delete(self, key: str) -> bool:"
        },
        {
          "line": 321,
          "content": "        \"\"\"删除持久化缓存\"\"\""
        },
        {
          "line": 328,
          "content": "        \"\"\"清空持久化缓存\"\"\""
        },
        {
          "line": 334,
          "content": "    def cleanup_expired(self) -> int:"
        },
        {
          "line": 335,
          "content": "        \"\"\"清理过期条目\"\"\""
        },
        {
          "line": 345,
          "content": "        \"\"\"获取缓存统计\"\"\""
        },
        {
          "line": 365,
          "content": "            return {"
        },
        {
          "line": 374,
          "content": "    def get_metrics(self) -> Dict[str, Any]:"
        },
        {
          "line": 375,
          "content": "        \"\"\"获取持久化缓存监控指标\"\"\""
        },
        {
          "line": 392,
          "content": "    \"\"\""
        },
        {
          "line": 402,
          "content": "    \"\"\""
        },
        {
          "line": 411,
          "content": "        \"\"\"获取缓存（L1 → L2）\"\"\""
        },
        {
          "line": 414,
          "content": "        if value is not None:"
        },
        {
          "line": 415,
          "content": "            return value"
        },
        {
          "line": 418,
          "content": "        if self.enabled:"
        },
        {
          "line": 420,
          "content": "            if value is not None:"
        },
        {
          "line": 423,
          "content": "                return value"
        },
        {
          "line": 425,
          "content": "        return None"
        },
        {
          "line": 427,
          "content": "    def set(self, key: str, value: Any, ttl: int = CacheConfig.DEFAULT_TTL):"
        },
        {
          "line": 428,
          "content": "        \"\"\"设置缓存（L1 + L2）\"\"\""
        },
        {
          "line": 437,
          "content": "        \"\"\"删除缓存（L1 + L2）\"\"\""
        },
        {
          "line": 439,
          "content": "        l2_deleted = self.l2_cache.delete(key) if self.enabled else False"
        },
        {
          "line": 440,
          "content": "        return l1_deleted or l2_deleted"
        },
        {
          "line": 442,
          "content": "    def clear(self):"
        },
        {
          "line": 443,
          "content": "        \"\"\"清空所有缓存\"\"\""
        },
        {
          "line": 449,
          "content": "        \"\"\"清理过期条目\"\"\""
        },
        {
          "line": 451,
          "content": "        l2_cleaned = self.l2_cache.cleanup_expired() if self.enabled else 0"
        },
        {
          "line": 452,
          "content": "        return l1_cleaned + l2_cleaned"
        },
        {
          "line": 454,
          "content": "    def stats(self) -> Dict[str, Any]:"
        },
        {
          "line": 455,
          "content": "        \"\"\"获取缓存统计\"\"\""
        },
        {
          "line": 466,
          "content": "        \"\"\"获取混合缓存监控指标\"\"\""
        },
        {
          "line": 468,
          "content": "        l2_metrics = self.l2_cache.get_metrics() if self.enabled else {}"
        },
        {
          "line": 471,
          "content": "        total_hits = l1_metrics.get('hits', 0) + l2_metrics.get('hits', 0) if self.enabled else l1_metrics.get('hits', 0)"
        },
        {
          "line": 475,
          "content": "        return {"
        },
        {
          "line": 484,
          "content": "            'l1_hit_ratio': round(l1_metrics.get('hits', 0) / max(total_hits, 1) * 100, 2) if total_hits > 0 else 0,"
        },
        {
          "line": 485,
          "content": "            'l2_hit_ratio': round(l2_metrics.get('hits', 0) / max(total_hits, 1) * 100, 2) if self.enabled and total_hits > 0 else 0"
        },
        {
          "line": 495,
          "content": "def cache_response(ttl: int = CacheConfig.DEFAULT_TTL,"
        },
        {
          "line": 498,
          "content": "    \"\"\""
        },
        {
          "line": 514,
          "content": "    \"\"\""
        },
        {
          "line": 515,
          "content": "    def decorator(f: Callable):"
        },
        {
          "line": 517,
          "content": "        def decorated_function(*args, **kwargs):"
        },
        {
          "line": 519,
          "content": "            if request.method not in CacheConfig.CACHEABLE_METHODS:"
        },
        {
          "line": 520,
          "content": "                return f(*args, **kwargs)"
        },
        {
          "line": 523,
          "content": "            if key_generator:"
        },
        {
          "line": 530,
          "content": "            if cached_response is not None:"
        },
        {
          "line": 539,
          "content": "                return response"
        },
        {
          "line": 547,
          "content": "            if cache_condition and not cache_condition():"
        },
        {
          "line": 551,
          "content": "            if hasattr(result, 'status_code'):"
        },
        {
          "line": 552,
          "content": "                if result.status_code in CacheConfig.NON_CACHEABLE_STATUS:"
        },
        {
          "line": 556,
          "content": "            if should_cache and ttl > 0:"
        },
        {
          "line": 558,
          "content": "                if hasattr(result, 'get_json'):"
        },
        {
          "line": 562,
          "content": "                if isinstance(response_data, dict):"
        },
        {
          "line": 571,
          "content": "            return response"
        },
        {
          "line": 573,
          "content": "        return decorated_function"
        },
        {
          "line": 574,
          "content": "    return decorator"
        },
        {
          "line": 577,
          "content": "def invalidate_cache(pattern: str):"
        },
        {
          "line": 578,
          "content": "    \"\"\""
        },
        {
          "line": 586,
          "content": "    \"\"\""
        },
        {
          "line": 587,
          "content": "    def decorator(f: Callable):"
        },
        {
          "line": 589,
          "content": "        def decorated_function(*args, **kwargs):"
        },
        {
          "line": 597,
          "content": "            return result"
        },
        {
          "line": 598,
          "content": "        return decorated_function"
        },
        {
          "line": 599,
          "content": "    return decorator"
        },
        {
          "line": 604,
          "content": "class RequestDeduplicator:"
        },
        {
          "line": 605,
          "content": "    \"\"\""
        },
        {
          "line": 608,
          "content": "    \"\"\""
        },
        {
          "line": 610,
          "content": "    def __init__(self):"
        },
        {
          "line": 613,
          "content": "    def execute(self, key: str, func: Callable, ttl: int = 30) -> Any:"
        },
        {
          "line": 614,
          "content": "        \"\"\""
        },
        {
          "line": 621,
          "content": "        \"\"\""
        },
        {
          "line": 623,
          "content": "        if key in self.pending_requests:"
        },
        {
          "line": 627,
          "content": "            if time.time() - pending['start_time'] > ttl:"
        },
        {
          "line": 634,
          "content": "                return self.execute(key, func, ttl)"
        },
        {
          "line": 649,
          "content": "            return result"
        },
        {
          "line": 656,
          "content": "            import threading"
        },
        {
          "line": 657,
          "content": "            def cleanup():"
        },
        {
          "line": 659,
          "content": "                if key in self.pending_requests:"
        },
        {
          "line": 669,
          "content": "def deduplicate_request(ttl: int = 30):"
        },
        {
          "line": 670,
          "content": "    \"\"\""
        },
        {
          "line": 677,
          "content": "    \"\"\""
        },
        {
          "line": 678,
          "content": "    def decorator(f: Callable):"
        },
        {
          "line": 680,
          "content": "        def decorated_function(*args, **kwargs):"
        },
        {
          "line": 685,
          "content": "            return _request_deduplicator.execute("
        },
        {
          "line": 691,
          "content": "        return decorated_function"
        },
        {
          "line": 692,
          "content": "    return decorator"
        },
        {
          "line": 697,
          "content": "def _generate_cache_key() -> str:"
        },
        {
          "line": 698,
          "content": "    \"\"\""
        },
        {
          "line": 701,
          "content": "    \"\"\""
        },
        {
          "line": 705,
          "content": "        request.query_string.decode() if request.query_string else '',"
        },
        {
          "line": 710,
          "content": "    if request.method in ['POST', 'PUT'] and request.is_json:"
        },
        {
          "line": 713,
          "content": "            if body_data:"
        },
        {
          "line": 724,
          "content": "    if accept_header and 'application/json' not in accept_header:"
        },
        {
          "line": 730,
          "content": "    return f\"{CacheConfig.KEY_PREFIX}{request.method}:{key_hash}\""
        },
        {
          "line": 733,
          "content": "def get_cache_stats() -> Dict[str, Any]:"
        },
        {
          "line": 734,
          "content": "    \"\"\"获取缓存统计\"\"\""
        },
        {
          "line": 739,
          "content": "    \"\"\"清空缓存\"\"\""
        },
        {
          "line": 741,
          "content": "    return {'status': 'success', 'message': '缓存已清空'}"
        },
        {
          "line": 744,
          "content": "def delete_cache_pattern(pattern: str) -> Dict[str, Any]:"
        },
        {
          "line": 745,
          "content": "    \"\"\"根据模式删除缓存\"\"\""
        },
        {
          "line": 755,
          "content": "    \"\"\"预热缓存\"\"\""
        },
        {
          "line": 762,
          "content": "def start_cache_maintenance():"
        },
        {
          "line": 763,
          "content": "    \"\"\"启动缓存维护任务\"\"\""
        },
        {
          "line": 793,
          "content": "    \"\"\"获取缓存统计\"\"\""
        },
        {
          "line": 794,
          "content": "    return jsonify({"
        },
        {
          "line": 801,
          "content": "def cache_clear_endpoint():"
        },
        {
          "line": 802,
          "content": "    \"\"\"清空缓存\"\"\""
        },
        {
          "line": 808,
          "content": "    \"\"\"使缓存失效\"\"\""
        },
        {
          "line": 811,
          "content": "    return jsonify(delete_cache_pattern(pattern))"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/mock_providers.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Mock providers for testing purposes"
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "    \"\"\"Mock provider for testing purposes\"\"\""
        },
        {
          "line": 12,
          "content": "    def __init__(self, api_key: str, model_name: str = \"mock-model\", **kwargs):"
        },
        {
          "line": 15,
          "content": "    async def query(self, prompt: str, **kwargs) -> StandardAIResponse:"
        },
        {
          "line": 17,
          "content": "        await asyncio.sleep(0.5)"
        },
        {
          "line": 18,
          "content": "        return StandardAIResponse("
        },
        {
          "line": 37,
          "content": "    def validate_config(self) -> bool:"
        },
        {
          "line": 38,
          "content": "        return bool(self.api_key)"
        },
        {
          "line": 40,
          "content": "    def get_provider_type(self) -> AIProviderType:"
        },
        {
          "line": 42,
          "content": "        return AIProviderType.CHATGPT  # Just for testing purposes"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/base_provider.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "    \"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\""
        },
        {
          "line": 18,
          "content": "        \"\"\""
        },
        {
          "line": 24,
          "content": "        \"\"\""
        },
        {
          "line": 30,
          "content": "        \"\"\""
        },
        {
          "line": 38,
          "content": "        \"\"\""
        },
        {
          "line": 42,
          "content": "        \"\"\""
        },
        {
          "line": 50,
          "content": "        \"\"\""
        },
        {
          "line": 102,
          "content": "        \"\"\""
        },
        {
          "line": 110,
          "content": "        \"\"\""
        },
        {
          "line": 128,
          "content": "        \"\"\""
        },
        {
          "line": 136,
          "content": "        \"\"\""
        },
        {
          "line": 171,
          "content": "        \"\"\""
        },
        {
          "line": 179,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/retry_decorator.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "    from wechat_backend.ai_adapters.retry_decorator import retry_ai_call"
        },
        {
          "line": 15,
          "content": "    def generate_response(self, prompt, **kwargs):"
        },
        {
          "line": 17,
          "content": "\"\"\""
        },
        {
          "line": 34,
          "content": "    \"\"\""
        },
        {
          "line": 50,
          "content": "        def call_ai_api(prompt):"
        },
        {
          "line": 53,
          "content": "    \"\"\""
        },
        {
          "line": 120,
          "content": "    \"\"\"AI 重试配置\"\"\""
        },
        {
          "line": 122,
          "content": "    def __init__("
        },
        {
          "line": 136,
          "content": "    def get_retry_decorator(self, exceptions: tuple = (Exception,)) -> Callable:"
        },
        {
          "line": 137,
          "content": "        \"\"\"获取重试装饰器\"\"\""
        },
        {
          "line": 159,
          "content": "    \"\"\"使用默认配置的重试装饰器\"\"\""
        },
        {
          "line": 160,
          "content": "    return DEFAULT_RETRY_CONFIG.get_retry_decorator()(func)"
        },
        {
          "line": 163,
          "content": "if __name__ == '__main__':"
        },
        {
          "line": 165,
          "content": "    import random"
        },
        {
          "line": 168,
          "content": "    def test_function():"
        },
        {
          "line": 169,
          "content": "        if random.random() < 0.7:  # 70% 概率失败"
        },
        {
          "line": 171,
          "content": "        return \"成功\""
        },
        {
          "line": 174,
          "content": "    for i in range(5):"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/deepseek_r1_adapter.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 22,
          "content": "    \"\"\""
        },
        {
          "line": 33,
          "content": "        \"\"\""
        },
        {
          "line": 43,
          "content": "        \"\"\""
        },
        {
          "line": 65,
          "content": "        \"\"\""
        },
        {
          "line": 73,
          "content": "        \"\"\""
        },
        {
          "line": 101,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 114,
          "content": "        \"\"\""
        },
        {
          "line": 116,
          "content": "        \"\"\""
        },
        {
          "line": 174,
          "content": "                    # Don't let logging errors affect the main response"
        },
        {
          "line": 242,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 267,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 294,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 297,
          "content": "            # Re-raise the exception to trigger circuit breaker for connection-related errors"
        },
        {
          "line": 330,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 362,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 365,
          "content": "            # Re-raise the exception to trigger circuit breaker for critical errors"
        },
        {
          "line": 379,
          "content": "        \"\"\""
        },
        {
          "line": 388,
          "content": "        \"\"\""
        },
        {
          "line": 425,
          "content": "        \"\"\""
        },
        {
          "line": 433,
          "content": "        \"\"\""
        },
        {
          "line": 458,
          "content": "        \"\"\""
        },
        {
          "line": 467,
          "content": "        \"\"\""
        },
        {
          "line": 527,
          "content": "        \"\"\"将请求异常映射到标准错误类型\"\"\""
        },
        {
          "line": 528,
          "content": "        if hasattr(e, 'response') and e.response is not None:"
        },
        {
          "line": 530,
          "content": "            if status_code == 401:"
        },
        {
          "line": 531,
          "content": "                return AIErrorType.INVALID_API_KEY"
        },
        {
          "line": 532,
          "content": "            elif status_code == 429:"
        },
        {
          "line": 533,
          "content": "                return AIErrorType.RATE_LIMIT_EXCEEDED"
        },
        {
          "line": 534,
          "content": "            elif status_code >= 500:"
        },
        {
          "line": 535,
          "content": "                return AIErrorType.SERVER_ERROR"
        },
        {
          "line": 536,
          "content": "            elif status_code == 403:"
        },
        {
          "line": 537,
          "content": "                return AIErrorType.INVALID_API_KEY"
        },
        {
          "line": 538,
          "content": "        return AIErrorType.UNKNOWN_ERROR"
        },
        {
          "line": 540,
          "content": "    def health_check(self) -> bool:"
        },
        {
          "line": 541,
          "content": "        \"\"\""
        },
        {
          "line": 546,
          "content": "        \"\"\""
        },
        {
          "line": 550,
          "content": "            return test_response.success"
        },
        {
          "line": 552,
          "content": "            return False"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/zhipu_adapter.py",
      "lines": [
        {
          "line": 17,
          "content": "    \"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 38,
          "content": "        \"\"\"生成响应（兼容 NXM 执行引擎）\"\"\""
        },
        {
          "line": 39,
          "content": "        return self.send_prompt(prompt, **kwargs)"
        },
        {
          "line": 40,
          "content": "    def send_prompt(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 41,
          "content": "        \"\"\""
        },
        {
          "line": 43,
          "content": "        \"\"\""
        },
        {
          "line": 47,
          "content": "            return response"
        },
        {
          "line": 65,
          "content": "                    **{k: v for k, v in kwargs.items() if k != 'execution_id'}"
        },
        {
          "line": 68,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 71,
          "content": "            return AIResponse("
        },
        {
          "line": 80,
          "content": "    def _make_request_internal(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 81,
          "content": "        \"\"\""
        },
        {
          "line": 83,
          "content": "        \"\"\""
        },
        {
          "line": 89,
          "content": "        temperature = kwargs.get('temperature', zhipu_config.default_temperature if zhipu_config else 0.7)"
        },
        {
          "line": 90,
          "content": "        max_tokens = kwargs.get('max_tokens', zhipu_config.default_max_tokens if zhipu_config else 1000)"
        },
        {
          "line": 91,
          "content": "        timeout = kwargs.get('timeout', zhipu_config.timeout if zhipu_config else 30)"
        },
        {
          "line": 115,
          "content": "            if response_data and response_data.get(\"choices\"):"
        },
        {
          "line": 117,
          "content": "                tokens_used = response_data[\"usage\"][\"total_tokens\"] if response_data.get(\"usage\") else 0"
        },
        {
          "line": 132,
          "content": "                        **{k: v for k, v in kwargs.items() if k != 'execution_id'}"
        },
        {
          "line": 135,
          "content": "                    # Don't let logging errors affect the main response"
        },
        {
          "line": 138,
          "content": "                return AIResponse("
        },
        {
          "line": 162,
          "content": "                        error_type=error_type if error_type else AIErrorType.UNKNOWN_ERROR,"
        },
        {
          "line": 165,
          "content": "                        **{k: v for k, v in kwargs.items() if k != 'execution_id'}"
        },
        {
          "line": 168,
          "content": "                    # Don't let logging errors affect the main response"
        },
        {
          "line": 171,
          "content": "                return AIResponse("
        },
        {
          "line": 185,
          "content": "            if hasattr(e, 'response') and e.response is not None:"
        },
        {
          "line": 187,
          "content": "                if status_code == 401:"
        },
        {
          "line": 189,
          "content": "                elif status_code == 429:"
        },
        {
          "line": 191,
          "content": "                elif status_code >= 500:"
        },
        {
          "line": 204,
          "content": "                    error_type=error_type if error_type else AIErrorType.REQUEST_EXCEPTION,"
        },
        {
          "line": 207,
          "content": "                    **{k: v for k, v in kwargs.items() if k != 'execution_id'}"
        },
        {
          "line": 210,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 213,
          "content": "            # Re-raise the exception to trigger circuit breaker for connection-related errors"
        },
        {
          "line": 214,
          "content": "            if isinstance(e, (requests.exceptions.ConnectionError, requests.exceptions.Timeout)):"
        },
        {
          "line": 218,
          "content": "            return AIResponse("
        },
        {
          "line": 244,
          "content": "                    **{k: v for k, v in kwargs.items() if k != 'execution_id'}"
        },
        {
          "line": 247,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 250,
          "content": "            # Re-raise the exception to trigger circuit breaker for critical errors"
        },
        {
          "line": 251,
          "content": "            if isinstance(e, (ConnectionError, TimeoutError)):"
        },
        {
          "line": 255,
          "content": "            return AIResponse("
        },
        {
          "line": 264,
          "content": "    def _map_error_message(self, error_message: str) -> AIErrorType:"
        },
        {
          "line": 265,
          "content": "        \"\"\"将Zhipu的错误信息映射到标准错误类型\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/doubao_provider.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 34,
          "content": "        \"\"\""
        },
        {
          "line": 44,
          "content": "        \"\"\""
        },
        {
          "line": 63,
          "content": "        \"\"\""
        },
        {
          "line": 71,
          "content": "        \"\"\""
        },
        {
          "line": 191,
          "content": "        \"\"\""
        },
        {
          "line": 197,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/deepseek_provider.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\""
        },
        {
          "line": 21,
          "content": "    \"\"\""
        },
        {
          "line": 33,
          "content": "        \"\"\""
        },
        {
          "line": 44,
          "content": "        \"\"\""
        },
        {
          "line": 64,
          "content": "        \"\"\""
        },
        {
          "line": 73,
          "content": "        \"\"\""
        },
        {
          "line": 205,
          "content": "        \"\"\""
        },
        {
          "line": 214,
          "content": "        \"\"\""
        },
        {
          "line": 251,
          "content": "        \"\"\""
        },
        {
          "line": 259,
          "content": "        \"\"\""
        },
        {
          "line": 284,
          "content": "        \"\"\""
        },
        {
          "line": 293,
          "content": "        \"\"\""
        },
        {
          "line": 382,
          "content": "        \"\"\""
        },
        {
          "line": 391,
          "content": "        \"\"\""
        },
        {
          "line": 426,
          "content": "        \"\"\""
        },
        {
          "line": 434,
          "content": "        \"\"\""
        },
        {
          "line": 475,
          "content": "        \"\"\""
        },
        {
          "line": 481,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/qwen_adapter.py",
      "lines": [
        {
          "line": 18,
          "content": "    \"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\""
        },
        {
          "line": 40,
          "content": "        \"\"\"生成响应（兼容 NXM 执行引擎）\"\"\""
        },
        {
          "line": 41,
          "content": "        return self.send_prompt(prompt, **kwargs)"
        },
        {
          "line": 42,
          "content": "    def send_prompt(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 43,
          "content": "        \"\"\""
        },
        {
          "line": 45,
          "content": "        \"\"\""
        },
        {
          "line": 49,
          "content": "            return response"
        },
        {
          "line": 67,
          "content": "                    **{k: v for k, v in kwargs.items() if k != 'execution_id'}"
        },
        {
          "line": 70,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 73,
          "content": "            return AIResponse("
        },
        {
          "line": 82,
          "content": "    def _make_request_internal(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 83,
          "content": "        \"\"\""
        },
        {
          "line": 85,
          "content": "        \"\"\""
        },
        {
          "line": 91,
          "content": "        temperature = kwargs.get('temperature', qwen_config.default_temperature if qwen_config else 0.7)"
        },
        {
          "line": 119,
          "content": "            if response_data and response_data.get(\"output\"):"
        },
        {
          "line": 121,
          "content": "                tokens_used = response_data[\"usage\"][\"total_tokens\"] if response_data.get(\"usage\") else 0"
        },
        {
          "line": 137,
          "content": "                        **{k: v for k, v in kwargs.items() if k != 'execution_id'}"
        },
        {
          "line": 140,
          "content": "                    # Don't let logging errors affect the main response"
        },
        {
          "line": 143,
          "content": "                return AIResponse("
        },
        {
          "line": 169,
          "content": "                        error_type=error_type if error_type else AIErrorType.UNKNOWN_ERROR,"
        },
        {
          "line": 172,
          "content": "                        **{k: v for k, v in kwargs.items() if k != 'execution_id'}"
        },
        {
          "line": 175,
          "content": "                    # Don't let logging errors affect the main response"
        },
        {
          "line": 178,
          "content": "                return AIResponse("
        },
        {
          "line": 205,
          "content": "                    **{k: v for k, v in kwargs.items() if k != 'execution_id'}"
        },
        {
          "line": 208,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 213,
          "content": "            # Re-raise the exception to trigger circuit breaker for connection-related errors"
        },
        {
          "line": 214,
          "content": "            if isinstance(e, (requests.exceptions.ConnectionError, requests.exceptions.Timeout)):"
        },
        {
          "line": 217,
          "content": "            return AIResponse("
        },
        {
          "line": 243,
          "content": "                    **{k: v for k, v in kwargs.items() if k != 'execution_id'}"
        },
        {
          "line": 246,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 251,
          "content": "            # Re-raise the exception to trigger circuit breaker for critical errors"
        },
        {
          "line": 252,
          "content": "            if isinstance(e, (ConnectionError, TimeoutError)):"
        },
        {
          "line": 255,
          "content": "            return AIResponse("
        },
        {
          "line": 264,
          "content": "    def _map_error_code(self, error_code: str) -> AIErrorType:"
        },
        {
          "line": 265,
          "content": "        \"\"\"将Qwen的错误码映射到标准错误类型\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/enhanced_factory.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\"增强版AI适配器工厂\"\"\""
        },
        {
          "line": 2,
          "content": "from typing import Dict, Type, Union, Optional"
        },
        {
          "line": 3,
          "content": "from wechat_backend.ai_adapters.base_adapter import AIClient, AIPlatformType"
        },
        {
          "line": 4,
          "content": "from wechat_backend.analytics.api_monitor import ApiMonitor"
        },
        {
          "line": 5,
          "content": "import random"
        },
        {
          "line": 8,
          "content": "class EnhancedAIAdapterFactory:"
        },
        {
          "line": 9,
          "content": "    \"\"\"增强版AI适配器工厂\"\"\""
        },
        {
          "line": 16,
          "content": "        \"\"\"注册适配器\"\"\""
        },
        {
          "line": 20,
          "content": "    def create(cls, platform_type: Union[AIPlatformType, str],"
        },
        {
          "line": 22,
          "content": "        \"\"\"创建AI客户端，智能选择最佳配置\"\"\""
        },
        {
          "line": 44,
          "content": "        \"\"\"将字符串转换为AIPlatformType\"\"\""
        },
        {
          "line": 62,
          "content": "        if platform_lower in platform_map:"
        },
        {
          "line": 63,
          "content": "            return platform_map[platform_lower]"
        },
        {
          "line": 66,
          "content": "            for platform_type in AIPlatformType:"
        },
        {
          "line": 67,
          "content": "                if platform_type.value == platform_lower:"
        },
        {
          "line": 68,
          "content": "                    return platform_type"
        },
        {
          "line": 72,
          "content": "    def _get_backup_platform(cls, primary_platform: AIPlatformType) -> Optional[AIPlatformType]:"
        },
        {
          "line": 73,
          "content": "        \"\"\"获取备用平台\"\"\""
        },
        {
          "line": 93,
          "content": "        \"\"\"注册适配器并关联监控配置\"\"\""
        },
        {
          "line": 95,
          "content": "        if config:"
        },
        {
          "line": 99,
          "content": "    def get_monitor(cls):"
        },
        {
          "line": 100,
          "content": "        \"\"\"获取监控器实例\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/factory.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Factory for creating and managing AI adapters"
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 97,
          "content": "    \"\"\""
        },
        {
          "line": 98,
          "content": "    Factory class for creating AI adapters based on platform type."
        },
        {
          "line": 99,
          "content": "    \"\"\""
        },
        {
          "line": 162,
          "content": "        \"\"\""
        },
        {
          "line": 163,
          "content": "        Register an AI adapter class for a specific platform type"
        },
        {
          "line": 164,
          "content": "        \"\"\""
        },
        {
          "line": 173,
          "content": "        \"\"\""
        },
        {
          "line": 175,
          "content": "        \"\"\""
        },
        {
          "line": 195,
          "content": "        \"\"\""
        },
        {
          "line": 197,
          "content": "        \"\"\""
        },
        {
          "line": 210,
          "content": "        \"\"\""
        },
        {
          "line": 211,
          "content": "        Create an instance of an AI adapter for the specified platform"
        },
        {
          "line": 212,
          "content": "        If api_key is not provided, attempts to load from environment variables"
        },
        {
          "line": 215,
          "content": "        For Doubao platform, uses DoubaoPriorityAdapter for automatic model selection"
        },
        {
          "line": 216,
          "content": "        \"\"\""
        },
        {
          "line": 231,
          "content": "        # If API key is not provided, try to get it from config"
        },
        {
          "line": 239,
          "content": "        # If model name is not provided, try to get default from config"
        },
        {
          "line": 260,
          "content": "# Debug logging for adapter availability"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/workflow_manager.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 20,
          "content": "# from wechat_backend.ai_adapters.base_provider import BaseAIProvider"
        },
        {
          "line": 21,
          "content": "# from .doubao_provider import DoubaoProvider"
        },
        {
          "line": 22,
          "content": "# from .deepseek_provider import DeepSeekProvider"
        },
        {
          "line": 26,
          "content": "    \"\"\"任务优先级枚举\"\"\""
        },
        {
          "line": 33,
          "content": "class TaskStatus(Enum):"
        },
        {
          "line": 34,
          "content": "    \"\"\"任务状态枚举\"\"\""
        },
        {
          "line": 44,
          "content": "    \"\"\"工作流任务数据结构\"\"\""
        },
        {
          "line": 63,
          "content": "class WebhookManager:"
        },
        {
          "line": 64,
          "content": "    \"\"\"Webhook管理器 - 处理任务推送至第三方API\"\"\""
        },
        {
          "line": 78,
          "content": "        \"\"\""
        },
        {
          "line": 88,
          "content": "        \"\"\""
        },
        {
          "line": 102,
          "content": "        \"\"\""
        },
        {
          "line": 104,
          "content": "        \"\"\""
        },
        {
          "line": 133,
          "content": "    \"\"\"工作流管理器 - 智能任务分发系统\"\"\""
        },
        {
          "line": 135,
          "content": "    def __init__(self):"
        },
        {
          "line": 150,
          "content": "    def _start_background_processor(self):"
        },
        {
          "line": 151,
          "content": "        \"\"\"启动后台任务处理器线程\"\"\""
        },
        {
          "line": 178,
          "content": "        \"\"\"启动重试处理器线程\"\"\""
        },
        {
          "line": 179,
          "content": "        def process_retries():"
        },
        {
          "line": 180,
          "content": "            while True:"
        },
        {
          "line": 188,
          "content": "                        if datetime.now() >= next_retry_time:"
        },
        {
          "line": 210,
          "content": "    def create_task_package("
        },
        {
          "line": 221,
          "content": "        \"\"\""
        },
        {
          "line": 236,
          "content": "        \"\"\""
        },
        {
          "line": 259,
          "content": "        return task_package"
        },
        {
          "line": 261,
          "content": "    def dispatch_task("
        },
        {
          "line": 273,
          "content": "        \"\"\""
        },
        {
          "line": 289,
          "content": "        \"\"\""
        },
        {
          "line": 290,
          "content": "        import uuid"
        },
        {
          "line": 316,
          "content": "        api_logger.info(f\"Task {task_id} queued for dispatch to {webhook_url} with priority {priority.value}\")"
        },
        {
          "line": 318,
          "content": "        return task_id"
        },
        {
          "line": 320,
          "content": "    def _priority_to_number(self, priority: TaskPriority) -> int:"
        },
        {
          "line": 321,
          "content": "        \"\"\"将优先级转换为数字，用于队列排序\"\"\""
        },
        {
          "line": 331,
          "content": "        \"\"\"处理单个任务\"\"\""
        },
        {
          "line": 341,
          "content": "        if success:"
        },
        {
          "line": 350,
          "content": "            if retry_count < max_retries:"
        },
        {
          "line": 362,
          "content": "                api_logger.info(f\"Task {task_id} failed, scheduled for retry #{retry_count + 1} at {next_retry_time} (delay: {delay_seconds}s)\")"
        },
        {
          "line": 369,
          "content": "    def _process_task_with_retry(self, task_data: Dict[str, Any]):"
        },
        {
          "line": 370,
          "content": "        \"\"\"处理重试任务\"\"\""
        },
        {
          "line": 409,
          "content": "        \"\"\""
        },
        {
          "line": 417,
          "content": "        \"\"\""
        },
        {
          "line": 429,
          "content": "        \"\"\"更新任务状态\"\"\""
        },
        {
          "line": 434,
          "content": "    def get_task_status(self, task_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 435,
          "content": "        \"\"\"获取任务状态\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/provider_factory.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "    \"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\""
        },
        {
          "line": 22,
          "content": "        \"\"\""
        },
        {
          "line": 28,
          "content": "        \"\"\""
        },
        {
          "line": 34,
          "content": "        \"\"\""
        },
        {
          "line": 45,
          "content": "        \"\"\""
        },
        {
          "line": 59,
          "content": "        \"\"\""
        },
        {
          "line": 64,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/domestic_providers.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\""
        },
        {
          "line": 36,
          "content": "        \"\"\""
        },
        {
          "line": 38,
          "content": "        \"\"\""
        },
        {
          "line": 127,
          "content": "        \"\"\"将通义千问的错误码映射到标准错误类型\"\"\""
        },
        {
          "line": 128,
          "content": "        if error_code == \"InvalidAPIKey\":"
        },
        {
          "line": 129,
          "content": "            return AIErrorType.INVALID_API_KEY"
        },
        {
          "line": 130,
          "content": "        if error_code == \"QuotaExhausted\":"
        },
        {
          "line": 131,
          "content": "            return AIErrorType.INSUFFICIENT_QUOTA"
        },
        {
          "line": 132,
          "content": "        if error_code == \"OperationDenied.ContentRisk\":"
        },
        {
          "line": 133,
          "content": "            return AIErrorType.CONTENT_SAFETY"
        },
        {
          "line": 134,
          "content": "        if \"Throttling\" in error_code:"
        },
        {
          "line": 135,
          "content": "            return AIErrorType.RATE_LIMIT_EXCEEDED"
        },
        {
          "line": 136,
          "content": "        return AIErrorType.UNKNOWN_ERROR"
        },
        {
          "line": 139,
          "content": "class WenxinAdapter(AIClient):"
        },
        {
          "line": 140,
          "content": "    \"\"\""
        },
        {
          "line": 142,
          "content": "    \"\"\""
        },
        {
          "line": 143,
          "content": "    def __init__(self, api_key: str, secret_key: str, model_name: str = \"ernie-bot-4.5\", base_url: Optional[str] = None):"
        },
        {
          "line": 158,
          "content": "        api_logger.info(f\"WenxinAdapter initialized for model: {model_name} with unified request wrapper\")"
        },
        {
          "line": 160,
          "content": "    def _get_access_token(self):"
        },
        {
          "line": 161,
          "content": "        \"\"\"获取访问令牌\"\"\""
        },
        {
          "line": 192,
          "content": "        \"\"\""
        },
        {
          "line": 194,
          "content": "        \"\"\""
        },
        {
          "line": 296,
          "content": "        \"\"\"将文心一言的错误码映射到标准错误类型\"\"\""
        },
        {
          "line": 297,
          "content": "        if error_code in [110, 111]:  # Invalid API key"
        },
        {
          "line": 298,
          "content": "            return AIErrorType.INVALID_API_KEY"
        },
        {
          "line": 299,
          "content": "        elif error_code == 18:  # Quota exceeded"
        },
        {
          "line": 300,
          "content": "            return AIErrorType.INSUFFICIENT_QUOTA"
        },
        {
          "line": 301,
          "content": "        elif error_code in [336003, 336100]:  # Content safety"
        },
        {
          "line": 302,
          "content": "            return AIErrorType.CONTENT_SAFETY"
        },
        {
          "line": 303,
          "content": "        elif error_code == 17:  # Rate limit"
        },
        {
          "line": 304,
          "content": "            return AIErrorType.RATE_LIMIT_EXCEEDED"
        },
        {
          "line": 305,
          "content": "        return AIErrorType.UNKNOWN_ERROR"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/doubao_adapter.py",
      "lines": [
        {
          "line": 25,
          "content": "# from wechat_backend.utils.ai_response_wrapper import log_detailed_response  # Removed: use NXM unified logging"
        },
        {
          "line": 29,
          "content": "    \"\"\""
        },
        {
          "line": 31,
          "content": "    \"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\"启动时验证API连通性\"\"\""
        },
        {
          "line": 87,
          "content": "            debug_log(\"HEALTH_CHECK\", \"INIT\", f\"Performing health check for Doubao API with model: {self.model_name}, URL: {base_url}\")"
        },
        {
          "line": 98,
          "content": "            if response.status_code == 200:"
        },
        {
          "line": 107,
          "content": "    def _get_headers(self):"
        },
        {
          "line": 108,
          "content": "        \"\"\"统一管理请求头\"\"\""
        },
        {
          "line": 116,
          "content": "        \"\"\""
        },
        {
          "line": 118,
          "content": "        \"\"\""
        },
        {
          "line": 119,
          "content": "        # Extract execution_id from kwargs if available for DEBUG_AI_CODE logging"
        },
        {
          "line": 160,
          "content": "        \"\"\""
        },
        {
          "line": 169,
          "content": "        \"\"\""
        },
        {
          "line": 174,
          "content": "        \"\"\""
        },
        {
          "line": 176,
          "content": "        \"\"\""
        },
        {
          "line": 177,
          "content": "        # Extract execution_id from kwargs for DEBUG_AI_CODE logging"
        },
        {
          "line": 189,
          "content": "        # Prepare payload for Doubao API"
        },
        {
          "line": 268,
          "content": "                # Note: Response logging is now handled by NXM execution engine for unified logging"
        },
        {
          "line": 284,
          "content": "                # Log with DEBUG_AI_CODE system for errors"
        },
        {
          "line": 288,
          "content": "                # Note: Error logging is now handled by NXM execution engine for unified logging"
        },
        {
          "line": 312,
          "content": "            # Note: Error logging is now handled by NXM execution engine for unified logging"
        },
        {
          "line": 314,
          "content": "            # Check if this is a timeout or connection error that should trigger circuit breaker"
        },
        {
          "line": 346,
          "content": "                            # Note: Error logging is now handled by NXM execution engine for unified logging"
        },
        {
          "line": 383,
          "content": "            # Note: Error logging is now handled by NXM execution engine for unified logging"
        },
        {
          "line": 385,
          "content": "            # For non-requests exceptions, check if it's a timeout-related error"
        },
        {
          "line": 403,
          "content": "        \"\"\"将Doubao的错误信息映射到标准错误类型\"\"\""
        },
        {
          "line": 405,
          "content": "        if \"invalid api\" in error_message_lower or \"authentication\" in error_message_lower or \"unauthorized\" in error_message_lower or \"api key\" in error_message_lower:"
        },
        {
          "line": 406,
          "content": "            return AIErrorType.INVALID_API_KEY"
        },
        {
          "line": 407,
          "content": "        if \"quota\" in error_message_lower or \"credit\" in error_message_lower or \"exceeded\" in error_message_lower:"
        },
        {
          "line": 408,
          "content": "            return AIErrorType.INSUFFICIENT_QUOTA"
        },
        {
          "line": 409,
          "content": "        if \"content\" in error_message_lower and (\"policy\" in error_message_lower or \"safety\" in error_message_lower):"
        },
        {
          "line": 410,
          "content": "            return AIErrorType.CONTENT_SAFETY"
        },
        {
          "line": 411,
          "content": "        if \"safety\" in error_message_lower or \"policy\" in error_message_lower:"
        },
        {
          "line": 412,
          "content": "            return AIErrorType.CONTENT_SAFETY"
        },
        {
          "line": 413,
          "content": "        if \"rate limit\" in error_message_lower or \"too many requests\" in error_message_lower:"
        },
        {
          "line": 414,
          "content": "            return AIErrorType.RATE_LIMIT_EXCEEDED"
        },
        {
          "line": 415,
          "content": "        if \"not found\" in error_message_lower or \"404\" in error_message_lower:"
        },
        {
          "line": 416,
          "content": "            return AIErrorType.INVALID_API_KEY  # 404通常意味着API密钥或端点错误"
        },
        {
          "line": 417,
          "content": "        return AIErrorType.UNKNOWN_ERROR"
        },
        {
          "line": 419,
          "content": "    def get_latency_stats(self) -> dict:"
        },
        {
          "line": 420,
          "content": "        \"\"\"获取延迟统计信息\"\"\""
        },
        {
          "line": 439,
          "content": "        \"\"\"清理会话连接\"\"\""
        },
        {
          "line": 440,
          "content": "        if hasattr(self, 'session'):"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/qwen_provider.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 33,
          "content": "        \"\"\""
        },
        {
          "line": 42,
          "content": "        \"\"\""
        },
        {
          "line": 60,
          "content": "        \"\"\""
        },
        {
          "line": 68,
          "content": "        \"\"\""
        },
        {
          "line": 188,
          "content": "        \"\"\""
        },
        {
          "line": 197,
          "content": "        \"\"\""
        },
        {
          "line": 308,
          "content": "        \"\"\""
        },
        {
          "line": 317,
          "content": "        \"\"\""
        },
        {
          "line": 396,
          "content": "        \"\"\""
        },
        {
          "line": 405,
          "content": "        \"\"\""
        },
        {
          "line": 428,
          "content": "        \"\"\""
        },
        {
          "line": 436,
          "content": "        \"\"\""
        },
        {
          "line": 469,
          "content": "        \"\"\""
        },
        {
          "line": 478,
          "content": "        \"\"\""
        },
        {
          "line": 504,
          "content": "        \"\"\""
        },
        {
          "line": 510,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/doubao_priority_adapter.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "    \"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\""
        },
        {
          "line": 60,
          "content": "        \"\"\""
        },
        {
          "line": 65,
          "content": "        \"\"\""
        },
        {
          "line": 87,
          "content": "        \"\"\""
        },
        {
          "line": 92,
          "content": "        \"\"\""
        },
        {
          "line": 132,
          "content": "        \"\"\""
        },
        {
          "line": 140,
          "content": "        \"\"\""
        },
        {
          "line": 184,
          "content": "        \"\"\""
        },
        {
          "line": 193,
          "content": "        \"\"\""
        },
        {
          "line": 260,
          "content": "        \"\"\""
        },
        {
          "line": 269,
          "content": "        \"\"\""
        },
        {
          "line": 274,
          "content": "        \"\"\""
        },
        {
          "line": 279,
          "content": "        \"\"\""
        },
        {
          "line": 283,
          "content": "        \"\"\""
        },
        {
          "line": 288,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/geo_parser.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "    \"\"\""
        },
        {
          "line": 29,
          "content": "    \"\"\""
        },
        {
          "line": 132,
          "content": "    \"\"\""
        },
        {
          "line": 140,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/doubao_adapter_fixed.py",
      "lines": [
        {
          "line": 13,
          "content": "    \"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\""
        },
        {
          "line": 40,
          "content": "        \"\"\""
        },
        {
          "line": 42,
          "content": "        \"\"\""
        },
        {
          "line": 52,
          "content": "        # Prepare payload for Doubao API"
        },
        {
          "line": 175,
          "content": "        \"\"\"将Doubao的错误信息映射到标准错误类型\"\"\""
        },
        {
          "line": 177,
          "content": "        if \"invalid api\" in error_message_lower or \"authentication\" in error_message_lower or \"unauthorized\" in error_message_lower:"
        },
        {
          "line": 178,
          "content": "            return AIErrorType.INVALID_API_KEY"
        },
        {
          "line": 179,
          "content": "        if \"quota\" in error_message_lower or \"credit\" in error_message_lower or \"exceeded\" in error_message_lower:"
        },
        {
          "line": 180,
          "content": "            return AIErrorType.INSUFFICIENT_QUOTA"
        },
        {
          "line": 181,
          "content": "        if \"content\" in error_message_lower and (\"policy\" in error_message_lower or \"safety\" in error_message_lower):"
        },
        {
          "line": 182,
          "content": "            return AIErrorType.CONTENT_SAFETY"
        },
        {
          "line": 183,
          "content": "        if \"safety\" in error_message_lower or \"policy\" in error_message_lower:"
        },
        {
          "line": 184,
          "content": "            return AIErrorType.CONTENT_SAFETY"
        },
        {
          "line": 185,
          "content": "        if \"rate limit\" in error_message_lower or \"too many requests\" in error_message_lower:"
        },
        {
          "line": 186,
          "content": "            return AIErrorType.RATE_LIMIT_EXCEEDED"
        },
        {
          "line": 187,
          "content": "        return AIErrorType.UNKNOWN_ERROR"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/gemini_adapter.py",
      "lines": [
        {
          "line": 16,
          "content": "    \"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\""
        },
        {
          "line": 34,
          "content": "        \"\"\"生成响应（兼容 NXM 执行引擎）\"\"\""
        },
        {
          "line": 35,
          "content": "        return self.send_prompt(prompt, **kwargs)"
        },
        {
          "line": 36,
          "content": "    def send_prompt(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 37,
          "content": "        \"\"\""
        },
        {
          "line": 39,
          "content": "        \"\"\""
        },
        {
          "line": 70,
          "content": "            if candidates:"
        },
        {
          "line": 90,
          "content": "                        **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 93,
          "content": "                    # Don't let logging errors affect the main response"
        },
        {
          "line": 96,
          "content": "                return AIResponse("
        },
        {
          "line": 122,
          "content": "                        error_type=error_type if error_type else AIErrorType.UNKNOWN_ERROR,"
        },
        {
          "line": 125,
          "content": "                        **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 128,
          "content": "                    # Don't let logging errors affect the main response"
        },
        {
          "line": 131,
          "content": "                return AIResponse("
        },
        {
          "line": 145,
          "content": "            if hasattr(e, 'response') and e.response is not None:"
        },
        {
          "line": 147,
          "content": "                if status_code == 400:"
        },
        {
          "line": 148,
          "content": "                    error_type = AIErrorType.CONTENT_SAFETY  # Often safety issues return 400"
        },
        {
          "line": 149,
          "content": "                elif status_code == 401 or status_code == 403:"
        },
        {
          "line": 151,
          "content": "                elif status_code == 429:"
        },
        {
          "line": 152,
          "content": "                    error_type = AIErrorType.INSUFFICIENT_QUOTA  # Quota issues often return 429"
        },
        {
          "line": 153,
          "content": "                elif status_code >= 500:"
        },
        {
          "line": 168,
          "content": "                    error_type=error_type if error_type else AIErrorType.REQUEST_EXCEPTION,"
        },
        {
          "line": 171,
          "content": "                    **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 174,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 178,
          "content": "            return AIResponse("
        },
        {
          "line": 204,
          "content": "                    **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 207,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 211,
          "content": "            return AIResponse("
        },
        {
          "line": 220,
          "content": "    def _map_error_code(self, error_code: int) -> AIErrorType:"
        },
        {
          "line": 221,
          "content": "        \"\"\"将Gemini的错误码映射到标准错误类型\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/enhanced_base.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\"增强版AI客户端基础类\"\"\""
        },
        {
          "line": 2,
          "content": "from wechat_backend.ai_adapters.base_adapter import AIClient, AIResponse, AIPlatformType"
        },
        {
          "line": 3,
          "content": "from wechat_backend.analytics.api_monitor import ApiMonitor"
        },
        {
          "line": 4,
          "content": "import time"
        },
        {
          "line": 5,
          "content": "import requests"
        },
        {
          "line": 6,
          "content": "from typing import Optional"
        },
        {
          "line": 9,
          "content": "class EnhancedAIClient(AIClient):"
        },
        {
          "line": 10,
          "content": "    \"\"\"增强版AI客户端\"\"\""
        },
        {
          "line": 20,
          "content": "        \"\"\"发送提示，包含智能错误处理\"\"\""
        },
        {
          "line": 24,
          "content": "        if self.monitor.is_rate_limited(platform_name):"
        },
        {
          "line": 25,
          "content": "            return self._create_rate_limit_response()"
        },
        {
          "line": 28,
          "content": "        if not self._is_platform_available():"
        },
        {
          "line": 29,
          "content": "            return self._create_fallback_response(prompt, **kwargs)"
        },
        {
          "line": 41,
          "content": "            if response.success:"
        },
        {
          "line": 43,
          "content": "                return response"
        },
        {
          "line": 46,
          "content": "                return response"
        },
        {
          "line": 50,
          "content": "            return AIResponse("
        },
        {
          "line": 58,
          "content": "    def _is_platform_available(self) -> bool:"
        },
        {
          "line": 59,
          "content": "        \"\"\"检查平台是否可用\"\"\""
        },
        {
          "line": 65,
          "content": "        \"\"\"创建速率限制响应\"\"\""
        },
        {
          "line": 66,
          "content": "        return AIResponse("
        },
        {
          "line": 69,
          "content": "            error_type=getattr(self, 'AIErrorType', None).__dict__.get('RATE_LIMIT_EXCEEDED') if hasattr(self, 'AIErrorType') else None,"
        },
        {
          "line": 75,
          "content": "    def _create_fallback_response(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 76,
          "content": "        \"\"\"创建备用响应\"\"\""
        },
        {
          "line": 88,
          "content": "        \"\"\"执行实际的API请求 - 子类需实现\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/sync_providers.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Synchronous AI Provider Implementations for GEO Content Quality Validator"
        },
        {
          "line": 3,
          "content": "Includes providers for domestic models like DeepSeek, Doubao, Qwen, etc."
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "    \"\"\"AI Provider for DeepSeek API\"\"\""
        },
        {
          "line": 15,
          "content": "    def __init__(self, api_key: str, model_name: str = \"deepseek-chat\", **kwargs):"
        },
        {
          "line": 21,
          "content": "        # Headers for API requests"
        },
        {
          "line": 27,
          "content": "    def _send_actual_request(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 28,
          "content": "        \"\"\"Send a prompt to the DeepSeek API\"\"\""
        },
        {
          "line": 51,
          "content": "                # Extract the content from the response"
        },
        {
          "line": 54,
          "content": "                # Extract token usage if available"
        },
        {
          "line": 103,
          "content": "    \"\"\"AI Provider for Doubao (ByteDance) API\"\"\""
        },
        {
          "line": 105,
          "content": "    def __init__(self, api_key: str, model_name: str = \"doubao-pro-128k\", **kwargs):"
        },
        {
          "line": 112,
          "content": "        # Headers for API requests"
        },
        {
          "line": 118,
          "content": "    def _send_actual_request(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 119,
          "content": "        \"\"\"Send a prompt to the Doubao API\"\"\""
        },
        {
          "line": 142,
          "content": "                # Extract the content from the response"
        },
        {
          "line": 145,
          "content": "                # Extract token usage if available"
        },
        {
          "line": 194,
          "content": "    \"\"\"AI Provider for Qwen (Alibaba Tongyi) API\"\"\""
        },
        {
          "line": 196,
          "content": "    def __init__(self, api_key: str, model_name: str = \"qwen-max\", **kwargs):"
        },
        {
          "line": 202,
          "content": "        # Headers for API requests"
        },
        {
          "line": 208,
          "content": "    def _send_actual_request(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 209,
          "content": "        \"\"\"Send a prompt to the Qwen API\"\"\""
        },
        {
          "line": 235,
          "content": "                # Extract the content from the response"
        },
        {
          "line": 238,
          "content": "                # Extract token usage if available"
        },
        {
          "line": 287,
          "content": "    \"\"\"AI Provider for Yuanbao (Tencent HunYuan) API\"\"\""
        },
        {
          "line": 289,
          "content": "    def __init__(self, api_key: str, model_name: str = \"hunyuan-pro\", **kwargs):"
        },
        {
          "line": 296,
          "content": "        # Headers for API requests"
        },
        {
          "line": 302,
          "content": "    def _send_actual_request(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 303,
          "content": "        \"\"\"Send a prompt to the Yuanbao API\"\"\""
        },
        {
          "line": 326,
          "content": "                # Extract the content from the response"
        },
        {
          "line": 329,
          "content": "                # Extract token usage if available"
        },
        {
          "line": 378,
          "content": "    \"\"\"AI Provider for Ernie (Baidu) API\"\"\""
        },
        {
          "line": 380,
          "content": "    def __init__(self, api_key: str, model_name: str = \"ernie-bot-4.5\", **kwargs):"
        },
        {
          "line": 387,
          "content": "        # Headers for API requests"
        },
        {
          "line": 392,
          "content": "    def _send_actual_request(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 393,
          "content": "        \"\"\"Send a prompt to the Ernie API\"\"\""
        },
        {
          "line": 425,
          "content": "                # Extract the content from the response"
        },
        {
          "line": 428,
          "content": "                # Extract token usage if available"
        },
        {
          "line": 476,
          "content": "        \"\"\"Get access token for Baidu API - placeholder implementation\"\"\""
        },
        {
          "line": 477,
          "content": "        # In a real implementation, you would fetch the access token from Baidu"
        },
        {
          "line": 479,
          "content": "        return \"fake_access_token\"  # Placeholder"
        },
        {
          "line": 482,
          "content": "class KimiProvider(EnhancedAIClient):"
        },
        {
          "line": 483,
          "content": "    \"\"\"AI Provider for Kimi (Moonshot AI) API\"\"\""
        },
        {
          "line": 491,
          "content": "        # Headers for API requests"
        },
        {
          "line": 498,
          "content": "        \"\"\"Send a prompt to the Kimi API\"\"\""
        },
        {
          "line": 519,
          "content": "            if response.status_code == 200:"
        },
        {
          "line": 520,
          "content": "                # Extract the content from the response"
        },
        {
          "line": 523,
          "content": "                # Extract token usage if available"
        },
        {
          "line": 527,
          "content": "                api_logger.info(f\"Successfully received response from Kimi API for model: {self.model_name}\")"
        },
        {
          "line": 529,
          "content": "                return AIResponse("
        },
        {
          "line": 541,
          "content": "                api_logger.error(f\"Kimi API error for model: {self.model_name}: {error_msg}\")"
        },
        {
          "line": 543,
          "content": "                return AIResponse("
        },
        {
          "line": 552,
          "content": "            api_logger.error(f\"Timeout error when calling Kimi API for model: {self.model_name}\")"
        },
        {
          "line": 553,
          "content": "            return AIResponse("
        },
        {
          "line": 561,
          "content": "            api_logger.error(f\"Unexpected error when calling Kimi API for model: {self.model_name}: {str(e)}\")"
        },
        {
          "line": 562,
          "content": "            return AIResponse("
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/base_adapter.py",
      "lines": [
        {
          "line": 34,
          "content": "\"\"\""
        },
        {
          "line": 60,
          "content": "\"\"\""
        },
        {
          "line": 80,
          "content": "\"\"\""
        },
        {
          "line": 105,
          "content": "\"\"\""
        },
        {
          "line": 108,
          "content": "    \"\"\"支持的AI平台枚举\"\"\""
        },
        {
          "line": 125,
          "content": "class AIErrorType(Enum):"
        },
        {
          "line": 126,
          "content": "    \"\"\"标准化的AI错误类型枚举\"\"\""
        },
        {
          "line": 137,
          "content": "    \"\"\"标准化的AI响应数据结构\"\"\""
        },
        {
          "line": 148,
          "content": "    def to_dict(self) -> Dict[str, Any]:"
        },
        {
          "line": 149,
          "content": "        \"\"\"将响应对象转换为字典\"\"\""
        },
        {
          "line": 157,
          "content": "    \"\"\"AI客户端接口\"\"\""
        },
        {
          "line": 158,
          "content": "    def __init__(self, platform_type: AIPlatformType, model_name: str, api_key: str):"
        },
        {
          "line": 165,
          "content": "    def _apply_frequency_control(self):"
        },
        {
          "line": 166,
          "content": "        \"\"\"应用请求频率控制\"\"\""
        },
        {
          "line": 177,
          "content": "        \"\"\""
        },
        {
          "line": 179,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/deepseek_adapter.py",
      "lines": [
        {
          "line": 14,
          "content": "    \"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 31,
          "content": "        \"\"\""
        },
        {
          "line": 42,
          "content": "        \"\"\""
        },
        {
          "line": 65,
          "content": "        \"\"\"生成响应（兼容 NXM 执行引擎）\"\"\""
        },
        {
          "line": 66,
          "content": "        return self.send_prompt(prompt, **kwargs)"
        },
        {
          "line": 67,
          "content": "    def send_prompt(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 68,
          "content": "        \"\"\""
        },
        {
          "line": 76,
          "content": "        \"\"\""
        },
        {
          "line": 83,
          "content": "            return response"
        },
        {
          "line": 101,
          "content": "                    **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 104,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 107,
          "content": "            return AIResponse("
        },
        {
          "line": 116,
          "content": "    def _make_request_internal(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 117,
          "content": "        \"\"\""
        },
        {
          "line": 119,
          "content": "        \"\"\""
        },
        {
          "line": 125,
          "content": "            if not self.api_key:"
        },
        {
          "line": 131,
          "content": "            if self.enable_chinese_constraint:"
        },
        {
          "line": 157,
          "content": "            if self.mode == \"reasoner\":"
        },
        {
          "line": 173,
          "content": "            if response.status_code != 200:"
        },
        {
          "line": 189,
          "content": "                        **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 192,
          "content": "                    # Don't let logging errors affect the main response"
        },
        {
          "line": 195,
          "content": "                return AIResponse("
        },
        {
          "line": 213,
          "content": "            if choices:"
        },
        {
          "line": 231,
          "content": "                    **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 234,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 238,
          "content": "            return AIResponse("
        },
        {
          "line": 265,
          "content": "                    **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 268,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 289,
          "content": "                    error_type=error_type if error_type else AIErrorType.UNKNOWN_ERROR,"
        },
        {
          "line": 292,
          "content": "                    **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 295,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 298,
          "content": "            # Re-raise the exception to trigger circuit breaker for connection-related errors"
        },
        {
          "line": 299,
          "content": "            if isinstance(e, (requests.exceptions.ConnectionError, requests.exceptions.Timeout)):"
        },
        {
          "line": 302,
          "content": "            return AIResponse("
        },
        {
          "line": 328,
          "content": "                    **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 331,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 334,
          "content": "            return AIResponse("
        },
        {
          "line": 360,
          "content": "                    **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 363,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 366,
          "content": "            # Re-raise the exception to trigger circuit breaker for critical errors"
        },
        {
          "line": 367,
          "content": "            if isinstance(e, (ConnectionError, TimeoutError)):"
        },
        {
          "line": 370,
          "content": "            return AIResponse("
        },
        {
          "line": 379,
          "content": "    def _map_request_exception(self, e: requests.RequestException) -> AIErrorType:"
        },
        {
          "line": 380,
          "content": "        \"\"\"将请求异常映射到标准错误类型\"\"\""
        },
        {
          "line": 394,
          "content": "        \"\"\""
        },
        {
          "line": 400,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/manager.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "AI Manager for GEO Content Quality Validator"
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 24,
          "content": "    \"\"\"Centralized manager for AI providers with configuration and routing capabilities\"\"\""
        },
        {
          "line": 26,
          "content": "    def __init__(self, max_workers=5):"
        },
        {
          "line": 32,
          "content": "    def _load_config(self) -> Dict[str, str]:"
        },
        {
          "line": 33,
          "content": "        \"\"\"Load configuration from environment variables or config file\"\"\""
        },
        {
          "line": 48,
          "content": "        \"\"\"Initialize all available AI providers based on configuration\"\"\""
        },
        {
          "line": 50,
          "content": "        if self.config['deepseek_api_key']:"
        },
        {
          "line": 58,
          "content": "        if self.config['doubao_api_key']:"
        },
        {
          "line": 66,
          "content": "        if self.config['yuanbao_api_key']:"
        },
        {
          "line": 74,
          "content": "        if self.config['qwen_api_key']:"
        },
        {
          "line": 82,
          "content": "        if self.config['ernie_api_key']:"
        },
        {
          "line": 90,
          "content": "        if self.config['kimi_api_key']:"
        },
        {
          "line": 99,
          "content": "        if self.config['mock_enabled'] and not self.providers:"
        },
        {
          "line": 102,
          "content": "    def _register_mock_providers(self):"
        },
        {
          "line": 103,
          "content": "        \"\"\"Register mock providers for testing when no real API keys are available\"\"\""
        },
        {
          "line": 119,
          "content": "        \"\"\""
        },
        {
          "line": 125,
          "content": "            timeout: Maximum time to wait for all queries"
        },
        {
          "line": 126,
          "content": "            user_id: Optional user identifier for tracking"
        },
        {
          "line": 127,
          "content": "            tenant_id: Optional tenant identifier for isolation"
        },
        {
          "line": 131,
          "content": "            List of AIResponse objects from all providers"
        },
        {
          "line": 132,
          "content": "        \"\"\""
        },
        {
          "line": 133,
          "content": "        # Record usage for commercial hooks"
        },
        {
          "line": 139,
          "content": "            # Submit tasks for each provider"
        },
        {
          "line": 172,
          "content": "        \"\"\""
        },
        {
          "line": 174,
          "content": "        \"\"\""
        },
        {
          "line": 187,
          "content": "        \"\"\""
        },
        {
          "line": 188,
          "content": "        Record usage for commercial tracking and tenant isolation"
        },
        {
          "line": 189,
          "content": "        \"\"\""
        },
        {
          "line": 202,
          "content": "        \"\"\"Get list of available providers\"\"\""
        },
        {
          "line": 203,
          "content": "        return list(self.providers.keys())"
        },
        {
          "line": 205,
          "content": "    def is_provider_available(self, provider_type: AIPlatformType) -> bool:"
        },
        {
          "line": 206,
          "content": "        \"\"\"Check if a specific provider is available\"\"\""
        },
        {
          "line": 210,
          "content": "        \"\"\"Validate configuration for all registered providers\"\"\""
        },
        {
          "line": 212,
          "content": "        for provider_type, provider in self.providers.items():"
        },
        {
          "line": 214,
          "content": "                # Since validate_config might not exist in all providers, we'll just check if API key is set"
        },
        {
          "line": 217,
          "content": "                api_logger.error(f\"Error validating config for {provider_type}: {str(e)}\")"
        },
        {
          "line": 220,
          "content": "        return results"
        },
        {
          "line": 223,
          "content": "# Mock provider for testing (to be used when real API keys are not available)"
        },
        {
          "line": 224,
          "content": "class MockProvider(AIClient):"
        },
        {
          "line": 225,
          "content": "    \"\"\"Mock provider for testing purposes\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/platform_balancer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "Provides intelligent routing and health monitoring for AI platforms"
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\"平台健康状态枚举\"\"\""
        },
        {
          "line": 22,
          "content": "class PlatformMetrics:"
        },
        {
          "line": 23,
          "content": "    \"\"\"平台性能指标\"\"\""
        },
        {
          "line": 32,
          "content": "        \"\"\"添加响应时间记录\"\"\""
        },
        {
          "line": 35,
          "content": "        if len(self.response_times) > 100:"
        },
        {
          "line": 38,
          "content": "    def get_avg_response_time(self) -> float:"
        },
        {
          "line": 39,
          "content": "        \"\"\"获取平均响应时间\"\"\""
        },
        {
          "line": 45,
          "content": "        \"\"\"获取成功率\"\"\""
        },
        {
          "line": 47,
          "content": "        if total_requests == 0:"
        },
        {
          "line": 48,
          "content": "            return 1.0  # 默认成功率为100%"
        },
        {
          "line": 49,
          "content": "        return self.success_count / total_requests"
        },
        {
          "line": 51,
          "content": "    def update_health_status(self):"
        },
        {
          "line": 52,
          "content": "        \"\"\"更新健康状态\"\"\""
        },
        {
          "line": 66,
          "content": "    \"\"\"AI平台负载均衡器\"\"\""
        },
        {
          "line": 68,
          "content": "    def __init__(self):"
        },
        {
          "line": 74,
          "content": "    def get_or_create_metrics(self, platform_name: str) -> PlatformMetrics:"
        },
        {
          "line": 75,
          "content": "        \"\"\"获取或创建平台指标对象\"\"\""
        },
        {
          "line": 82,
          "content": "        \"\"\"记录请求结果\"\"\""
        },
        {
          "line": 87,
          "content": "            if success:"
        },
        {
          "line": 94,
          "content": "    def get_platform_priority_list(self) -> List[Tuple[str, float]]:"
        },
        {
          "line": 95,
          "content": "        \"\"\"获取平台优先级列表，基于健康状态和性能\"\"\""
        },
        {
          "line": 134,
          "content": "        \"\"\"从可用平台中选择最佳平台\"\"\""
        },
        {
          "line": 135,
          "content": "        if not available_platforms:"
        },
        {
          "line": 136,
          "content": "            return None"
        },
        {
          "line": 142,
          "content": "        filtered_priorities = [(name, score) for name, score in all_priorities"
        },
        {
          "line": 143,
          "content": "                              if name in available_platforms]"
        },
        {
          "line": 145,
          "content": "        if filtered_priorities:"
        },
        {
          "line": 147,
          "content": "            return filtered_priorities[0][0]"
        },
        {
          "line": 150,
          "content": "            return available_platforms[0] if available_platforms else None"
        },
        {
          "line": 152,
          "content": "    def get_healthy_platforms(self) -> List[str]:"
        },
        {
          "line": 153,
          "content": "        \"\"\"获取健康状态的平台列表\"\"\""
        },
        {
          "line": 165,
          "content": "        \"\"\"启动健康监控线程\"\"\""
        },
        {
          "line": 166,
          "content": "        def health_check_worker():"
        },
        {
          "line": 167,
          "content": "            while True:"
        },
        {
          "line": 178,
          "content": "    def perform_health_check(self):"
        },
        {
          "line": 179,
          "content": "        \"\"\"执行健康检查\"\"\""
        },
        {
          "line": 194,
          "content": "    \"\"\"获取全局负载均衡器实例\"\"\""
        },
        {
          "line": 195,
          "content": "    return balancer"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/base.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Base AI Provider Module for GEO Content Quality Validator"
        },
        {
          "line": 3,
          "content": "Defines the abstract base class and core infrastructure for AI model integration"
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\"Enumeration of supported AI provider types\"\"\""
        },
        {
          "line": 29,
          "content": "class StandardAIResponse:"
        },
        {
          "line": 30,
          "content": "    \"\"\"Standardized response structure from AI providers\"\"\""
        },
        {
          "line": 43,
          "content": "    \"\"\"Abstract base class for all AI providers implementing the unified interface\"\"\""
        },
        {
          "line": 45,
          "content": "    def __init__(self, api_key: str, model_name: str, **kwargs):"
        },
        {
          "line": 46,
          "content": "        \"\"\""
        },
        {
          "line": 53,
          "content": "        \"\"\""
        },
        {
          "line": 60,
          "content": "    async def initialize_session(self):"
        },
        {
          "line": 61,
          "content": "        \"\"\"Initialize the aiohttp session for async requests\"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\"Close the aiohttp session\"\"\""
        },
        {
          "line": 68,
          "content": "        if self.session:"
        },
        {
          "line": 69,
          "content": "            await self.session.close()"
        },
        {
          "line": 73,
          "content": "    async def query(self, prompt: str, **kwargs) -> StandardAIResponse:"
        },
        {
          "line": 74,
          "content": "        \"\"\""
        },
        {
          "line": 83,
          "content": "        \"\"\""
        },
        {
          "line": 87,
          "content": "    def validate_config(self) -> bool:"
        },
        {
          "line": 88,
          "content": "        \"\"\""
        },
        {
          "line": 93,
          "content": "        \"\"\""
        },
        {
          "line": 96,
          "content": "    def get_model_info(self) -> Dict[str, Any]:"
        },
        {
          "line": 97,
          "content": "        \"\"\""
        },
        {
          "line": 102,
          "content": "        \"\"\""
        },
        {
          "line": 103,
          "content": "        return {"
        },
        {
          "line": 110,
          "content": "    def get_provider_type(self) -> AIProviderType:"
        },
        {
          "line": 111,
          "content": "        \"\"\""
        },
        {
          "line": 116,
          "content": "        \"\"\""
        },
        {
          "line": 120,
          "content": "class AsyncAIManager:"
        },
        {
          "line": 121,
          "content": "    \"\"\"Manages multiple AI providers with async concurrency and error handling\"\"\""
        },
        {
          "line": 128,
          "content": "        \"\"\"Register an AI provider instance\"\"\""
        },
        {
          "line": 131,
          "content": "    async def query_all_concurrent(self, prompt: str, provider_types: List[AIProviderType],"
        },
        {
          "line": 133,
          "content": "        \"\"\""
        },
        {
          "line": 144,
          "content": "        \"\"\""
        },
        {
          "line": 145,
          "content": "        # Create tasks for all providers"
        },
        {
          "line": 147,
          "content": "        for provider_type in provider_types:"
        },
        {
          "line": 148,
          "content": "            if provider_type in self.providers:"
        },
        {
          "line": 153,
          "content": "        if not tasks:"
        },
        {
          "line": 154,
          "content": "            return []"
        },
        {
          "line": 156,
          "content": "        # Wait for all tasks to complete (with timeout)"
        },
        {
          "line": 158,
          "content": "            responses = await asyncio.wait_for(asyncio.gather(*tasks, return_exceptions=True), timeout=timeout)"
        },
        {
          "line": 160,
          "content": "            # Even if timeout occurs, return whatever responses we got"
        },
        {
          "line": 162,
          "content": "            for task in tasks:"
        },
        {
          "line": 163,
          "content": "                if not task.done():"
        },
        {
          "line": 165,
          "content": "            responses = [None] * len(tasks)  # Placeholder for cancelled tasks"
        },
        {
          "line": 169,
          "content": "        for i, response in enumerate(responses):"
        },
        {
          "line": 170,
          "content": "            if isinstance(response, Exception):"
        },
        {
          "line": 171,
          "content": "                # Handle exception from the task"
        },
        {
          "line": 180,
          "content": "            elif response is None:"
        },
        {
          "line": 193,
          "content": "        return processed_responses"
        },
        {
          "line": 195,
          "content": "    async def _query_with_timeout(self, provider: BaseAIProvider, prompt: str, timeout: float, **kwargs):"
        },
        {
          "line": 196,
          "content": "        \"\"\"Helper method to query a provider with timeout\"\"\""
        },
        {
          "line": 210,
          "content": "        \"\"\"Close all active provider sessions\"\"\""
        },
        {
          "line": 211,
          "content": "        for provider in self.providers.values():"
        },
        {
          "line": 212,
          "content": "            await provider.close_session()"
        },
        {
          "line": 216,
          "content": "if __name__ == \"__main__\":"
        },
        {
          "line": 217,
          "content": "    import asyncio"
        },
        {
          "line": 219,
          "content": "    # Example implementation of a mock provider for testing"
        },
        {
          "line": 220,
          "content": "    class MockProvider(BaseAIProvider):"
        },
        {
          "line": 221,
          "content": "        def __init__(self, api_key: str, model_name: str = \"mock-model\", **kwargs):"
        },
        {
          "line": 224,
          "content": "        async def query(self, prompt: str, **kwargs) -> StandardAIResponse:"
        },
        {
          "line": 226,
          "content": "            await asyncio.sleep(1)"
        },
        {
          "line": 227,
          "content": "            return StandardAIResponse("
        },
        {
          "line": 237,
          "content": "        def validate_config(self) -> bool:"
        },
        {
          "line": 238,
          "content": "            return bool(self.api_key)"
        },
        {
          "line": 240,
          "content": "        def get_provider_type(self) -> AIProviderType:"
        },
        {
          "line": 241,
          "content": "            return AIProviderType.CHATGPT  # Just for testing"
        },
        {
          "line": 243,
          "content": "    async def test_async_manager():"
        },
        {
          "line": 247,
          "content": "        for i in range(3):"
        },
        {
          "line": 249,
          "content": "            manager.register_provider(AIProviderType(f\"chatgpt\"), provider)  # Using same type for simplicity"
        },
        {
          "line": 252,
          "content": "        responses = await manager.query_all_concurrent("
        },
        {
          "line": 253,
          "content": "            \"Test prompt for concurrent querying\","
        },
        {
          "line": 258,
          "content": "        for i, resp in enumerate(responses):"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/erniebot_adapter.py",
      "lines": [
        {
          "line": 16,
          "content": "    \"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\""
        },
        {
          "line": 37,
          "content": "        \"\"\"获取访问令牌\"\"\""
        },
        {
          "line": 38,
          "content": "        import time"
        },
        {
          "line": 42,
          "content": "        if self.access_token and current_time < self.token_expires_at:"
        },
        {
          "line": 43,
          "content": "            return self.access_token"
        },
        {
          "line": 62,
          "content": "            return self.access_token"
        },
        {
          "line": 67,
          "content": "    def generate_response(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 68,
          "content": "        \"\"\"生成响应（兼容 NXM 执行引擎）\"\"\""
        },
        {
          "line": 71,
          "content": "        \"\"\""
        },
        {
          "line": 73,
          "content": "        \"\"\""
        },
        {
          "line": 130,
          "content": "                    # Don't let logging errors affect the main response"
        },
        {
          "line": 164,
          "content": "                    # Don't let logging errors affect the main response"
        },
        {
          "line": 206,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 239,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 253,
          "content": "        \"\"\"将文心一言的错误码映射到标准错误类型\"\"\""
        },
        {
          "line": 254,
          "content": "        if error_code in [110, 111]:  # Invalid API key"
        },
        {
          "line": 255,
          "content": "            return AIErrorType.INVALID_API_KEY"
        },
        {
          "line": 256,
          "content": "        elif error_code == 18:  # Quota exceeded"
        },
        {
          "line": 257,
          "content": "            return AIErrorType.INSUFFICIENT_QUOTA"
        },
        {
          "line": 258,
          "content": "        elif error_code in [336003, 336100]:  # Content safety"
        },
        {
          "line": 259,
          "content": "            return AIErrorType.CONTENT_SAFETY"
        },
        {
          "line": 260,
          "content": "        elif error_code == 17:  # Rate limit"
        },
        {
          "line": 261,
          "content": "            return AIErrorType.RATE_LIMIT_EXCEEDED"
        },
        {
          "line": 262,
          "content": "        return AIErrorType.UNKNOWN_ERROR"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/ai_adapters/chatgpt_adapter.py",
      "lines": [
        {
          "line": 16,
          "content": "    \"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\""
        },
        {
          "line": 34,
          "content": "        \"\"\"生成响应（兼容 NXM 执行引擎）\"\"\""
        },
        {
          "line": 35,
          "content": "        return self.send_prompt(prompt, **kwargs)"
        },
        {
          "line": 36,
          "content": "    def send_prompt(self, prompt: str, **kwargs) -> AIResponse:"
        },
        {
          "line": 37,
          "content": "        \"\"\""
        },
        {
          "line": 39,
          "content": "        \"\"\""
        },
        {
          "line": 45,
          "content": "        temperature = kwargs.get('temperature', chatgpt_config.default_temperature if chatgpt_config else 0.7)"
        },
        {
          "line": 46,
          "content": "        max_tokens = kwargs.get('max_tokens', chatgpt_config.default_max_tokens if chatgpt_config else 1000)"
        },
        {
          "line": 47,
          "content": "        timeout = kwargs.get('timeout', chatgpt_config.timeout if chatgpt_config else 30)"
        },
        {
          "line": 73,
          "content": "            if response_data and response_data.get(\"choices\"):"
        },
        {
          "line": 75,
          "content": "                tokens_used = response_data[\"usage\"][\"total_tokens\"] if response_data.get(\"usage\") else 0"
        },
        {
          "line": 90,
          "content": "                        **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 93,
          "content": "                    # Don't let logging errors affect the main response"
        },
        {
          "line": 96,
          "content": "                return AIResponse("
        },
        {
          "line": 120,
          "content": "                        error_type=error_type if error_type else AIErrorType.UNKNOWN_ERROR,"
        },
        {
          "line": 123,
          "content": "                        **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 126,
          "content": "                    # Don't let logging errors affect the main response"
        },
        {
          "line": 129,
          "content": "                return AIResponse("
        },
        {
          "line": 143,
          "content": "            if hasattr(e, 'response') and e.response is not None:"
        },
        {
          "line": 145,
          "content": "                if status_code == 401:"
        },
        {
          "line": 147,
          "content": "                elif status_code == 429:"
        },
        {
          "line": 149,
          "content": "                elif status_code >= 500:"
        },
        {
          "line": 151,
          "content": "                elif status_code == 403:"
        },
        {
          "line": 166,
          "content": "                    error_type=error_type if error_type else AIErrorType.REQUEST_EXCEPTION,"
        },
        {
          "line": 169,
          "content": "                    **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 172,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 176,
          "content": "            return AIResponse("
        },
        {
          "line": 202,
          "content": "                    **kwargs  # Pass any additional context from kwargs"
        },
        {
          "line": 205,
          "content": "                # Don't let logging errors affect the main response"
        },
        {
          "line": 209,
          "content": "            return AIResponse("
        },
        {
          "line": 218,
          "content": "    def _map_error_message(self, error_message: str) -> AIErrorType:"
        },
        {
          "line": 219,
          "content": "        \"\"\"将ChatGPT的错误信息映射到标准错误类型\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/config/config_validator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\"配置验证结果\"\"\""
        },
        {
          "line": 25,
          "content": "    def __init__(self):"
        },
        {
          "line": 30,
          "content": "    def add_error(self, message):"
        },
        {
          "line": 33,
          "content": "    def add_warning(self, message):"
        },
        {
          "line": 36,
          "content": "    def add_info(self, message):"
        },
        {
          "line": 39,
          "content": "    def is_valid(self):"
        },
        {
          "line": 40,
          "content": "        return len(self.errors) == 0"
        },
        {
          "line": 42,
          "content": "    def print_report(self):"
        },
        {
          "line": 43,
          "content": "        \"\"\"打印验证报告\"\"\""
        },
        {
          "line": 75,
          "content": "    \"\"\"验证配置完整性\"\"\""
        },
        {
          "line": 85,
          "content": "    for key, description in required_configs.items():"
        },
        {
          "line": 87,
          "content": "        if not value:"
        },
        {
          "line": 89,
          "content": "        elif key == 'SECRET_KEY' and len(value) < 16:"
        },
        {
          "line": 105,
          "content": "    for key, name in ai_platforms.items():"
        },
        {
          "line": 107,
          "content": "        if value and value != '${' + key + '}':"
        },
        {
          "line": 112,
          "content": "    if not configured_platforms:"
        },
        {
          "line": 117,
          "content": "    if unavailable_platforms:"
        },
        {
          "line": 122,
          "content": "    if doubao_api_key and doubao_api_key != '${ARK_API_KEY}':"
        },
        {
          "line": 124,
          "content": "        for i in range(1, 6):"
        },
        {
          "line": 126,
          "content": "            if model_id:"
        },
        {
          "line": 131,
          "content": "        if not priority_models and not default_model:"
        },
        {
          "line": 133,
          "content": "        elif priority_models:"
        },
        {
          "line": 135,
          "content": "        elif default_model:"
        },
        {
          "line": 140,
          "content": "    if debug_mode:"
        },
        {
          "line": 143,
          "content": "    return result"
        },
        {
          "line": 146,
          "content": "def print_config_status():"
        },
        {
          "line": 147,
          "content": "    \"\"\"打印配置状态\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/sqlcipher_evaluation.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "\"\"\""
        },
        {
          "line": 36,
          "content": "    \"\"\"SQLCipher 评估器\"\"\""
        },
        {
          "line": 38,
          "content": "    def __init__(self, test_db_path: str = 'data/test_encrypted.db'):"
        },
        {
          "line": 39,
          "content": "        \"\"\""
        },
        {
          "line": 44,
          "content": "        \"\"\""
        },
        {
          "line": 52,
          "content": "    def check_sqlcipher_installed(self) -> bool:"
        },
        {
          "line": 53,
          "content": "        \"\"\"检查 SQLCipher 是否安装\"\"\""
        },
        {
          "line": 80,
          "content": "        \"\"\"测试加密功能\"\"\""
        },
        {
          "line": 84,
          "content": "            import sqlcipher3"
        },
        {
          "line": 96,
          "content": "            \"\"\")"
        },
        {
          "line": 151,
          "content": "        \"\"\"性能基准测试\"\"\""
        },
        {
          "line": 155,
          "content": "            import sqlcipher3"
        },
        {
          "line": 165,
          "content": "            for i in range(test_iterations):"
        },
        {
          "line": 172,
          "content": "                for j in range(num_records):"
        },
        {
          "line": 194,
          "content": "            for i in range(test_iterations):"
        },
        {
          "line": 202,
          "content": "                for j in range(num_records):"
        },
        {
          "line": 236,
          "content": "            if overhead < 10:"
        },
        {
          "line": 239,
          "content": "            elif overhead < 20:"
        },
        {
          "line": 246,
          "content": "            return {"
        },
        {
          "line": 262,
          "content": "            return {'status': 'FAIL'}"
        },
        {
          "line": 264,
          "content": "    def test_compatibility(self) -> Dict[str, Any]:"
        },
        {
          "line": 265,
          "content": "        \"\"\"兼容性测试\"\"\""
        },
        {
          "line": 295,
          "content": "            \"\"\")"
        },
        {
          "line": 299,
          "content": "            \"\"\")"
        },
        {
          "line": 325,
          "content": "        \"\"\"运行完整评估\"\"\""
        },
        {
          "line": 331,
          "content": "        if not self.check_sqlcipher_installed():"
        },
        {
          "line": 337,
          "content": "            return self.results"
        },
        {
          "line": 356,
          "content": "            'status': 'PASS' if all_passed else 'FAIL',"
        },
        {
          "line": 368,
          "content": "        return self.results"
        },
        {
          "line": 370,
          "content": "    def _generate_recommendation(self, performance_result: Dict[str, Any]) -> str:"
        },
        {
          "line": 371,
          "content": "        \"\"\"生成推荐建议\"\"\""
        },
        {
          "line": 382,
          "content": "        \"\"\"生成下一步建议\"\"\""
        },
        {
          "line": 383,
          "content": "        return ["
        },
        {
          "line": 391,
          "content": "    def _save_report(self):"
        },
        {
          "line": 392,
          "content": "        \"\"\"保存评估报告\"\"\""
        },
        {
          "line": 404,
          "content": "    \"\"\"主函数\"\"\""
        },
        {
          "line": 415,
          "content": "    for i, step in enumerate(results['summary']['next_steps'], 1):"
        },
        {
          "line": 419,
          "content": "    return 0 if results['summary']['status'] == 'PASS' else 1"
        },
        {
          "line": 422,
          "content": "if __name__ == '__main__':"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/key_manager.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "\"\"\""
        },
        {
          "line": 34,
          "content": "    \"\"\"密钥管理器\"\"\""
        },
        {
          "line": 36,
          "content": "    def __init__(self, key_vault_path: str = 'data/key_vault.json'):"
        },
        {
          "line": 37,
          "content": "        \"\"\""
        },
        {
          "line": 42,
          "content": "        \"\"\""
        },
        {
          "line": 47,
          "content": "    def _load_key_vault(self) -> Dict[str, Any]:"
        },
        {
          "line": 48,
          "content": "        \"\"\"加载密钥库\"\"\""
        },
        {
          "line": 77,
          "content": "        \"\"\"保存密钥库\"\"\""
        },
        {
          "line": 94,
          "content": "    def generate_key(self, key_id: Optional[str] = None) -> Dict[str, Any]:"
        },
        {
          "line": 95,
          "content": "        \"\"\""
        },
        {
          "line": 103,
          "content": "        \"\"\""
        },
        {
          "line": 105,
          "content": "        if key_id is None:"
        },
        {
          "line": 127,
          "content": "        if self.key_vault['current_key_id'] is None:"
        },
        {
          "line": 134,
          "content": "        return key_info"
        },
        {
          "line": 136,
          "content": "    def get_current_key(self) -> Optional[str]:"
        },
        {
          "line": 137,
          "content": "        \"\"\"获取当前密钥\"\"\""
        },
        {
          "line": 155,
          "content": "        \"\"\"获取指定密钥\"\"\""
        },
        {
          "line": 156,
          "content": "        if key_id in self.key_vault['keys']:"
        },
        {
          "line": 158,
          "content": "            return key_info['key'].encode()"
        },
        {
          "line": 159,
          "content": "        return None"
        },
        {
          "line": 161,
          "content": "    def rotate_key(self) -> Dict[str, Any]:"
        },
        {
          "line": 162,
          "content": "        \"\"\""
        },
        {
          "line": 167,
          "content": "        \"\"\""
        },
        {
          "line": 175,
          "content": "        if old_key_id:"
        },
        {
          "line": 194,
          "content": "        return stats"
        },
        {
          "line": 196,
          "content": "    def backup_keys(self, backup_path: str) -> str:"
        },
        {
          "line": 197,
          "content": "        \"\"\""
        },
        {
          "line": 205,
          "content": "        \"\"\""
        },
        {
          "line": 230,
          "content": "        return str(backup_file)"
        },
        {
          "line": 232,
          "content": "    def restore_keys(self, backup_path: str) -> bool:"
        },
        {
          "line": 233,
          "content": "        \"\"\""
        },
        {
          "line": 241,
          "content": "        \"\"\""
        },
        {
          "line": 244,
          "content": "        if not backup_file.exists():"
        },
        {
          "line": 246,
          "content": "            return False"
        },
        {
          "line": 264,
          "content": "            return True"
        },
        {
          "line": 267,
          "content": "            return False"
        },
        {
          "line": 269,
          "content": "    def get_key_stats(self) -> Dict[str, Any]:"
        },
        {
          "line": 270,
          "content": "        \"\"\"获取密钥统计信息\"\"\""
        },
        {
          "line": 292,
          "content": "        \"\"\"审计密钥\"\"\""
        },
        {
          "line": 295,
          "content": "        for key_id, key_info in self.key_vault['keys'].items():"
        },
        {
          "line": 297,
          "content": "            if key_info['status'] == 'active':"
        },
        {
          "line": 301,
          "content": "                if days_until_expiry < 0:"
        },
        {
          "line": 309,
          "content": "                elif days_until_expiry < self.key_vault['rotation_policy']['warning_days']:"
        },
        {
          "line": 318,
          "content": "        return audit_logs"
        },
        {
          "line": 325,
          "content": "def get_key_manager() -> KeyManager:"
        },
        {
          "line": 326,
          "content": "    \"\"\"获取密钥管理器实例\"\"\""
        },
        {
          "line": 334,
          "content": "    \"\"\"初始化加密系统\"\"\""
        },
        {
          "line": 338,
          "content": "    if key_manager.get_current_key() is None:"
        },
        {
          "line": 343,
          "content": "    return key_manager.get_key_stats()"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/auth.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 42,
          "content": "    \"\"\"身份验证错误\"\"\""
        },
        {
          "line": 46,
          "content": "class AuthorizationError(Exception):"
        },
        {
          "line": 47,
          "content": "    \"\"\"授权错误\"\"\""
        },
        {
          "line": 52,
          "content": "    \"\"\"JWT管理器\"\"\""
        },
        {
          "line": 54,
          "content": "    def __init__(self, secret_key: str = None, algorithm: str = 'HS256'):"
        },
        {
          "line": 55,
          "content": "        if jwt is None:"
        },
        {
          "line": 56,
          "content": "            raise RuntimeError(\"PyJWT is required for JWT functionality. Please install it with 'pip install PyJWT'\")"
        },
        {
          "line": 61,
          "content": "    def generate_token(self, user_id: str, expires_delta: timedelta = None, additional_claims: Dict = None) -> str:"
        },
        {
          "line": 62,
          "content": "        \"\"\"生成JWT令牌\"\"\""
        },
        {
          "line": 83,
          "content": "        \"\"\"解码JWT令牌\"\"\""
        },
        {
          "line": 84,
          "content": "        if jwt is None:"
        },
        {
          "line": 85,
          "content": "            raise RuntimeError(\"PyJWT is required for JWT functionality\")"
        },
        {
          "line": 89,
          "content": "            return payload"
        },
        {
          "line": 95,
          "content": "    def verify_token(self, token: str, expected_user_id: str = None) -> bool:"
        },
        {
          "line": 96,
          "content": "        \"\"\"验证JWT令牌\"\"\""
        },
        {
          "line": 110,
          "content": "    \"\"\"密码哈希器\"\"\""
        },
        {
          "line": 113,
          "content": "    def hash_password(password: str, salt: str = None) -> str:"
        },
        {
          "line": 114,
          "content": "        \"\"\"哈希密码\"\"\""
        },
        {
          "line": 124,
          "content": "        \"\"\"验证密码\"\"\""
        },
        {
          "line": 125,
          "content": "        if '$' not in hashed_password:"
        },
        {
          "line": 126,
          "content": "            return False"
        },
        {
          "line": 131,
          "content": "        return secrets.compare_digest(pwd_hash, stored_hash)"
        },
        {
          "line": 134,
          "content": "class AccessControl:"
        },
        {
          "line": 135,
          "content": "    \"\"\"访问控制\"\"\""
        },
        {
          "line": 146,
          "content": "        \"\"\"分配角色给用户\"\"\""
        },
        {
          "line": 147,
          "content": "        if role not in self.role_permissions:"
        },
        {
          "line": 151,
          "content": "    def has_permission(self, user_id: str, permission: str) -> bool:"
        },
        {
          "line": 152,
          "content": "        \"\"\"检查用户是否有特定权限\"\"\""
        },
        {
          "line": 161,
          "content": "        \"\"\"装饰器：要求特定权限\"\"\""
        },
        {
          "line": 162,
          "content": "        def decorator(f):"
        },
        {
          "line": 164,
          "content": "            def decorated_function(*args, **kwargs):"
        },
        {
          "line": 167,
          "content": "                if not user_id:"
        },
        {
          "line": 168,
          "content": "                    return jsonify({'error': '未认证'}), 401"
        },
        {
          "line": 170,
          "content": "                if not self.has_permission(user_id, permission):"
        },
        {
          "line": 171,
          "content": "                    return jsonify({'error': '无权限访问'}), 403"
        },
        {
          "line": 173,
          "content": "                return f(*args, **kwargs)"
        },
        {
          "line": 174,
          "content": "            return decorated_function"
        },
        {
          "line": 175,
          "content": "        return decorator"
        },
        {
          "line": 178,
          "content": "def require_auth(f):"
        },
        {
          "line": 179,
          "content": "    \"\"\"装饰器：要求身份验证（支持JWT和微信会话）\"\"\""
        },
        {
          "line": 235,
          "content": "    \"\"\"装饰器：可选身份验证（即使认证失败也继续执行）\"\"\""
        },
        {
          "line": 237,
          "content": "    def decorated_function(*args, **kwargs):"
        },
        {
          "line": 242,
          "content": "            if jwt:"
        },
        {
          "line": 244,
          "content": "                if auth_header and auth_header.startswith('Bearer '):"
        },
        {
          "line": 253,
          "content": "            if not user_id:"
        },
        {
          "line": 255,
          "content": "                if wechat_openid:"
        },
        {
          "line": 259,
          "content": "            if not user_id and request.is_json:"
        },
        {
          "line": 261,
          "content": "                if data and 'userOpenid' in data:"
        },
        {
          "line": 270,
          "content": "            g.user_id = user_id if user_id is not None else 'anonymous'"
        },
        {
          "line": 272,
          "content": "            g.auth_method = 'jwt' if user_id and jwt and request.headers.get('Authorization', '').startswith('Bearer ') else 'wechat_session' if user_id else 'anonymous'"
        },
        {
          "line": 281,
          "content": "        return f(*args, **kwargs)"
        },
        {
          "line": 283,
          "content": "    return decorated_function"
        },
        {
          "line": 286,
          "content": "def get_current_user_id() -> Optional[str]:"
        },
        {
          "line": 287,
          "content": "    \"\"\"获取当前认证用户的ID\"\"\""
        },
        {
          "line": 292,
          "content": "    \"\"\"获取认证方法\"\"\""
        },
        {
          "line": 293,
          "content": "    return getattr(g, 'auth_method', 'none')"
        },
        {
          "line": 296,
          "content": "def is_authenticated() -> bool:"
        },
        {
          "line": 297,
          "content": "    \"\"\"检查用户是否已认证\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/rate_limiting.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\"基础限流器\"\"\""
        },
        {
          "line": 21,
          "content": "    def __init__(self):"
        },
        {
          "line": 24,
          "content": "    def is_allowed(self, key: str, limit: int, window: int) -> bool:"
        },
        {
          "line": 28,
          "content": "class SlidingWindowRateLimiter(RateLimiter):"
        },
        {
          "line": 29,
          "content": "    \"\"\"滑动窗口限流器\"\"\""
        },
        {
          "line": 36,
          "content": "        \"\"\"检查请求是否被允许（滑动窗口算法）\"\"\""
        },
        {
          "line": 42,
          "content": "            while window_queue and now - window_queue[0] > window:"
        },
        {
          "line": 46,
          "content": "            if len(window_queue) < limit:"
        },
        {
          "line": 48,
          "content": "                return True"
        },
        {
          "line": 50,
          "content": "                return False"
        },
        {
          "line": 53,
          "content": "class TokenBucketRateLimiter(RateLimiter):"
        },
        {
          "line": 54,
          "content": "    \"\"\"令牌桶限流器\"\"\""
        },
        {
          "line": 61,
          "content": "        \"\"\"检查请求是否被允许（令牌桶算法）\"\"\""
        },
        {
          "line": 65,
          "content": "            if key not in self.buckets:"
        },
        {
          "line": 80,
          "content": "            if bucket['tokens'] >= 1:"
        },
        {
          "line": 82,
          "content": "                return True"
        },
        {
          "line": 84,
          "content": "                return False"
        },
        {
          "line": 87,
          "content": "class IPBasedRateLimiter:"
        },
        {
          "line": 88,
          "content": "    \"\"\"基于IP的限流器\"\"\""
        },
        {
          "line": 100,
          "content": "        \"\"\"获取客户端IP地址\"\"\""
        },
        {
          "line": 101,
          "content": "        if request.headers.getlist(\"X-Forwarded-For\"):"
        },
        {
          "line": 103,
          "content": "        elif request.headers.get('X-Real-IP'):"
        },
        {
          "line": 107,
          "content": "        return ip"
        },
        {
          "line": 109,
          "content": "    def is_allowed(self,"
        },
        {
          "line": 113,
          "content": "        \"\"\"检查IP是否被允许发送请求\"\"\""
        },
        {
          "line": 134,
          "content": "        \"\"\"获取限流相关的HTTP头信息\"\"\""
        },
        {
          "line": 138,
          "content": "        if limit_type == 'requests_per_minute':"
        },
        {
          "line": 140,
          "content": "        elif limit_type == 'requests_per_hour':"
        },
        {
          "line": 142,
          "content": "        elif limit_type == 'requests_per_day':"
        },
        {
          "line": 153,
          "content": "        return {"
        },
        {
          "line": 160,
          "content": "class EndpointRateLimiter:"
        },
        {
          "line": 161,
          "content": "    \"\"\"端点级别的限流器\"\"\""
        },
        {
          "line": 177,
          "content": "        \"\"\"检查端点请求是否被允许\"\"\""
        },
        {
          "line": 178,
          "content": "        if endpoint is None:"
        },
        {
          "line": 181,
          "content": "        if custom_limit and custom_window:"
        },
        {
          "line": 191,
          "content": "        return self.sliding_window_limiter.is_allowed(key, limit, window)"
        },
        {
          "line": 193,
          "content": "    def get_rate_limit_headers(self, endpoint: str = None) -> Dict[str, str]:"
        },
        {
          "line": 194,
          "content": "        \"\"\"获取端点限流相关的HTTP头信息\"\"\""
        },
        {
          "line": 216,
          "content": "    \"\"\"组合限流器 - 同时应用IP和端点级别的限流\"\"\""
        },
        {
          "line": 218,
          "content": "    def __init__(self):"
        },
        {
          "line": 222,
          "content": "    def is_allowed(self,"
        },
        {
          "line": 229,
          "content": "        \"\"\"检查请求是否被允许（同时检查IP和端点限制）\"\"\""
        },
        {
          "line": 244,
          "content": "    \"\"\"装饰器：应用限流\"\"\""
        },
        {
          "line": 245,
          "content": "    def decorator(f):"
        },
        {
          "line": 247,
          "content": "        def decorated_function(*args, **kwargs):"
        },
        {
          "line": 250,
          "content": "            if per == 'ip':"
        },
        {
          "line": 255,
          "content": "            elif per == 'endpoint':"
        },
        {
          "line": 267,
          "content": "            if not allowed:"
        },
        {
          "line": 268,
          "content": "                logger.warning(f\"Rate limit exceeded for {per}: {request.remote_addr} on {request.path}\")"
        },
        {
          "line": 269,
          "content": "                return jsonify({"
        },
        {
          "line": 276,
          "content": "            if hasattr(resp, 'headers'):"
        },
        {
          "line": 278,
          "content": "                for header, value in headers.items():"
        },
        {
          "line": 281,
          "content": "            return resp"
        },
        {
          "line": 282,
          "content": "        return decorated_function"
        },
        {
          "line": 283,
          "content": "    return decorator"
        },
        {
          "line": 290,
          "content": "def check_rate_limit() -> bool:"
        },
        {
          "line": 291,
          "content": "    \"\"\"检查全局限流\"\"\""
        },
        {
          "line": 296,
          "content": "    \"\"\"获取限流信息\"\"\""
        },
        {
          "line": 297,
          "content": "    return combined_limiter.ip_limiter.get_rate_limit_headers()"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/data_validator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 24,
          "content": "\"\"\""
        },
        {
          "line": 34,
          "content": "    \"\"\"验证异常类\"\"\""
        },
        {
          "line": 35,
          "content": "    def __init__(self, message: str, field: str = None, value: Any = None):"
        },
        {
          "line": 41,
          "content": "    def __str__(self):"
        },
        {
          "line": 42,
          "content": "        if self.field:"
        },
        {
          "line": 43,
          "content": "            return f\"Validation error in '{self.field}': {self.message}\""
        },
        {
          "line": 44,
          "content": "        return self.message"
        },
        {
          "line": 47,
          "content": "class DataValidator:"
        },
        {
          "line": 48,
          "content": "    \"\"\""
        },
        {
          "line": 52,
          "content": "    \"\"\""
        },
        {
          "line": 79,
          "content": "    def __init__(self, strict_mode: bool = True):"
        },
        {
          "line": 80,
          "content": "        \"\"\""
        },
        {
          "line": 85,
          "content": "        \"\"\""
        },
        {
          "line": 90,
          "content": "    def validate_task_data(self, task_data: Dict[str, Any]) -> Tuple[bool, List[str]]:"
        },
        {
          "line": 91,
          "content": "        \"\"\""
        },
        {
          "line": 99,
          "content": "        \"\"\""
        },
        {
          "line": 104,
          "content": "        for field in required_fields:"
        },
        {
          "line": 105,
          "content": "            if field not in task_data:"
        },
        {
          "line": 110,
          "content": "        for field, max_length in self.MAX_LENGTHS.items():"
        },
        {
          "line": 111,
          "content": "            if field in task_data and isinstance(task_data[field], str):"
        },
        {
          "line": 112,
          "content": "                if len(task_data[field]) > max_length:"
        },
        {
          "line": 117,
          "content": "        if 'response' in task_data:"
        },
        {
          "line": 119,
          "content": "            if not isinstance(response, str):"
        },
        {
          "line": 122,
          "content": "            elif not response.strip():"
        },
        {
          "line": 127,
          "content": "        if 'status' in task_data:"
        },
        {
          "line": 130,
          "content": "            if status not in valid_statuses:"
        },
        {
          "line": 135,
          "content": "        if 'error' in task_data and task_data['error']:"
        },
        {
          "line": 137,
          "content": "            if len(error_msg) > self.MAX_LENGTHS['error_message']:"
        },
        {
          "line": 143,
          "content": "        if errors:"
        },
        {
          "line": 145,
          "content": "            for error in errors:"
        },
        {
          "line": 148,
          "content": "        return len(errors) == 0, errors"
        },
        {
          "line": 150,
          "content": "    def validate_aggregated_results(self, aggregated_results: Dict[str, Any]) -> Tuple[bool, List[str]]:"
        },
        {
          "line": 151,
          "content": "        \"\"\""
        },
        {
          "line": 159,
          "content": "        \"\"\""
        },
        {
          "line": 163,
          "content": "        if 'main_brand' not in aggregated_results:"
        },
        {
          "line": 167,
          "content": "        if 'summary' not in aggregated_results:"
        },
        {
          "line": 170,
          "content": "            return False, errors"
        },
        {
          "line": 175,
          "content": "        for field, (min_val, max_val) in self.VALUE_RANGES.items():"
        },
        {
          "line": 176,
          "content": "            if field in summary:"
        },
        {
          "line": 178,
          "content": "                if not isinstance(value, (int, float)):"
        },
        {
          "line": 181,
          "content": "                elif not (min_val <= value <= max_val):"
        },
        {
          "line": 187,
          "content": "        if not isinstance(total_tests, int) or total_tests < 0:"
        },
        {
          "line": 192,
          "content": "        if not isinstance(total_mentions, int) or total_mentions < 0:"
        },
        {
          "line": 197,
          "content": "        if 'detailed_results' in aggregated_results:"
        },
        {
          "line": 199,
          "content": "            if not isinstance(detailed_results, list):"
        },
        {
          "line": 205,
          "content": "        if errors:"
        },
        {
          "line": 207,
          "content": "            for error in errors:"
        },
        {
          "line": 210,
          "content": "        return len(errors) == 0, errors"
        },
        {
          "line": 212,
          "content": "    def validate_brand_rankings(self, brand_rankings: List[Dict[str, Any]]) -> Tuple[bool, List[str]]:"
        },
        {
          "line": 213,
          "content": "        \"\"\""
        },
        {
          "line": 221,
          "content": "        \"\"\""
        },
        {
          "line": 224,
          "content": "        if not isinstance(brand_rankings, list):"
        },
        {
          "line": 227,
          "content": "            return False, errors"
        },
        {
          "line": 229,
          "content": "        if len(brand_rankings) == 0:"
        },
        {
          "line": 233,
          "content": "        for i, ranking in enumerate(brand_rankings):"
        },
        {
          "line": 238,
          "content": "            for field in required_fields:"
        },
        {
          "line": 239,
          "content": "                if field not in ranking:"
        },
        {
          "line": 244,
          "content": "            if 'brand' in ranking:"
        },
        {
          "line": 246,
          "content": "                if not isinstance(brand, str) or not brand.strip():"
        },
        {
          "line": 249,
          "content": "                elif len(brand) > self.MAX_LENGTHS['brand_name']:"
        },
        {
          "line": 254,
          "content": "            if 'rank' in ranking:"
        },
        {
          "line": 256,
          "content": "                if not isinstance(rank, (int, float)) or rank < 1:"
        },
        {
          "line": 261,
          "content": "            if 'responses' in ranking:"
        },
        {
          "line": 263,
          "content": "                if not isinstance(responses, (int, float)) or responses < 0:"
        },
        {
          "line": 268,
          "content": "            if 'sov_share' in ranking:"
        },
        {
          "line": 270,
          "content": "                if not isinstance(sov_share, (int, float)) or not (0 <= sov_share <= 100):"
        },
        {
          "line": 275,
          "content": "            if 'avg_sentiment' in ranking:"
        },
        {
          "line": 277,
          "content": "                if not isinstance(avg_sentiment, (int, float)) or not (0 <= avg_sentiment <= 1):"
        },
        {
          "line": 283,
          "content": "        if errors:"
        },
        {
          "line": 285,
          "content": "            for error in errors:"
        },
        {
          "line": 288,
          "content": "        return len(errors) == 0, errors"
        },
        {
          "line": 290,
          "content": "    def validate_execution_id(self, execution_id: str) -> str:"
        },
        {
          "line": 291,
          "content": "        \"\"\""
        },
        {
          "line": 302,
          "content": "        \"\"\""
        },
        {
          "line": 303,
          "content": "        if not execution_id:"
        },
        {
          "line": 306,
          "content": "        if not isinstance(execution_id, str):"
        },
        {
          "line": 309,
          "content": "        if len(execution_id) > self.MAX_LENGTHS['execution_id']:"
        },
        {
          "line": 317,
          "content": "        import re"
        },
        {
          "line": 318,
          "content": "        if not re.match(r'^[a-zA-Z0-9_-]+$', execution_id):"
        },
        {
          "line": 325,
          "content": "        return execution_id"
        },
        {
          "line": 327,
          "content": "    def get_stats(self) -> Dict[str, Any]:"
        },
        {
          "line": 328,
          "content": "        \"\"\"获取验证器统计信息\"\"\""
        },
        {
          "line": 341,
          "content": "    \"\"\"获取全局验证器实例\"\"\""
        },
        {
          "line": 343,
          "content": "    if _validator is None:"
        },
        {
          "line": 345,
          "content": "    return _validator"
        },
        {
          "line": 348,
          "content": "def validate_task_data(task_data: Dict[str, Any]) -> Tuple[bool, List[str]]:"
        },
        {
          "line": 349,
          "content": "    \"\"\"便捷函数：验证任务数据\"\"\""
        },
        {
          "line": 354,
          "content": "    \"\"\"便捷函数：验证聚合结果\"\"\""
        },
        {
          "line": 355,
          "content": "    return get_validator().validate_aggregated_results(aggregated_results)"
        },
        {
          "line": 358,
          "content": "def validate_brand_rankings(brand_rankings: List[Dict[str, Any]]) -> Tuple[bool, List[str]]:"
        },
        {
          "line": 359,
          "content": "    \"\"\"便捷函数：验证品牌排名\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/sql_protection.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\"SQL 注入防护器\"\"\""
        },
        {
          "line": 22,
          "content": "    def __init__(self):"
        },
        {
          "line": 52,
          "content": "    def contains_sql_injection(self, input_str: str) -> bool:"
        },
        {
          "line": 53,
          "content": "        \"\"\"检查输入是否包含 SQL 注入模式\"\"\""
        },
        {
          "line": 57,
          "content": "        # Check for dangerous patterns regardless of input type"
        },
        {
          "line": 65,
          "content": "        \"\"\"净化输入，移除潜在的危险字符\"\"\""
        },
        {
          "line": 66,
          "content": "        if not input_str:"
        },
        {
          "line": 67,
          "content": "            return input_str"
        },
        {
          "line": 76,
          "content": "        return sanitized"
        },
        {
          "line": 78,
          "content": "    def validate_input(self, input_str: str) -> bool:"
        },
        {
          "line": 79,
          "content": "        \"\"\"验证输入是否安全\"\"\""
        },
        {
          "line": 86,
          "content": "    \"\"\""
        },
        {
          "line": 95,
          "content": "    \"\"\""
        },
        {
          "line": 105,
          "content": "        \"\"\"确保数据库连接已建立\"\"\""
        },
        {
          "line": 106,
          "content": "        if self.conn is None or self._closed:"
        },
        {
          "line": 111,
          "content": "    def execute_query(self, query: str, params: Tuple = ()) -> List[Tuple]:"
        },
        {
          "line": 112,
          "content": "        \"\"\"执行安全的数据库查询\"\"\""
        },
        {
          "line": 133,
          "content": "        \"\"\"显式关闭数据库连接\"\"\""
        },
        {
          "line": 134,
          "content": "        if self.conn and not self._closed:"
        },
        {
          "line": 144,
          "content": "    def __enter__(self):"
        },
        {
          "line": 145,
          "content": "        \"\"\"上下文管理器入口\"\"\""
        },
        {
          "line": 150,
          "content": "        \"\"\"上下文管理器出口 - 确保连接关闭\"\"\""
        },
        {
          "line": 153,
          "content": "        return False"
        },
        {
          "line": 155,
          "content": "    def begin_transaction(self):"
        },
        {
          "line": 156,
          "content": "        \"\"\"开始事务\"\"\""
        },
        {
          "line": 164,
          "content": "        \"\"\"提交事务\"\"\""
        },
        {
          "line": 165,
          "content": "        if self.conn:"
        },
        {
          "line": 169,
          "content": "    def rollback(self):"
        },
        {
          "line": 170,
          "content": "        \"\"\"回滚事务\"\"\""
        },
        {
          "line": 176,
          "content": "        \"\"\""
        },
        {
          "line": 185,
          "content": "        \"\"\""
        },
        {
          "line": 200,
          "content": "        \"\"\"执行安全的选择查询\"\"\""
        },
        {
          "line": 202,
          "content": "        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', table):"
        },
        {
          "line": 206,
          "content": "        if columns:"
        },
        {
          "line": 207,
          "content": "            for col in columns:"
        },
        {
          "line": 208,
          "content": "                if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', col):"
        },
        {
          "line": 213,
          "content": "        if columns:"
        },
        {
          "line": 219,
          "content": "        if conditions:"
        },
        {
          "line": 221,
          "content": "            for key, value in conditions.items():"
        },
        {
          "line": 223,
          "content": "                if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', key):"
        },
        {
          "line": 227,
          "content": "                if isinstance(value, str):"
        },
        {
          "line": 228,
          "content": "                    if self.protector.contains_sql_injection(value):"
        },
        {
          "line": 234,
          "content": "            if where_clause:"
        },
        {
          "line": 237,
          "content": "        return self.execute_query(query, params)"
        },
        {
          "line": 239,
          "content": "    def execute_safe_insert(self, table: str, data: dict) -> int:"
        },
        {
          "line": 240,
          "content": "        \"\"\""
        },
        {
          "line": 246,
          "content": "        \"\"\""
        },
        {
          "line": 248,
          "content": "        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', table):"
        },
        {
          "line": 256,
          "content": "        for key, value in data.items():"
        },
        {
          "line": 258,
          "content": "            if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', key):"
        },
        {
          "line": 262,
          "content": "            if isinstance(value, str):"
        },
        {
          "line": 263,
          "content": "                if self.protector.contains_sql_injection(value):"
        },
        {
          "line": 275,
          "content": "        return self.conn.lastrowid if self.conn else None"
        },
        {
          "line": 282,
          "content": "def is_safe_sql_input(input_str: str) -> bool:"
        },
        {
          "line": 283,
          "content": "    \"\"\"便捷函数：检查输入是否安全\"\"\""
        },
        {
          "line": 288,
          "content": "    \"\"\"便捷函数：净化 SQL 输入\"\"\""
        },
        {
          "line": 289,
          "content": "    return sql_protector.sanitize_input(input_str)"
        },
        {
          "line": 292,
          "content": "def create_safe_query(db_path: str) -> SafeDatabaseQuery:"
        },
        {
          "line": 293,
          "content": "    \"\"\"便捷函数：创建安全查询对象\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/input_validation.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "        \"\"\"简单的HTML净化替代函数\"\"\""
        },
        {
          "line": 21,
          "content": "        import re"
        },
        {
          "line": 22,
          "content": "        if strip:"
        },
        {
          "line": 28,
          "content": "        return clean_text"
        },
        {
          "line": 34,
          "content": "    from marshmallow import Schema, fields, ValidationError"
        },
        {
          "line": 38,
          "content": "    class Schema:"
        },
        {
          "line": 41,
          "content": "    class fields:"
        },
        {
          "line": 43,
          "content": "        def String(*args, **kwargs):"
        },
        {
          "line": 44,
          "content": "            return str"
        },
        {
          "line": 47,
          "content": "        def Email(*args, **kwargs):"
        },
        {
          "line": 48,
          "content": "            return str"
        },
        {
          "line": 51,
          "content": "        def Url(*args, **kwargs):"
        },
        {
          "line": 52,
          "content": "            return str"
        },
        {
          "line": 54,
          "content": "    class ValidationError(Exception):"
        },
        {
          "line": 60,
          "content": "class InputValidator:"
        },
        {
          "line": 61,
          "content": "    \"\"\"输入验证器\"\"\""
        },
        {
          "line": 65,
          "content": "        \"\"\"验证邮箱格式\"\"\""
        },
        {
          "line": 67,
          "content": "        return bool(re.match(pattern, email))"
        },
        {
          "line": 70,
          "content": "    def validate_url(url: str) -> bool:"
        },
        {
          "line": 71,
          "content": "        \"\"\"验证URL格式\"\"\""
        },
        {
          "line": 80,
          "content": "        \"\"\"验证字母数字组合\"\"\""
        },
        {
          "line": 82,
          "content": "        return bool(re.match(pattern, text))"
        },
        {
          "line": 85,
          "content": "    def validate_safe_text(text: str, max_length: int = 1000) -> bool:"
        },
        {
          "line": 86,
          "content": "        \"\"\"验证安全文本（不含危险字符）\"\"\""
        },
        {
          "line": 103,
          "content": "    \"\"\"输入净化器\"\"\""
        },
        {
          "line": 106,
          "content": "    def sanitize_html(text: str) -> str:"
        },
        {
          "line": 107,
          "content": "        \"\"\"净化HTML内容，移除危险标签\"\"\""
        },
        {
          "line": 126,
          "content": "        \"\"\"净化字符串，移除或转义特殊字符\"\"\""
        },
        {
          "line": 127,
          "content": "        if text is None:"
        },
        {
          "line": 128,
          "content": "            return None"
        },
        {
          "line": 132,
          "content": "        return html.escape(text, quote=True)"
        },
        {
          "line": 135,
          "content": "    def sanitize_user_input(data: Dict[str, Any]) -> Dict[str, Any]:"
        },
        {
          "line": 136,
          "content": "        \"\"\"净化用户输入数据\"\"\""
        },
        {
          "line": 155,
          "content": "        \"\"\"请求数据验证模式\"\"\""
        },
        {
          "line": 167,
          "content": "    class RequestSchema:"
        },
        {
          "line": 168,
          "content": "        \"\"\"简单的请求数据验证类（当marshmallow不可用时）\"\"\""
        },
        {
          "line": 174,
          "content": "            \"\"\"简单的数据加载和验证\"\"\""
        },
        {
          "line": 176,
          "content": "            if 'brand_list' not in data or not isinstance(data.get('brand_list'), list) or len(data['brand_list']) == 0:"
        },
        {
          "line": 180,
          "content": "            for field_name in ['user_id', 'userOpenid', 'apiKey', 'userLevel']:"
        },
        {
          "line": 182,
          "content": "                if value and isinstance(value, str) and len(value) > 100:"
        },
        {
          "line": 185,
          "content": "            return data"
        },
        {
          "line": 188,
          "content": "def validate_and_sanitize_request(request_data: Dict[str, Any], schema_class=RequestSchema) -> Dict[str, Any]:"
        },
        {
          "line": 189,
          "content": "    \"\"\"验证和净化请求数据\"\"\""
        },
        {
          "line": 219,
          "content": "    \"\"\"便捷函数：验证邮箱\"\"\""
        },
        {
          "line": 220,
          "content": "    return InputValidator.validate_email(email)"
        },
        {
          "line": 223,
          "content": "def is_valid_url(url: str) -> bool:"
        },
        {
          "line": 224,
          "content": "    \"\"\"便捷函数：验证URL\"\"\""
        },
        {
          "line": 229,
          "content": "    \"\"\"便捷函数：净化输入\"\"\""
        },
        {
          "line": 230,
          "content": "    return InputSanitizer.sanitize_string(text)"
        },
        {
          "line": 233,
          "content": "def validate_safe_text(text: str, max_length: int = 1000) -> bool:"
        },
        {
          "line": 234,
          "content": "    \"\"\"便捷函数：验证安全文本\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/data_encryption.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 37,
          "content": "    python -c \"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\""
        },
        {
          "line": 38,
          "content": "\"\"\""
        },
        {
          "line": 59,
          "content": "    \"\"\""
        },
        {
          "line": 64,
          "content": "    \"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\""
        },
        {
          "line": 73,
          "content": "        \"\"\""
        },
        {
          "line": 117,
          "content": "        \"\"\""
        },
        {
          "line": 121,
          "content": "        \"\"\""
        },
        {
          "line": 127,
          "content": "        \"\"\""
        },
        {
          "line": 135,
          "content": "        \"\"\""
        },
        {
          "line": 157,
          "content": "        \"\"\""
        },
        {
          "line": 165,
          "content": "        \"\"\""
        },
        {
          "line": 187,
          "content": "        \"\"\""
        },
        {
          "line": 195,
          "content": "        \"\"\""
        },
        {
          "line": 208,
          "content": "        \"\"\"获取加密器统计信息\"\"\""
        },
        {
          "line": 209,
          "content": "        return {"
        },
        {
          "line": 213,
          "content": "            'algorithm': 'AES-256-GCM' if self.use_aesgcm else 'Fernet (AES-128-CBC)'"
        },
        {
          "line": 221,
          "content": "def get_encryptor() -> FieldEncryptor:"
        },
        {
          "line": 222,
          "content": "    \"\"\"获取全局加密器实例\"\"\""
        },
        {
          "line": 230,
          "content": "    \"\"\""
        },
        {
          "line": 238,
          "content": "    \"\"\""
        },
        {
          "line": 243,
          "content": "    \"\"\""
        },
        {
          "line": 251,
          "content": "    \"\"\""
        },
        {
          "line": 256,
          "content": "    \"\"\""
        },
        {
          "line": 265,
          "content": "    \"\"\""
        },
        {
          "line": 274,
          "content": "    \"\"\""
        },
        {
          "line": 283,
          "content": "    \"\"\""
        },
        {
          "line": 304,
          "content": "    \"\"\""
        },
        {
          "line": 308,
          "content": "    \"\"\""
        },
        {
          "line": 313,
          "content": "        \"\"\"加密记录中的敏感字段\"\"\""
        },
        {
          "line": 314,
          "content": "        if table in self.SENSITIVE_FIELDS:"
        },
        {
          "line": 315,
          "content": "            return encrypt_sensitive_data(data, self.SENSITIVE_FIELDS[table])"
        },
        {
          "line": 316,
          "content": "        return data"
        },
        {
          "line": 318,
          "content": "    def decrypt_record(self, table: str, data: dict) -> dict:"
        },
        {
          "line": 319,
          "content": "        \"\"\"解密记录中的敏感字段\"\"\""
        },
        {
          "line": 327,
          "content": "    \"\"\""
        },
        {
          "line": 332,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/encryption_enhanced.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "    from wechat_backend.security.encryption_enhanced import encrypt_sensitive_fields"
        },
        {
          "line": 14,
          "content": "    class User:"
        },
        {
          "line": 16,
          "content": "\"\"\""
        },
        {
          "line": 26,
          "content": "    \"\"\"获取加密器实例\"\"\""
        },
        {
          "line": 28,
          "content": "    if _encryptor is None:"
        },
        {
          "line": 30,
          "content": "    return _encryptor"
        },
        {
          "line": 33,
          "content": "def encrypt_sensitive_data(data: Dict[str, Any], fields: List[str]) -> Dict[str, Any]:"
        },
        {
          "line": 34,
          "content": "    \"\"\""
        },
        {
          "line": 43,
          "content": "    \"\"\""
        },
        {
          "line": 46,
          "content": "    for field in fields:"
        },
        {
          "line": 47,
          "content": "        if field in data and data[field]:"
        },
        {
          "line": 54,
          "content": "    return encrypted_data"
        },
        {
          "line": 57,
          "content": "def decrypt_sensitive_data(data: Dict[str, Any], fields: List[str]) -> Dict[str, Any]:"
        },
        {
          "line": 58,
          "content": "    \"\"\""
        },
        {
          "line": 67,
          "content": "    \"\"\""
        },
        {
          "line": 70,
          "content": "    for field in fields:"
        },
        {
          "line": 71,
          "content": "        if field in data and data[field]:"
        },
        {
          "line": 78,
          "content": "    return decrypted_data"
        },
        {
          "line": 89,
          "content": "def encrypt_user_data(user_data: Dict[str, Any]) -> Dict[str, Any]:"
        },
        {
          "line": 90,
          "content": "    \"\"\"加密用户数据\"\"\""
        },
        {
          "line": 95,
          "content": "    \"\"\"解密用户数据\"\"\""
        },
        {
          "line": 96,
          "content": "    return decrypt_sensitive_data(user_data, SENSITIVE_FIELDS['user'])"
        },
        {
          "line": 99,
          "content": "def encrypt_test_record(record: Dict[str, Any]) -> Dict[str, Any]:"
        },
        {
          "line": 100,
          "content": "    \"\"\"加密测试记录\"\"\""
        },
        {
          "line": 105,
          "content": "    \"\"\"解密测试记录\"\"\""
        },
        {
          "line": 106,
          "content": "    return decrypt_sensitive_data(record, SENSITIVE_FIELDS['test_record'])"
        },
        {
          "line": 110,
          "content": "def encrypt_on_save(*fields):"
        },
        {
          "line": 111,
          "content": "    \"\"\""
        },
        {
          "line": 118,
          "content": "    \"\"\""
        },
        {
          "line": 119,
          "content": "    def decorator(cls):"
        },
        {
          "line": 122,
          "content": "        def save_with_encryption(self, *args, **kwargs):"
        },
        {
          "line": 124,
          "content": "            for field in fields:"
        },
        {
          "line": 125,
          "content": "                if hasattr(self, field):"
        },
        {
          "line": 127,
          "content": "                    if value:"
        },
        {
          "line": 135,
          "content": "            if original_save:"
        },
        {
          "line": 136,
          "content": "                return original_save(self, *args, **kwargs)"
        },
        {
          "line": 139,
          "content": "        return cls"
        },
        {
          "line": 141,
          "content": "    return decorator"
        },
        {
          "line": 144,
          "content": "def decrypt_on_load(*fields):"
        },
        {
          "line": 145,
          "content": "    \"\"\""
        },
        {
          "line": 152,
          "content": "    \"\"\""
        },
        {
          "line": 153,
          "content": "    def decorator(cls):"
        },
        {
          "line": 155,
          "content": "        for field in fields:"
        },
        {
          "line": 158,
          "content": "            def make_getter(f, pf):"
        },
        {
          "line": 159,
          "content": "                def getter(self):"
        },
        {
          "line": 161,
          "content": "                    if value:"
        },
        {
          "line": 163,
          "content": "                            return decrypt_field(value)"
        },
        {
          "line": 167,
          "content": "                            return value"
        },
        {
          "line": 168,
          "content": "                    return None"
        },
        {
          "line": 169,
          "content": "                return getter"
        },
        {
          "line": 171,
          "content": "            def make_setter(f, pf):"
        },
        {
          "line": 172,
          "content": "                def setter(self, value):"
        },
        {
          "line": 173,
          "content": "                    if value:"
        },
        {
          "line": 183,
          "content": "                return setter"
        },
        {
          "line": 186,
          "content": "            if not hasattr(cls, private_field):"
        },
        {
          "line": 195,
          "content": "        return cls"
        },
        {
          "line": 197,
          "content": "    return decorator"
        },
        {
          "line": 200,
          "content": "if __name__ == '__main__':"
        },
        {
          "line": 231,
          "content": "    if decrypted['openid'] == user_data['openid'] and decrypted['phone'] == user_data['phone']:"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\"安全模块初始化\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/flask_security.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "    \"\"\"创建安全增强的 Flask 应用\"\"\""
        },
        {
          "line": 41,
          "content": "    return app, csrf"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/rate_limit_monitor.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "\"\"\""
        },
        {
          "line": 27,
          "content": "    \"\"\""
        },
        {
          "line": 35,
          "content": "    \"\"\""
        },
        {
          "line": 50,
          "content": "        \"\"\"加载统计数据\"\"\""
        },
        {
          "line": 52,
          "content": "            if RATE_LIMIT_STATS_FILE.exists():"
        },
        {
          "line": 60,
          "content": "                    for key in ['limited_by_endpoint', 'limited_by_ip', 'limited_by_user']:"
        },
        {
          "line": 61,
          "content": "                        if key in loaded_stats:"
        },
        {
          "line": 65,
          "content": "                    if 'hourly_stats' in loaded_stats:"
        },
        {
          "line": 68,
          "content": "                        for hour_str, hour_data in loaded_stats['hourly_stats'].items():"
        },
        {
          "line": 71,
          "content": "                                if hour_dt >= cutoff:"
        },
        {
          "line": 80,
          "content": "    def _save_stats(self):"
        },
        {
          "line": 81,
          "content": "        \"\"\"保存统计数据\"\"\""
        },
        {
          "line": 102,
          "content": "        \"\"\""
        },
        {
          "line": 109,
          "content": "        \"\"\""
        },
        {
          "line": 122,
          "content": "        \"\"\""
        },
        {
          "line": 131,
          "content": "        \"\"\""
        },
        {
          "line": 178,
          "content": "        \"\"\""
        },
        {
          "line": 185,
          "content": "        \"\"\""
        },
        {
          "line": 209,
          "content": "        \"\"\""
        },
        {
          "line": 214,
          "content": "        \"\"\""
        },
        {
          "line": 245,
          "content": "        \"\"\"重置统计数据\"\"\""
        },
        {
          "line": 263,
          "content": "def get_rate_limit_monitor() -> RateLimitMonitor:"
        },
        {
          "line": 264,
          "content": "    \"\"\""
        },
        {
          "line": 269,
          "content": "    \"\"\""
        },
        {
          "line": 271,
          "content": "    if _rate_limit_monitor is None:"
        },
        {
          "line": 273,
          "content": "    return _rate_limit_monitor"
        },
        {
          "line": 277,
          "content": "def monitored_rate_limit(func):"
        },
        {
          "line": 278,
          "content": "    \"\"\""
        },
        {
          "line": 285,
          "content": "    \"\"\""
        },
        {
          "line": 286,
          "content": "    from functools import wraps"
        },
        {
          "line": 289,
          "content": "    def wrapper(*args, **kwargs):"
        },
        {
          "line": 294,
          "content": "        if result is False:"
        },
        {
          "line": 303,
          "content": "        return result"
        },
        {
          "line": 305,
          "content": "    return wrapper"
        },
        {
          "line": 308,
          "content": "if __name__ == '__main__':"
        },
        {
          "line": 318,
          "content": "    for i in range(10):"
        },
        {
          "line": 322,
          "content": "    for i in range(5):"
        },
        {
          "line": 333,
          "content": "    for key, value in stats.items():"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/db_optimization.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 22,
          "content": "\"\"\""
        },
        {
          "line": 45,
          "content": "    \"\"\"缓存条目\"\"\""
        },
        {
          "line": 46,
          "content": "    def __init__(self, value: Any, ttl: int = 300):"
        },
        {
          "line": 51,
          "content": "    def is_expired(self) -> bool:"
        },
        {
          "line": 52,
          "content": "        \"\"\"检查是否过期\"\"\""
        },
        {
          "line": 57,
          "content": "    \"\"\""
        },
        {
          "line": 65,
          "content": "    \"\"\""
        },
        {
          "line": 68,
          "content": "        \"\"\""
        },
        {
          "line": 74,
          "content": "        \"\"\""
        },
        {
          "line": 90,
          "content": "        \"\"\"生成缓存键\"\"\""
        },
        {
          "line": 91,
          "content": "        key_material = f\"{query}:{json.dumps(params, sort_keys=True) if params else ''}\""
        },
        {
          "line": 92,
          "content": "        return hashlib.md5(key_material.encode()).hexdigest()"
        },
        {
          "line": 94,
          "content": "    def get(self, key: str) -> Optional[Any]:"
        },
        {
          "line": 95,
          "content": "        \"\"\""
        },
        {
          "line": 103,
          "content": "        \"\"\""
        },
        {
          "line": 105,
          "content": "            if key not in self._cache:"
        },
        {
          "line": 107,
          "content": "                return None"
        },
        {
          "line": 112,
          "content": "            if entry.is_expired():"
        },
        {
          "line": 116,
          "content": "                return None"
        },
        {
          "line": 122,
          "content": "            return entry.value"
        },
        {
          "line": 124,
          "content": "    def set(self, key: str, value: Any, ttl: int = None) -> None:"
        },
        {
          "line": 125,
          "content": "        \"\"\""
        },
        {
          "line": 132,
          "content": "        \"\"\""
        },
        {
          "line": 133,
          "content": "        if ttl is None:"
        },
        {
          "line": 138,
          "content": "            if key in self._cache:"
        },
        {
          "line": 142,
          "content": "            if len(self._cache) >= self._max_size:"
        },
        {
          "line": 150,
          "content": "    def get_or_set(self, key: str, factory: Callable[[], Any], ttl: int = None) -> Any:"
        },
        {
          "line": 151,
          "content": "        \"\"\""
        },
        {
          "line": 161,
          "content": "        \"\"\""
        },
        {
          "line": 163,
          "content": "        if value is not None:"
        },
        {
          "line": 164,
          "content": "            return value"
        },
        {
          "line": 169,
          "content": "        return value"
        },
        {
          "line": 171,
          "content": "    def delete(self, key: str) -> bool:"
        },
        {
          "line": 172,
          "content": "        \"\"\"删除缓存\"\"\""
        },
        {
          "line": 180,
          "content": "        \"\"\"清空缓存\"\"\""
        },
        {
          "line": 184,
          "content": "    def cleanup_expired(self) -> int:"
        },
        {
          "line": 185,
          "content": "        \"\"\"清理过期缓存\"\"\""
        },
        {
          "line": 199,
          "content": "        \"\"\"获取缓存统计\"\"\""
        },
        {
          "line": 204,
          "content": "                if total_requests > 0 else 0"
        },
        {
          "line": 207,
          "content": "            return {"
        },
        {
          "line": 223,
          "content": "def get_query_cache() -> QueryCache:"
        },
        {
          "line": 224,
          "content": "    \"\"\"获取全局查询缓存实例\"\"\""
        },
        {
          "line": 236,
          "content": "    \"\"\""
        },
        {
          "line": 244,
          "content": "    \"\"\""
        },
        {
          "line": 252,
          "content": "        \"\"\""
        },
        {
          "line": 259,
          "content": "        \"\"\""
        },
        {
          "line": 269,
          "content": "        \"\"\""
        },
        {
          "line": 277,
          "content": "        \"\"\""
        },
        {
          "line": 301,
          "content": "        \"\"\"清理旧备份\"\"\""
        },
        {
          "line": 304,
          "content": "        if len(backups) <= self.max_backups:"
        },
        {
          "line": 305,
          "content": "            return 0"
        },
        {
          "line": 309,
          "content": "        for backup_path in to_delete:"
        },
        {
          "line": 316,
          "content": "        return len(to_delete)"
        },
        {
          "line": 318,
          "content": "    def _list_backups(self) -> List[Path]:"
        },
        {
          "line": 319,
          "content": "        \"\"\"列出所有备份 (按时间排序)\"\"\""
        },
        {
          "line": 334,
          "content": "        \"\"\""
        },
        {
          "line": 339,
          "content": "        \"\"\""
        },
        {
          "line": 357,
          "content": "        \"\"\""
        },
        {
          "line": 365,
          "content": "        \"\"\""
        },
        {
          "line": 384,
          "content": "        \"\"\""
        },
        {
          "line": 392,
          "content": "        \"\"\""
        },
        {
          "line": 437,
          "content": "        \"\"\"获取备份统计\"\"\""
        },
        {
          "line": 439,
          "content": "        total_size = sum(f.stat().st_size for f in backups)"
        },
        {
          "line": 441,
          "content": "        return {"
        },
        {
          "line": 448,
          "content": "                backups[0].name if backups else None"
        },
        {
          "line": 457,
          "content": "class CapacityMonitor:"
        },
        {
          "line": 458,
          "content": "    \"\"\""
        },
        {
          "line": 467,
          "content": "    \"\"\""
        },
        {
          "line": 473,
          "content": "    def __init__(self, db_path: str):"
        },
        {
          "line": 474,
          "content": "        \"\"\""
        },
        {
          "line": 479,
          "content": "        \"\"\""
        },
        {
          "line": 483,
          "content": "    def get_database_stats(self) -> Dict[str, Any]:"
        },
        {
          "line": 484,
          "content": "        \"\"\"获取数据库统计\"\"\""
        },
        {
          "line": 552,
          "content": "        \"\"\"获取表统计\"\"\""
        },
        {
          "line": 570,
          "content": "        return stats"
        },
        {
          "line": 572,
          "content": "    def _get_size_status(self, size_bytes: int) -> str:"
        },
        {
          "line": 573,
          "content": "        \"\"\"获取大小状态\"\"\""
        },
        {
          "line": 584,
          "content": "        \"\"\"获取增长趋势\"\"\""
        },
        {
          "line": 585,
          "content": "        if len(self._history) < 2:"
        },
        {
          "line": 586,
          "content": "            return {"
        },
        {
          "line": 600,
          "content": "        if time_diff <= 0:"
        },
        {
          "line": 601,
          "content": "            return {'available': False, 'reason': 'Time diff is zero'}"
        },
        {
          "line": 606,
          "content": "        return {"
        },
        {
          "line": 618,
          "content": "    def check_capacity(self) -> Dict[str, Any]:"
        },
        {
          "line": 619,
          "content": "        \"\"\"检查容量状态\"\"\""
        },
        {
          "line": 661,
          "content": "    \"\"\"便捷函数：查询缓存\"\"\""
        },
        {
          "line": 662,
          "content": "    return get_query_cache().get_or_set(key, factory, ttl)"
        },
        {
          "line": 665,
          "content": "def create_backup(db_path: str, backup_dir: str = 'data/backups') -> str:"
        },
        {
          "line": 666,
          "content": "    \"\"\"便捷函数：创建数据库备份\"\"\""
        },
        {
          "line": 672,
          "content": "    \"\"\"便捷函数：监控数据库容量\"\"\""
        },
        {
          "line": 674,
          "content": "    return monitor.check_capacity()"
        },
        {
          "line": 677,
          "content": "if __name__ == '__main__':"
        },
        {
          "line": 691,
          "content": "    if Path(db_path).exists():"
        },
        {
          "line": 692,
          "content": "        print(f\"\\n=== Testing DatabaseBackup for {db_path} ===\")"
        },
        {
          "line": 696,
          "content": "        print(f\"\\n=== Testing CapacityMonitor for {db_path} ===\")"
        },
        {
          "line": 701,
          "content": "        if stats.get('warnings'):"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/secure_config.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\"安全配置管理类\"\"\""
        },
        {
          "line": 17,
          "content": "    def __init__(self, password: str = None):"
        },
        {
          "line": 18,
          "content": "        \"\"\""
        },
        {
          "line": 21,
          "content": "        \"\"\""
        },
        {
          "line": 25,
          "content": "    def _get_cipher(self, salt: bytes) -> Fernet:"
        },
        {
          "line": 26,
          "content": "        \"\"\"根据盐值获取加密器\"\"\""
        },
        {
          "line": 37,
          "content": "        \"\"\"加密单个值\"\"\""
        },
        {
          "line": 42,
          "content": "        return base64.b64encode(salt + encrypted_value).decode()"
        },
        {
          "line": 44,
          "content": "    def decrypt_value(self, encrypted_value: str) -> str:"
        },
        {
          "line": 45,
          "content": "        \"\"\"解密单个值\"\"\""
        },
        {
          "line": 57,
          "content": "        \"\"\"加密整个配置字典\"\"\""
        },
        {
          "line": 59,
          "content": "        return self.encrypt_value(json_str)"
        },
        {
          "line": 61,
          "content": "    def decrypt_config_dict(self, encrypted_config: str) -> dict:"
        },
        {
          "line": 62,
          "content": "        \"\"\"解密配置字典\"\"\""
        },
        {
          "line": 72,
          "content": "    \"\"\"获取配置管理器实例\"\"\""
        },
        {
          "line": 74,
          "content": "    if _config_manager is None:"
        },
        {
          "line": 76,
          "content": "    return _config_manager"
        },
        {
          "line": 79,
          "content": "def load_secure_config_from_file(file_path: str, password: str = None) -> dict:"
        },
        {
          "line": 80,
          "content": "    \"\"\"从加密文件加载配置\"\"\""
        },
        {
          "line": 92,
          "content": "    \"\"\"保存配置到加密文件\"\"\""
        },
        {
          "line": 105,
          "content": "def encrypt_sensitive_value(value: str, password: str = None) -> str:"
        },
        {
          "line": 106,
          "content": "    \"\"\"便捷函数：加密敏感值\"\"\""
        },
        {
          "line": 112,
          "content": "    \"\"\"便捷函数：解密敏感值\"\"\""
        },
        {
          "line": 114,
          "content": "    return manager.decrypt_value(encrypted_value)"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/auth_enhanced.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "    def get_sensitive_data():"
        },
        {
          "line": 16,
          "content": "\"\"\""
        },
        {
          "line": 27,
          "content": "    \"\"\""
        },
        {
          "line": 36,
          "content": "    \"\"\""
        },
        {
          "line": 81,
          "content": "    \"\"\""
        },
        {
          "line": 90,
          "content": "    \"\"\""
        },
        {
          "line": 114,
          "content": "    \"\"\""
        },
        {
          "line": 125,
          "content": "    \"\"\""
        },
        {
          "line": 205,
          "content": "    \"\"\""
        },
        {
          "line": 213,
          "content": "        def get_user_data(user_id):"
        },
        {
          "line": 216,
          "content": "    \"\"\""
        },
        {
          "line": 258,
          "content": "    \"\"\"记录安全事件日志\"\"\""
        },
        {
          "line": 260,
          "content": "        from wechat_backend.database.audit_logs import create_audit_log"
        },
        {
          "line": 266,
          "content": "            ip_address=ip_address or request.remote_addr if request else None,"
        },
        {
          "line": 267,
          "content": "            user_agent=request.user_agent.string[:255] if request and request.user_agent else None,"
        },
        {
          "line": 268,
          "content": "            request_method=request.method if request else None,"
        },
        {
          "line": 280,
          "content": "def log_audit_access(endpoint_name: str):"
        },
        {
          "line": 281,
          "content": "    \"\"\"记录审计日志（差距 1 增强）\"\"\""
        },
        {
          "line": 335,
          "content": "    \"\"\"检查端点是否需要严格认证\"\"\""
        },
        {
          "line": 336,
          "content": "    for endpoint in STRICT_AUTH_ENDPOINTS:"
        },
        {
          "line": 337,
          "content": "        if path.startswith(endpoint):"
        },
        {
          "line": 338,
          "content": "            return True"
        },
        {
          "line": 339,
          "content": "    return False"
        },
        {
          "line": 342,
          "content": "if __name__ == '__main__':"
        },
        {
          "line": 355,
          "content": "    for endpoint in STRICT_AUTH_ENDPOINTS:"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/security/input_validator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "\"\"\""
        },
        {
          "line": 25,
          "content": "    \"\"\"输入验证器 (增强版)\"\"\""
        },
        {
          "line": 62,
          "content": "    def validate_string("
        },
        {
          "line": 72,
          "content": "        \"\"\""
        },
        {
          "line": 89,
          "content": "        \"\"\""
        },
        {
          "line": 91,
          "content": "        if value is None:"
        },
        {
          "line": 92,
          "content": "            if allow_empty:"
        },
        {
          "line": 93,
          "content": "                return ''"
        },
        {
          "line": 97,
          "content": "        if not isinstance(value, str):"
        },
        {
          "line": 103,
          "content": "        if not value:"
        },
        {
          "line": 104,
          "content": "            if allow_empty:"
        },
        {
          "line": 105,
          "content": "                return ''"
        },
        {
          "line": 110,
          "content": "        if max_length is None:"
        },
        {
          "line": 113,
          "content": "        if len(value) > max_length:"
        },
        {
          "line": 120,
          "content": "        if whitelist_pattern:"
        },
        {
          "line": 121,
          "content": "            if not re.match(whitelist_pattern, value):"
        },
        {
          "line": 128,
          "content": "        if check_sql_injection:"
        },
        {
          "line": 132,
          "content": "        if check_xss:"
        },
        {
          "line": 135,
          "content": "        return value"
        },
        {
          "line": 138,
          "content": "    def _check_sql_injection(cls, value: str, field_name: str):"
        },
        {
          "line": 139,
          "content": "        \"\"\"检查 SQL 注入\"\"\""
        },
        {
          "line": 158,
          "content": "        \"\"\"检查 XSS 攻击\"\"\""
        },
        {
          "line": 161,
          "content": "        for dangerous in cls.DANGEROUS_XSS_CHARS:"
        },
        {
          "line": 162,
          "content": "            if dangerous.lower() in value_lower:"
        },
        {
          "line": 168,
          "content": "        if re.search(r'<[^>]+>', value):"
        },
        {
          "line": 172,
          "content": "    def validate_execution_id(cls, value: str) -> str:"
        },
        {
          "line": 173,
          "content": "        \"\"\"验证执行 ID (增强版 - 使用白名单)\"\"\""
        },
        {
          "line": 184,
          "content": "        \"\"\"验证品牌名称 (增强版 - 使用白名单)\"\"\""
        },
        {
          "line": 185,
          "content": "        return cls.validate_string("
        },
        {
          "line": 194,
          "content": "    def validate_model_name(cls, value: str) -> str:"
        },
        {
          "line": 195,
          "content": "        \"\"\"验证模型名称 (增强版 - 使用白名单)\"\"\""
        },
        {
          "line": 206,
          "content": "        \"\"\"验证用户 OpenID (增强版 - 使用白名单)\"\"\""
        },
        {
          "line": 207,
          "content": "        return cls.validate_string("
        },
        {
          "line": 216,
          "content": "    def validate_question(cls, value: str) -> str:"
        },
        {
          "line": 217,
          "content": "        \"\"\"验证问题\"\"\""
        },
        {
          "line": 227,
          "content": "        \"\"\"验证响应\"\"\""
        },
        {
          "line": 228,
          "content": "        return cls.validate_string("
        },
        {
          "line": 237,
          "content": "    def validate_numeric(cls, value: Any, field_name: str = 'value',"
        },
        {
          "line": 241,
          "content": "        \"\"\""
        },
        {
          "line": 256,
          "content": "        \"\"\""
        },
        {
          "line": 257,
          "content": "        if value is None:"
        },
        {
          "line": 258,
          "content": "            if allow_none:"
        },
        {
          "line": 259,
          "content": "                return None"
        },
        {
          "line": 270,
          "content": "        import math"
        },
        {
          "line": 271,
          "content": "        if math.isnan(num_value):"
        },
        {
          "line": 274,
          "content": "        if math.isinf(num_value):"
        },
        {
          "line": 279,
          "content": "        if min_value is not None and num_value < min_value:"
        },
        {
          "line": 282,
          "content": "        if max_value is not None and num_value > max_value:"
        },
        {
          "line": 286,
          "content": "        return num_value"
        },
        {
          "line": 289,
          "content": "    def validate_json_string(cls, value: str, field_name: str = 'json_data') -> str:"
        },
        {
          "line": 290,
          "content": "        \"\"\"验证 JSON 字符串\"\"\""
        },
        {
          "line": 307,
          "content": "    \"\"\"便捷函数：验证字符串\"\"\""
        },
        {
          "line": 308,
          "content": "    return InputValidator.validate_string(*args, **kwargs)"
        },
        {
          "line": 310,
          "content": "def validate_execution_id(value: str) -> str:"
        },
        {
          "line": 311,
          "content": "    \"\"\"便捷函数：验证执行 ID\"\"\""
        },
        {
          "line": 315,
          "content": "    \"\"\"便捷函数：验证品牌名称\"\"\""
        },
        {
          "line": 316,
          "content": "    return InputValidator.validate_brand_name(value)"
        },
        {
          "line": 318,
          "content": "def validate_model_name(value: str) -> str:"
        },
        {
          "line": 319,
          "content": "    \"\"\"便捷函数：验证模型名称\"\"\""
        },
        {
          "line": 323,
          "content": "    \"\"\"便捷函数：验证问题\"\"\""
        },
        {
          "line": 324,
          "content": "    return InputValidator.validate_question(value)"
        },
        {
          "line": 326,
          "content": "def validate_response(value: str) -> str:"
        },
        {
          "line": 327,
          "content": "    \"\"\"便捷函数：验证响应\"\"\""
        },
        {
          "line": 331,
          "content": "    \"\"\"便捷函数：验证数值\"\"\""
        },
        {
          "line": 332,
          "content": "    return InputValidator.validate_numeric(*args, **kwargs)"
        },
        {
          "line": 334,
          "content": "def validate_user_openid(value: str) -> str:"
        },
        {
          "line": 335,
          "content": "    \"\"\"便捷函数：验证用户 OpenID\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/optimization/request_frequency_optimizer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\"请求优先级\"\"\""
        },
        {
          "line": 22,
          "content": "class RequestFrequencyOptimizer:"
        },
        {
          "line": 23,
          "content": "    \"\"\"API请求频率优化器\"\"\""
        },
        {
          "line": 40,
          "content": "        \"\"\""
        },
        {
          "line": 49,
          "content": "        \"\"\""
        },
        {
          "line": 84,
          "content": "        \"\"\"清理过期的请求记录\"\"\""
        },
        {
          "line": 87,
          "content": "            for platform, times in self.request_times.items():"
        },
        {
          "line": 89,
          "content": "                recent_times = [t for t in times if current_time - t <= max_age_seconds]"
        },
        {
          "line": 92,
          "content": "    def get_current_frequency(self, platform: str, window_seconds: int = 60) -> float:"
        },
        {
          "line": 93,
          "content": "        \"\"\"获取指定平台在指定时间窗口内的请求频率（次/分钟）\"\"\""
        },
        {
          "line": 103,
          "content": "        \"\"\"强制重置指定平台的请求计数\"\"\""
        },
        {
          "line": 112,
          "content": "def optimize_request_frequency(platform: str, priority: RequestPriority = RequestPriority.MEDIUM):"
        },
        {
          "line": 113,
          "content": "    \"\"\""
        },
        {
          "line": 115,
          "content": "    \"\"\""
        },
        {
          "line": 116,
          "content": "    def decorator(func):"
        },
        {
          "line": 117,
          "content": "        def wrapper(*args, **kwargs):"
        },
        {
          "line": 121,
          "content": "            if delay_time > 0:"
        },
        {
          "line": 122,
          "content": "                api_logger.info(f\"Delaying request to {platform} for {delay_time:.2f}s due to frequency control\")"
        },
        {
          "line": 126,
          "content": "            return func(*args, **kwargs)"
        },
        {
          "line": 127,
          "content": "        return wrapper"
        },
        {
          "line": 128,
          "content": "    return decorator"
        },
        {
          "line": 131,
          "content": "def get_platform_frequency_info(platform: str) -> Dict:"
        },
        {
          "line": 132,
          "content": "    \"\"\"获取平台频率信息\"\"\""
        },
        {
          "line": 141,
          "content": "    \"\"\"清理过期的频率记录\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/optimization/progress_tracker_optimization.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "    \"\"\"执行状态枚举\"\"\""
        },
        {
          "line": 20,
          "content": "class OptimizedProgressTracker:"
        },
        {
          "line": 21,
          "content": "    \"\"\""
        },
        {
          "line": 26,
          "content": "    \"\"\""
        },
        {
          "line": 28,
          "content": "    def __init__(self, max_poll_interval: int = 10, timeout_seconds: int = 1800):  # 30分钟超时"
        },
        {
          "line": 34,
          "content": "    def create_execution(self, execution_id: str, total_tests: int, metadata: Dict[str, Any] = None) -> Dict[str, Any]:"
        },
        {
          "line": 35,
          "content": "        \"\"\"创建新的执行记录\"\"\""
        },
        {
          "line": 52,
          "content": "        \"\"\"更新进度\"\"\""
        },
        {
          "line": 54,
          "content": "            if execution_id in self.execution_store:"
        },
        {
          "line": 60,
          "content": "                if current['status'] in [ExecutionStatus.COMPLETED.value, ExecutionStatus.FAILED.value, ExecutionStatus.TIMEOUT.value]:"
        },
        {
          "line": 63,
          "content": "                return True"
        },
        {
          "line": 64,
          "content": "            return False"
        },
        {
          "line": 66,
          "content": "    def get_progress(self, execution_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 67,
          "content": "        \"\"\"获取进度信息，包含智能轮询建议\"\"\""
        },
        {
          "line": 95,
          "content": "        \"\"\"计算建议的轮询间隔（智能轮询策略）\"\"\""
        },
        {
          "line": 96,
          "content": "        if poll_count <= 5:"
        },
        {
          "line": 97,
          "content": "            return 2  # 前5次每2秒轮询"
        },
        {
          "line": 98,
          "content": "        elif poll_count <= 15:"
        },
        {
          "line": 99,
          "content": "            return 3  # 接下来每3秒轮询"
        },
        {
          "line": 100,
          "content": "        elif poll_count <= 30:"
        },
        {
          "line": 101,
          "content": "            return 5  # 再接下来每5秒轮询"
        },
        {
          "line": 103,
          "content": "            return min(10, self.max_poll_interval)  # 最大不超过10秒"
        },
        {
          "line": 105,
          "content": "    def complete_execution(self, execution_id: str, final_results: Dict[str, Any]) -> bool:"
        },
        {
          "line": 106,
          "content": "        \"\"\"完成执行\"\"\""
        },
        {
          "line": 118,
          "content": "        \"\"\"标记执行失败\"\"\""
        },
        {
          "line": 120,
          "content": "            if execution_id in self.execution_store:"
        },
        {
          "line": 126,
          "content": "                return True"
        },
        {
          "line": 127,
          "content": "            return False"
        },
        {
          "line": 129,
          "content": "    def cleanup_old_executions(self, max_age_seconds: int = 3600) -> int:  # 1小时"
        },
        {
          "line": 130,
          "content": "        \"\"\"清理旧的执行记录\"\"\""
        },
        {
          "line": 151,
          "content": "    \"\"\"获取优化的进度跟踪器实例\"\"\""
        },
        {
          "line": 152,
          "content": "    return optimized_progress_tracker"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/network/security.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\"安全HTTP客户端\"\"\""
        },
        {
          "line": 22,
          "content": "    def __init__(self,"
        },
        {
          "line": 27,
          "content": "        \"\"\""
        },
        {
          "line": 33,
          "content": "        \"\"\""
        },
        {
          "line": 61,
          "content": "    def _prepare_headers(self, additional_headers: Optional[Dict] = None) -> Dict:"
        },
        {
          "line": 62,
          "content": "        \"\"\"准备请求头部\"\"\""
        },
        {
          "line": 69,
          "content": "        \"\"\"安全GET请求\"\"\""
        },
        {
          "line": 71,
          "content": "        return self._make_request('GET', url, headers=headers, **kwargs)"
        },
        {
          "line": 73,
          "content": "    def post(self, url: str, headers: Optional[Dict] = None, **kwargs) -> requests.Response:"
        },
        {
          "line": 74,
          "content": "        \"\"\"安全POST请求\"\"\""
        },
        {
          "line": 79,
          "content": "        \"\"\"安全PUT请求\"\"\""
        },
        {
          "line": 81,
          "content": "        return self._make_request('PUT', url, headers=headers, **kwargs)"
        },
        {
          "line": 83,
          "content": "    def delete(self, url: str, headers: Optional[Dict] = None, **kwargs) -> requests.Response:"
        },
        {
          "line": 84,
          "content": "        \"\"\"安全DELETE请求\"\"\""
        },
        {
          "line": 89,
          "content": "        \"\"\"执行安全请求\"\"\""
        },
        {
          "line": 91,
          "content": "        if self.verify_ssl and not url.startswith('https://'):"
        },
        {
          "line": 96,
          "content": "        kwargs.setdefault('verify', self.cert_file if self.verify_ssl else False)"
        },
        {
          "line": 107,
          "content": "            return response"
        },
        {
          "line": 113,
          "content": "    def _validate_response(self, response: requests.Response) -> None:"
        },
        {
          "line": 114,
          "content": "        \"\"\"验证响应的安全性\"\"\""
        },
        {
          "line": 130,
          "content": "        \"\"\"关闭会话\"\"\""
        },
        {
          "line": 134,
          "content": "class CertificatePinner:"
        },
        {
          "line": 135,
          "content": "    \"\"\"证书固定器\"\"\""
        },
        {
          "line": 138,
          "content": "        \"\"\""
        },
        {
          "line": 141,
          "content": "        \"\"\""
        },
        {
          "line": 145,
          "content": "        \"\"\"验证证书是否与固定的指纹匹配\"\"\""
        },
        {
          "line": 146,
          "content": "        if hostname not in self.pinned_certificates:"
        },
        {
          "line": 147,
          "content": "            return True  # 如果没有固定证书，则跳过验证"
        },
        {
          "line": 152,
          "content": "        return hmac.compare_digest(expected_fingerprint, actual_fingerprint)"
        },
        {
          "line": 159,
          "content": "def get_http_client(**kwargs) -> SecureHttpClient:"
        },
        {
          "line": 160,
          "content": "    \"\"\"获取安全HTTP客户端实例\"\"\""
        },
        {
          "line": 168,
          "content": "    \"\"\"重置HTTP客户端实例\"\"\""
        },
        {
          "line": 170,
          "content": "    if _http_client:"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/network/rate_limiter.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\"速率限制算法类型\"\"\""
        },
        {
          "line": 25,
          "content": "class RateLimiter:"
        },
        {
          "line": 26,
          "content": "    \"\"\"速率限制器基类\"\"\""
        },
        {
          "line": 33,
          "content": "        \"\"\"检查请求是否被允许\"\"\""
        },
        {
          "line": 37,
          "content": "class TokenBucketRateLimiter(RateLimiter):"
        },
        {
          "line": 38,
          "content": "    \"\"\"令牌桶算法速率限制器\"\"\""
        },
        {
          "line": 45,
          "content": "        \"\"\""
        },
        {
          "line": 50,
          "content": "        \"\"\""
        },
        {
          "line": 78,
          "content": "    \"\"\"滑动窗口算法速率限制器\"\"\""
        },
        {
          "line": 80,
          "content": "    def __init__(self):"
        },
        {
          "line": 84,
          "content": "    def is_allowed(self, key: str, limit: int, window_size: int) -> bool:"
        },
        {
          "line": 85,
          "content": "        \"\"\""
        },
        {
          "line": 90,
          "content": "        \"\"\""
        },
        {
          "line": 96,
          "content": "            while window and now - window[0] > window_size:"
        },
        {
          "line": 100,
          "content": "            if len(window) < limit:"
        },
        {
          "line": 102,
          "content": "                return True"
        },
        {
          "line": 104,
          "content": "                return False"
        },
        {
          "line": 107,
          "content": "class FixedWindowRateLimiter(RateLimiter):"
        },
        {
          "line": 108,
          "content": "    \"\"\"固定窗口算法速率限制器\"\"\""
        },
        {
          "line": 115,
          "content": "        \"\"\""
        },
        {
          "line": 120,
          "content": "        \"\"\""
        },
        {
          "line": 146,
          "content": "    \"\"\"速率限制器管理器\"\"\""
        },
        {
          "line": 148,
          "content": "    def __init__(self):"
        },
        {
          "line": 157,
          "content": "    def is_allowed(self,"
        },
        {
          "line": 164,
          "content": "        \"\"\""
        },
        {
          "line": 172,
          "content": "        \"\"\""
        },
        {
          "line": 177,
          "content": "        if algorithm == RateLimitAlgorithm.TOKEN_BUCKET:"
        },
        {
          "line": 181,
          "content": "            return limiter.is_allowed(key, cap, rate)"
        },
        {
          "line": 184,
          "content": "            return limiter.is_allowed(key, limit, window_size)"
        },
        {
          "line": 186,
          "content": "    def get_limiter(self, algorithm: RateLimitAlgorithm):"
        },
        {
          "line": 187,
          "content": "        \"\"\"获取指定算法的限流器\"\"\""
        },
        {
          "line": 196,
          "content": "    \"\"\"获取速率限制器管理器实例\"\"\""
        },
        {
          "line": 198,
          "content": "    if _rate_limiter_manager is None:"
        },
        {
          "line": 200,
          "content": "    return _rate_limiter_manager"
        },
        {
          "line": 203,
          "content": "def is_rate_limited(key: str, limit: int, window_size: int, **kwargs) -> bool:"
        },
        {
          "line": 204,
          "content": "    \"\"\"便捷函数：检查是否被限流\"\"\""
        },
        {
          "line": 210,
          "content": "    \"\"\"检查速率限制状态\"\"\""
        },
        {
          "line": 214,
          "content": "    return {"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/network/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\"网络安全模块初始化\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/network/circuit_breaker.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\"断路器状态\"\"\""
        },
        {
          "line": 22,
          "content": "class CircuitBreaker:"
        },
        {
          "line": 23,
          "content": "    \"\"\"断路器实现\"\"\""
        },
        {
          "line": 29,
          "content": "        \"\"\""
        },
        {
          "line": 34,
          "content": "        \"\"\""
        },
        {
          "line": 46,
          "content": "        \"\"\""
        },
        {
          "line": 53,
          "content": "        \"\"\""
        },
        {
          "line": 83,
          "content": "        \"\"\"调用成功时的处理\"\"\""
        },
        {
          "line": 89,
          "content": "    def _on_failure(self, exception_type: str, exception_msg: str):"
        },
        {
          "line": 90,
          "content": "        \"\"\"调用失败时的处理\"\"\""
        },
        {
          "line": 103,
          "content": "        \"\"\"强制打开断路器\"\"\""
        },
        {
          "line": 110,
          "content": "    def force_close(self):"
        },
        {
          "line": 111,
          "content": "        \"\"\"强制关闭断路器\"\"\""
        },
        {
          "line": 118,
          "content": "        \"\"\"获取断路器状态信息\"\"\""
        },
        {
          "line": 120,
          "content": "            return {"
        },
        {
          "line": 127,
          "content": "                'time_since_last_failure': time.time() - self.last_failure_time if self.last_failure_time else None,"
        },
        {
          "line": 131,
          "content": "                ) if self.last_failure_time else False"
        },
        {
          "line": 135,
          "content": "class CircuitBreakerGroup:"
        },
        {
          "line": 136,
          "content": "    \"\"\"断路器组，用于管理多个相关服务的断路器\"\"\""
        },
        {
          "line": 143,
          "content": "        \"\"\"获取指定名称的断路器\"\"\""
        },
        {
          "line": 145,
          "content": "            if name not in self.circuit_breakers:"
        },
        {
          "line": 147,
          "content": "            return self.circuit_breakers[name]"
        },
        {
          "line": 149,
          "content": "    def get_state_info(self) -> dict:"
        },
        {
          "line": 150,
          "content": "        \"\"\"获取所有断路器的状态信息\"\"\""
        },
        {
          "line": 155,
          "content": "        \"\"\"强制打开所有断路器\"\"\""
        },
        {
          "line": 157,
          "content": "            for cb in self.circuit_breakers.values():"
        },
        {
          "line": 160,
          "content": "    def force_close_all(self):"
        },
        {
          "line": 161,
          "content": "        \"\"\"强制关闭所有断路器\"\"\""
        },
        {
          "line": 172,
          "content": "    \"\"\"获取指定名称的断路器\"\"\""
        },
        {
          "line": 174,
          "content": "    if _circuit_breaker_group is None:"
        },
        {
          "line": 176,
          "content": "    return _circuit_breaker_group.get_circuit_breaker(name, **kwargs)"
        },
        {
          "line": 179,
          "content": "def get_circuit_breaker_group() -> CircuitBreakerGroup:"
        },
        {
          "line": 180,
          "content": "    \"\"\"获取断路器组\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/network/request_wrapper.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\"统一的HTTP请求封装器\"\"\""
        },
        {
          "line": 25,
          "content": "    def __init__(self,"
        },
        {
          "line": 33,
          "content": "        \"\"\""
        },
        {
          "line": 42,
          "content": "        \"\"\""
        },
        {
          "line": 55,
          "content": "    def _prepare_url(self, endpoint: str) -> str:"
        },
        {
          "line": 56,
          "content": "        \"\"\"准备完整URL\"\"\""
        },
        {
          "line": 63,
          "content": "        \"\"\"准备请求头\"\"\""
        },
        {
          "line": 65,
          "content": "        if additional_headers:"
        },
        {
          "line": 67,
          "content": "        return headers"
        },
        {
          "line": 69,
          "content": "    def _check_rate_limit(self) -> bool:"
        },
        {
          "line": 70,
          "content": "        \"\"\"检查速率限制\"\"\""
        },
        {
          "line": 82,
          "content": "        \"\"\"执行HTTP请求\"\"\""
        },
        {
          "line": 84,
          "content": "        if not self._check_rate_limit():"
        },
        {
          "line": 85,
          "content": "            raise Exception(f\"Rate limit exceeded for key: {self.rate_limit_key}\")"
        },
        {
          "line": 130,
          "content": "        return response"
        },
        {
          "line": 132,
          "content": "    def get(self, endpoint: str, headers: Optional[Dict[str, str]] = None, **kwargs) -> requests.Response:"
        },
        {
          "line": 133,
          "content": "        \"\"\"GET请求\"\"\""
        },
        {
          "line": 137,
          "content": "        \"\"\"POST请求\"\"\""
        },
        {
          "line": 138,
          "content": "        return self._make_request('POST', endpoint, headers, **kwargs)"
        },
        {
          "line": 140,
          "content": "    def put(self, endpoint: str, headers: Optional[Dict[str, str]] = None, **kwargs) -> requests.Response:"
        },
        {
          "line": 141,
          "content": "        \"\"\"PUT请求\"\"\""
        },
        {
          "line": 145,
          "content": "        \"\"\"DELETE请求\"\"\""
        },
        {
          "line": 146,
          "content": "        return self._make_request('DELETE', endpoint, headers, **kwargs)"
        },
        {
          "line": 148,
          "content": "    def patch(self, endpoint: str, headers: Optional[Dict[str, str]] = None, **kwargs) -> requests.Response:"
        },
        {
          "line": 149,
          "content": "        \"\"\"PATCH请求\"\"\""
        },
        {
          "line": 157,
          "content": "        \"\"\""
        },
        {
          "line": 160,
          "content": "        \"\"\""
        },
        {
          "line": 174,
          "content": "    \"\"\"AI平台专用请求封装器\"\"\""
        },
        {
          "line": 176,
          "content": "    def __init__(self,"
        },
        {
          "line": 183,
          "content": "        \"\"\""
        },
        {
          "line": 191,
          "content": "        \"\"\""
        },
        {
          "line": 194,
          "content": "        if api_key:"
        },
        {
          "line": 208,
          "content": "    def make_ai_request(self,"
        },
        {
          "line": 214,
          "content": "        \"\"\"发送AI请求\"\"\""
        },
        {
          "line": 228,
          "content": "    \"\"\"获取指定名称的请求封装器\"\"\""
        },
        {
          "line": 230,
          "content": "    if name not in _request_wrappers:"
        },
        {
          "line": 232,
          "content": "    return _request_wrappers[name]"
        },
        {
          "line": 235,
          "content": "def get_ai_request_wrapper(platform_name: str, **kwargs) -> AIPlatformRequestWrapper:"
        },
        {
          "line": 236,
          "content": "    \"\"\"获取AI平台请求封装器\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/network/retry_mechanism.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\"重试策略类型\"\"\""
        },
        {
          "line": 22,
          "content": "class RetryHandler:"
        },
        {
          "line": 23,
          "content": "    \"\"\"重试处理器\"\"\""
        },
        {
          "line": 32,
          "content": "        \"\"\""
        },
        {
          "line": 40,
          "content": "        \"\"\""
        },
        {
          "line": 49,
          "content": "        \"\"\"计算重试延迟时间\"\"\""
        },
        {
          "line": 50,
          "content": "        if self.strategy == RetryStrategy.FIXED_INTERVAL:"
        },
        {
          "line": 52,
          "content": "        elif self.strategy == RetryStrategy.LINEAR_BACKOFF:"
        },
        {
          "line": 54,
          "content": "        elif self.strategy == RetryStrategy.EXPONENTIAL_BACKOFF:"
        },
        {
          "line": 63,
          "content": "        if self.jitter:"
        },
        {
          "line": 66,
          "content": "        return delay"
        },
        {
          "line": 68,
          "content": "    def should_retry(self, attempt: int, exception: Exception) -> bool:"
        },
        {
          "line": 69,
          "content": "        \"\"\"判断是否应该重试\"\"\""
        },
        {
          "line": 77,
          "content": "        \"\"\""
        },
        {
          "line": 80,
          "content": "        \"\"\""
        },
        {
          "line": 104,
          "content": "    \"\"\"智能重试处理器，根据错误类型调整重试策略\"\"\""
        },
        {
          "line": 106,
          "content": "    def __init__(self,"
        },
        {
          "line": 122,
          "content": "    def execute_with_smart_retry(self, func: Callable, error_type: Optional[str] = None, *args, **kwargs) -> Tuple[bool, Any, Optional[Exception]]:"
        },
        {
          "line": 123,
          "content": "        \"\"\""
        },
        {
          "line": 128,
          "content": "        \"\"\""
        },
        {
          "line": 131,
          "content": "        if error_type and error_type in self.error_configs:"
        },
        {
          "line": 144,
          "content": "            return self.execute_with_retry(func, *args, **kwargs)"
        },
        {
          "line": 147,
          "content": "            if original_config:"
        },
        {
          "line": 154,
          "content": "def retry_execution(max_attempts: int = 3, base_delay: float = 1.0, **kwargs):"
        },
        {
          "line": 155,
          "content": "    \"\"\"装饰器：为函数添加重试功能\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/network/connection_pool.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\"连接池管理器\"\"\""
        },
        {
          "line": 18,
          "content": "    def __init__(self, pool_connections=10, pool_maxsize=20, max_retries=3):"
        },
        {
          "line": 19,
          "content": "        \"\"\""
        },
        {
          "line": 24,
          "content": "        \"\"\""
        },
        {
          "line": 34,
          "content": "    def _create_session(self):"
        },
        {
          "line": 35,
          "content": "        \"\"\"创建配置好的会话\"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\"获取特定主机的会话\"\"\""
        },
        {
          "line": 69,
          "content": "            if host not in self.sessions:"
        },
        {
          "line": 71,
          "content": "            return self.sessions[host]"
        },
        {
          "line": 73,
          "content": "    def get_default_session(self):"
        },
        {
          "line": 74,
          "content": "        \"\"\"获取默认会话\"\"\""
        },
        {
          "line": 78,
          "content": "        \"\"\"关闭所有会话\"\"\""
        },
        {
          "line": 79,
          "content": "        for session in self.sessions.values():"
        },
        {
          "line": 89,
          "content": "def get_connection_pool_manager() -> ConnectionPoolManager:"
        },
        {
          "line": 90,
          "content": "    \"\"\"获取连接池管理器实例\"\"\""
        },
        {
          "line": 98,
          "content": "    \"\"\"根据URL获取适当的会话\"\"\""
        },
        {
          "line": 99,
          "content": "    from urllib.parse import urlparse"
        },
        {
          "line": 104,
          "content": "    return manager.get_session_for_host(host)"
        },
        {
          "line": 107,
          "content": "def get_default_session():"
        },
        {
          "line": 108,
          "content": "    \"\"\"获取默认会话\"\"\""
        },
        {
          "line": 114,
          "content": "    \"\"\"清理所有连接池\"\"\""
        },
        {
          "line": 116,
          "content": "    if _pool_manager:"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/intelligence_services/misunderstanding_analyzer.py",
      "lines": [
        {
          "line": 8,
          "content": "    \"\"\"典型品牌误解类型枚举\"\"\""
        },
        {
          "line": 18,
          "content": "class MisunderstandingResult:"
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 28,
          "content": "    \"\"\""
        },
        {
          "line": 36,
          "content": "class MisunderstandingAnalyzer:"
        },
        {
          "line": 37,
          "content": "    \"\"\""
        },
        {
          "line": 40,
          "content": "    \"\"\""
        },
        {
          "line": 42,
          "content": "    def analyze("
        },
        {
          "line": 49,
          "content": "        \"\"\""
        },
        {
          "line": 60,
          "content": "        \"\"\""
        },
        {
          "line": 65,
          "content": "        if judge_result.accuracy_score < 70:"
        },
        {
          "line": 68,
          "content": "        if judge_result.completeness_score < 60:"
        },
        {
          "line": 74,
          "content": "        if \"混淆\" in judgement_lower or \"误认\" in judgement_lower:"
        },
        {
          "line": 75,
          "content": "            if MisunderstandingType.BRAND_CONFUSION.value not in issue_types:"
        },
        {
          "line": 78,
          "content": "        if \"过时\" in judgement_lower or \"旧\" in judgement_lower:"
        },
        {
          "line": 79,
          "content": "            if MisunderstandingType.OUTDATED_INFO.value not in issue_types:"
        },
        {
          "line": 82,
          "content": "        if \"不准确\" in judgement_lower or \"错误\" in judgement_lower:"
        },
        {
          "line": 83,
          "content": "            if MisunderstandingType.FACT_ERROR.value not in issue_types:"
        },
        {
          "line": 86,
          "content": "        if \"遗漏\" in judgement_lower or \"不全\" in judgement_lower:"
        },
        {
          "line": 87,
          "content": "            if MisunderstandingType.INCOMPLETE_INFO.value not in issue_types:"
        },
        {
          "line": 95,
          "content": "        if any(phrase in ai_answer_lower for phrase in generic_phrases):"
        },
        {
          "line": 96,
          "content": "            if MisunderstandingType.OVER_GENERALIZATION.value not in issue_types:"
        },
        {
          "line": 101,
          "content": "        if any(phrase in ai_answer_lower for phrase in uncertain_phrases):"
        },
        {
          "line": 102,
          "content": "            if MisunderstandingType.NO_CLEAR_EVIDENCE.value not in issue_types:"
        },
        {
          "line": 108,
          "content": "        if brand_name.lower() not in ai_answer_lower and \"品牌\" in ai_answer_lower:"
        },
        {
          "line": 109,
          "content": "            if MisunderstandingType.BRAND_CONFUSION.value not in issue_types:"
        },
        {
          "line": 127,
          "content": "        return MisunderstandingResult("
        },
        {
          "line": 135,
          "content": "    def _evaluate_risk_level(self, issue_types: List[str], judge_result: JudgeResult) -> str:"
        },
        {
          "line": 136,
          "content": "        \"\"\""
        },
        {
          "line": 145,
          "content": "        \"\"\""
        },
        {
          "line": 147,
          "content": "        if MisunderstandingType.FACT_ERROR.value in issue_types or \\"
        },
        {
          "line": 149,
          "content": "            return \"high\""
        },
        {
          "line": 152,
          "content": "        if judge_result.accuracy_score < 60 or len(issue_types) >= 3:"
        },
        {
          "line": 153,
          "content": "            return \"medium\""
        },
        {
          "line": 156,
          "content": "        return \"low\""
        },
        {
          "line": 158,
          "content": "    def _generate_issue_summary("
        },
        {
          "line": 165,
          "content": "        \"\"\""
        },
        {
          "line": 176,
          "content": "        \"\"\""
        },
        {
          "line": 177,
          "content": "        if not has_issue:"
        },
        {
          "line": 178,
          "content": "            return f\"AI 对 {brand_name} 的回答质量良好，未发现明显误解。\""
        },
        {
          "line": 190,
          "content": "        issue_names = [type_mapping.get(t, t) for t in issue_types]"
        },
        {
          "line": 202,
          "content": "        return \"\".join(summary_parts)"
        },
        {
          "line": 204,
          "content": "    def _generate_improvement_hint(self, issue_types: List[str]) -> str:"
        },
        {
          "line": 205,
          "content": "        \"\"\""
        },
        {
          "line": 213,
          "content": "        \"\"\""
        },
        {
          "line": 216,
          "content": "        if MisunderstandingType.FACT_ERROR.value in issue_types:"
        },
        {
          "line": 219,
          "content": "        if MisunderstandingType.BRAND_CONFUSION.value in issue_types:"
        },
        {
          "line": 222,
          "content": "        if MisunderstandingType.INCOMPLETE_INFO.value in issue_types:"
        },
        {
          "line": 225,
          "content": "        if MisunderstandingType.OVER_GENERALIZATION.value in issue_types:"
        },
        {
          "line": 228,
          "content": "        if MisunderstandingType.OUTDATED_INFO.value in issue_types:"
        },
        {
          "line": 231,
          "content": "        if MisunderstandingType.NO_CLEAR_EVIDENCE.value in issue_types:"
        },
        {
          "line": 234,
          "content": "        if not hints:"
        },
        {
          "line": 235,
          "content": "            return \"继续保持现有质量水平。\""
        },
        {
          "line": 237,
          "content": "        return \" \".join(hints)"
        },
        {
          "line": 241,
          "content": "if __name__ == \"__main__\":"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/intelligence_services/prediction_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\""
        },
        {
          "line": 25,
          "content": "        \"\"\""
        },
        {
          "line": 35,
          "content": "        \"\"\""
        },
        {
          "line": 56,
          "content": "        \"\"\""
        },
        {
          "line": 65,
          "content": "        \"\"\""
        },
        {
          "line": 88,
          "content": "        \"\"\""
        },
        {
          "line": 97,
          "content": "        \"\"\""
        },
        {
          "line": 141,
          "content": "        \"\"\""
        },
        {
          "line": 150,
          "content": "        \"\"\""
        },
        {
          "line": 173,
          "content": "        \"\"\""
        },
        {
          "line": 182,
          "content": "        \"\"\""
        },
        {
          "line": 195,
          "content": "        \"\"\""
        },
        {
          "line": 203,
          "content": "        \"\"\""
        },
        {
          "line": 215,
          "content": "        \"\"\""
        },
        {
          "line": 224,
          "content": "        \"\"\""
        },
        {
          "line": 252,
          "content": "        \"\"\""
        },
        {
          "line": 260,
          "content": "        \"\"\""
        },
        {
          "line": 272,
          "content": "        \"\"\""
        },
        {
          "line": 280,
          "content": "        \"\"\""
        },
        {
          "line": 302,
          "content": "        \"\"\""
        },
        {
          "line": 310,
          "content": "        \"\"\""
        },
        {
          "line": 325,
          "content": "    \"\"\""
        },
        {
          "line": 327,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/intelligence_services/source_analyzer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "    \"\"\""
        },
        {
          "line": 13,
          "content": "    \"\"\""
        },
        {
          "line": 59,
          "content": "        \"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\""
        },
        {
          "line": 93,
          "content": "        \"\"\""
        },
        {
          "line": 101,
          "content": "        \"\"\""
        },
        {
          "line": 109,
          "content": "        \"\"\""
        },
        {
          "line": 117,
          "content": "        \"\"\""
        },
        {
          "line": 155,
          "content": "        \"\"\""
        },
        {
          "line": 163,
          "content": "        \"\"\""
        },
        {
          "line": 174,
          "content": "        \"\"\""
        },
        {
          "line": 183,
          "content": "        \"\"\""
        },
        {
          "line": 204,
          "content": "        \"\"\""
        },
        {
          "line": 212,
          "content": "        \"\"\""
        },
        {
          "line": 238,
          "content": "    \"\"\""
        },
        {
          "line": 240,
          "content": "    \"\"\""
        },
        {
          "line": 251,
          "content": "    \"\"\""
        },
        {
          "line": 263,
          "content": "    for i, source in enumerate(result['sources'], 1):"
        },
        {
          "line": 272,
          "content": "if __name__ == \"__main__\":"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/enums/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/enums/task_status.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "    \"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\""
        },
        {
          "line": 25,
          "content": "    \"\"\""
        },
        {
          "line": 29,
          "content": "    \"\"\""
        },
        {
          "line": 89,
          "content": "    \"\"\""
        },
        {
          "line": 97,
          "content": "    \"\"\""
        },
        {
          "line": 102,
          "content": "    \"\"\""
        },
        {
          "line": 110,
          "content": "    \"\"\""
        },
        {
          "line": 115,
          "content": "    \"\"\""
        },
        {
          "line": 123,
          "content": "    \"\"\""
        },
        {
          "line": 128,
          "content": "    \"\"\""
        },
        {
          "line": 136,
          "content": "    \"\"\""
        },
        {
          "line": 141,
          "content": "    \"\"\""
        },
        {
          "line": 149,
          "content": "    \"\"\""
        },
        {
          "line": 154,
          "content": "    \"\"\""
        },
        {
          "line": 162,
          "content": "    \"\"\""
        },
        {
          "line": 167,
          "content": "    \"\"\""
        },
        {
          "line": 175,
          "content": "    \"\"\""
        },
        {
          "line": 190,
          "content": "    \"\"\""
        },
        {
          "line": 198,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/utils/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/utils/logger.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "    \"\"\""
        },
        {
          "line": 21,
          "content": "    \"\"\""
        },
        {
          "line": 27,
          "content": "    \"\"\""
        },
        {
          "line": 34,
          "content": "    \"\"\""
        },
        {
          "line": 40,
          "content": "    \"\"\""
        },
        {
          "line": 47,
          "content": "    \"\"\""
        },
        {
          "line": 53,
          "content": "    \"\"\""
        },
        {
          "line": 60,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/utils/debug_manager.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "    \"\"\"调试管理器类\"\"\""
        },
        {
          "line": 12,
          "content": "    def __init__(self):"
        },
        {
          "line": 15,
          "content": "    def log(self, message, **kwargs):"
        },
        {
          "line": 16,
          "content": "        \"\"\"记录调试日志\"\"\""
        },
        {
          "line": 21,
          "content": "        \"\"\"启用调试模式\"\"\""
        },
        {
          "line": 25,
          "content": "    def disable(self):"
        },
        {
          "line": 26,
          "content": "        \"\"\"禁用调试模式\"\"\""
        },
        {
          "line": 36,
          "content": "    \"\"\"获取调试管理器实例\"\"\""
        },
        {
          "line": 38,
          "content": "    if _debug_manager is None:"
        },
        {
          "line": 40,
          "content": "    return _debug_manager"
        },
        {
          "line": 57,
          "content": "def debug_log(*args, **kwargs):"
        },
        {
          "line": 58,
          "content": "    \"\"\""
        },
        {
          "line": 64,
          "content": "    \"\"\""
        },
        {
          "line": 65,
          "content": "    message = ' '.join(str(arg) for arg in args)"
        },
        {
          "line": 69,
          "content": "def ai_io_log(*args, **kwargs):"
        },
        {
          "line": 70,
          "content": "    \"\"\""
        },
        {
          "line": 76,
          "content": "    \"\"\""
        },
        {
          "line": 77,
          "content": "    message = ' '.join(str(arg) for arg in args)"
        },
        {
          "line": 81,
          "content": "def debug_log_ai_io(tag, execution_id, content, message=\"\"):"
        },
        {
          "line": 82,
          "content": "    \"\"\""
        },
        {
          "line": 90,
          "content": "    \"\"\""
        },
        {
          "line": 94,
          "content": "def status_flow_log(*args, **kwargs):"
        },
        {
          "line": 95,
          "content": "    \"\"\""
        },
        {
          "line": 101,
          "content": "    \"\"\""
        },
        {
          "line": 102,
          "content": "    message = ' '.join(str(arg) for arg in args)"
        },
        {
          "line": 106,
          "content": "def exception_log(*args, **kwargs):"
        },
        {
          "line": 107,
          "content": "    \"\"\""
        },
        {
          "line": 113,
          "content": "    \"\"\""
        },
        {
          "line": 114,
          "content": "    message = ' '.join(str(arg) for arg in args)"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/utils/ai_response_logger_v2.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 33,
          "content": "    \"\"\""
        },
        {
          "line": 36,
          "content": "    \"\"\""
        },
        {
          "line": 39,
          "content": "        \"\"\""
        },
        {
          "line": 44,
          "content": "        \"\"\""
        },
        {
          "line": 57,
          "content": "        \"\"\"获取系统信息\"\"\""
        },
        {
          "line": 58,
          "content": "        return {"
        },
        {
          "line": 67,
          "content": "    def _calculate_text_stats(self, text: str) -> Dict[str, Any]:"
        },
        {
          "line": 68,
          "content": "        \"\"\"计算文本统计信息\"\"\""
        },
        {
          "line": 138,
          "content": "        \"\"\""
        },
        {
          "line": 142,
          "content": "        \"\"\""
        },
        {
          "line": 255,
          "content": "        \"\"\"检测响应是否包含结构化数据\"\"\""
        },
        {
          "line": 256,
          "content": "        if not text:"
        },
        {
          "line": 257,
          "content": "            return False"
        },
        {
          "line": 259,
          "content": "        return any(ind in text for ind in indicators)"
        },
        {
          "line": 261,
          "content": "    def _assess_completeness(self, text: str) -> Optional[float]:"
        },
        {
          "line": 262,
          "content": "        \"\"\"评估响应完整性（简单启发式）\"\"\""
        },
        {
          "line": 286,
          "content": "        \"\"\"递归清理字典中的 None 值和不可序列化的对象\"\"\""
        },
        {
          "line": 287,
          "content": "        if isinstance(obj, dict):"
        },
        {
          "line": 288,
          "content": "            return {k: self._clean_none_values(v) for k, v in obj.items() if v is not None}"
        },
        {
          "line": 289,
          "content": "        elif isinstance(obj, list):"
        },
        {
          "line": 290,
          "content": "            return [self._clean_none_values(item) for item in obj if item is not None]"
        },
        {
          "line": 291,
          "content": "        elif hasattr(obj, 'value'):  # 处理枚举对象 (如 AIErrorType)"
        },
        {
          "line": 292,
          "content": "            return obj.value"
        },
        {
          "line": 293,
          "content": "        elif hasattr(obj, 'isoformat'):  # 处理 datetime/date 对象"
        },
        {
          "line": 294,
          "content": "            return obj.isoformat()"
        },
        {
          "line": 295,
          "content": "        return obj"
        },
        {
          "line": 297,
          "content": "    def get_recent_responses("
        },
        {
          "line": 306,
          "content": "        \"\"\""
        },
        {
          "line": 316,
          "content": "        \"\"\""
        },
        {
          "line": 319,
          "content": "        if not self.log_file.exists():"
        },
        {
          "line": 320,
          "content": "            return responses"
        },
        {
          "line": 326,
          "content": "                    for line in f:"
        },
        {
          "line": 328,
          "content": "                        if not line:"
        },
        {
          "line": 334,
          "content": "                            if platform and record.get('platform', {}).get('name') != platform:"
        },
        {
          "line": 336,
          "content": "                            if brand and record.get('business', {}).get('brand') != brand:"
        },
        {
          "line": 338,
          "content": "                            if success_only and not record.get('status', {}).get('success', True):"
        },
        {
          "line": 340,
          "content": "                            if start_time and record.get('timestamp', '') < start_time:"
        },
        {
          "line": 342,
          "content": "                            if end_time and record.get('timestamp', '') > end_time:"
        },
        {
          "line": 349,
          "content": "                        if len(responses) >= limit:"
        },
        {
          "line": 355,
          "content": "        return responses"
        },
        {
          "line": 357,
          "content": "    def get_statistics(self, days: int = 7) -> Dict[str, Any]:"
        },
        {
          "line": 358,
          "content": "        \"\"\""
        },
        {
          "line": 363,
          "content": "        \"\"\""
        },
        {
          "line": 364,
          "content": "        from datetime import timedelta"
        },
        {
          "line": 385,
          "content": "        if not self.log_file.exists():"
        },
        {
          "line": 386,
          "content": "            return stats"
        },
        {
          "line": 392,
          "content": "                    for line in f:"
        },
        {
          "line": 394,
          "content": "                        if not line:"
        },
        {
          "line": 400,
          "content": "                            if record.get('timestamp', '') < cutoff_time:"
        },
        {
          "line": 406,
          "content": "                            if record.get(\"status\", {}).get(\"success\", True):"
        },
        {
          "line": 415,
          "content": "                            if platform:"
        },
        {
          "line": 420,
          "content": "                            if model:"
        },
        {
          "line": 425,
          "content": "                            if brand:"
        },
        {
          "line": 430,
          "content": "                            if category:"
        },
        {
          "line": 435,
          "content": "                            if latency:"
        },
        {
          "line": 439,
          "content": "                            if tokens:"
        },
        {
          "line": 446,
          "content": "            if stats[\"performance\"][\"latency_samples\"]:"
        },
        {
          "line": 460,
          "content": "        return stats"
        },
        {
          "line": 467,
          "content": "def get_logger(log_file: Optional[str] = None) -> AIResponseLogger:"
        },
        {
          "line": 468,
          "content": "    \"\"\"获取全局 AI 响应记录器实例\"\"\""
        },
        {
          "line": 476,
          "content": "    \"\"\"便捷函数：记录 AI 响应（使用全局记录器）\"\"\""
        },
        {
          "line": 478,
          "content": "    return logger.log_response(**kwargs)"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/utils/ai_response_logger_v3.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 47,
          "content": "    \"\"\""
        },
        {
          "line": 50,
          "content": "    \"\"\""
        },
        {
          "line": 59,
          "content": "        \"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\""
        },
        {
          "line": 93,
          "content": "        \"\"\"获取系统信息\"\"\""
        },
        {
          "line": 94,
          "content": "        return {"
        },
        {
          "line": 103,
          "content": "    def _check_and_rotate(self):"
        },
        {
          "line": 104,
          "content": "        \"\"\"检查是否需要日志轮转\"\"\""
        },
        {
          "line": 116,
          "content": "        \"\"\"执行日志轮转\"\"\""
        },
        {
          "line": 128,
          "content": "                if self.enable_compression:"
        },
        {
          "line": 130,
          "content": "                    if compressed_path:"
        },
        {
          "line": 141,
          "content": "    def _compress_backup(self, backup_path: Path) -> Optional[Path]:"
        },
        {
          "line": 142,
          "content": "        \"\"\"压缩备份文件\"\"\""
        },
        {
          "line": 165,
          "content": "        \"\"\"清理旧备份文件\"\"\""
        },
        {
          "line": 169,
          "content": "            for pattern in ['ai_responses_*.jsonl', 'ai_responses_*.jsonl.gz']:"
        },
        {
          "line": 176,
          "content": "            if len(backup_files) > self.max_backup_count:"
        },
        {
          "line": 178,
          "content": "                for file_path in files_to_delete:"
        },
        {
          "line": 184,
          "content": "            total_size = sum(f.stat().st_size for f in backup_files[:self.max_backup_count])"
        },
        {
          "line": 190,
          "content": "    def _calculate_text_stats(self, text: str) -> Dict[str, Any]:"
        },
        {
          "line": 191,
          "content": "        \"\"\"计算文本统计信息\"\"\""
        },
        {
          "line": 261,
          "content": "        \"\"\""
        },
        {
          "line": 264,
          "content": "        \"\"\""
        },
        {
          "line": 382,
          "content": "        \"\"\"检测响应是否包含结构化数据\"\"\""
        },
        {
          "line": 383,
          "content": "        if not text:"
        },
        {
          "line": 384,
          "content": "            return False"
        },
        {
          "line": 386,
          "content": "        return any(ind in text for ind in indicators)"
        },
        {
          "line": 388,
          "content": "    def _assess_completeness(self, text: str) -> Optional[float]:"
        },
        {
          "line": 389,
          "content": "        \"\"\"评估响应完整性（简单启发式）\"\"\""
        },
        {
          "line": 413,
          "content": "        \"\"\"递归清理字典中的 None 值和不可序列化的对象\"\"\""
        },
        {
          "line": 414,
          "content": "        if isinstance(obj, dict):"
        },
        {
          "line": 415,
          "content": "            return {k: self._clean_none_values(v) for k, v in obj.items() if v is not None}"
        },
        {
          "line": 416,
          "content": "        elif isinstance(obj, list):"
        },
        {
          "line": 417,
          "content": "            return [self._clean_none_values(item) for item in item in obj if item is not None]"
        },
        {
          "line": 418,
          "content": "        elif hasattr(obj, 'value'):"
        },
        {
          "line": 419,
          "content": "            return obj.value"
        },
        {
          "line": 420,
          "content": "        elif hasattr(obj, 'isoformat'):"
        },
        {
          "line": 421,
          "content": "            return obj.isoformat()"
        },
        {
          "line": 422,
          "content": "        return obj"
        },
        {
          "line": 424,
          "content": "    def get_stats(self) -> Dict[str, Any]:"
        },
        {
          "line": 425,
          "content": "        \"\"\"获取日志统计信息\"\"\""
        },
        {
          "line": 463,
          "content": "    \"\"\"获取全局 logger 实例\"\"\""
        },
        {
          "line": 465,
          "content": "    if _default_logger is None:"
        },
        {
          "line": 467,
          "content": "    return _default_logger"
        },
        {
          "line": 470,
          "content": "def log_ai_response(**kwargs) -> Dict[str, Any]:"
        },
        {
          "line": 471,
          "content": "    \"\"\"便捷函数：记录 AI 响应\"\"\""
        },
        {
          "line": 477,
          "content": "    \"\"\"获取日志统计信息\"\"\""
        },
        {
          "line": 479,
          "content": "    return logger.get_stats()"
        },
        {
          "line": 483,
          "content": "if __name__ == \"__main__\":"
        },
        {
          "line": 510,
          "content": "    for key, value in stats.items():"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/utils/ai_response_logger_enhanced.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "\"\"\""
        },
        {
          "line": 34,
          "content": "    \"\"\""
        },
        {
          "line": 37,
          "content": "    \"\"\""
        },
        {
          "line": 40,
          "content": "        \"\"\"初始化异步记录器\"\"\""
        },
        {
          "line": 41,
          "content": "        if log_file:"
        },
        {
          "line": 68,
          "content": "    def _log_worker(self):"
        },
        {
          "line": 69,
          "content": "        \"\"\"后台日志写入线程\"\"\""
        },
        {
          "line": 116,
          "content": "        \"\"\"批量写入日志\"\"\""
        },
        {
          "line": 117,
          "content": "        if not batch:"
        },
        {
          "line": 123,
          "content": "        while retry_count < LOG_MAX_RETRIES and not success:"
        },
        {
          "line": 127,
          "content": "                        for record in batch:"
        },
        {
          "line": 133,
          "content": "                if retry_count > 0:"
        },
        {
          "line": 140,
          "content": "                if retry_count < LOG_MAX_RETRIES:"
        },
        {
          "line": 143,
          "content": "        if not success:"
        },
        {
          "line": 147,
          "content": "    def log_response(self, **kwargs) -> Dict[str, Any]:"
        },
        {
          "line": 148,
          "content": "        \"\"\""
        },
        {
          "line": 153,
          "content": "        \"\"\""
        },
        {
          "line": 154,
          "content": "        import uuid"
        },
        {
          "line": 173,
          "content": "            return {"
        },
        {
          "line": 191,
          "content": "                return {"
        },
        {
          "line": 201,
          "content": "                return {"
        },
        {
          "line": 207,
          "content": "    def flush(self):"
        },
        {
          "line": 208,
          "content": "        \"\"\"强制刷新队列中的所有日志\"\"\""
        },
        {
          "line": 220,
          "content": "        \"\"\"获取统计信息\"\"\""
        },
        {
          "line": 222,
          "content": "            return {"
        },
        {
          "line": 228,
          "content": "    def close(self):"
        },
        {
          "line": 229,
          "content": "        \"\"\"关闭记录器\"\"\""
        },
        {
          "line": 243,
          "content": "    \"\"\"获取全局异步记录器实例\"\"\""
        },
        {
          "line": 247,
          "content": "        if _async_logger is None:"
        },
        {
          "line": 249,
          "content": "        return _async_logger"
        },
        {
          "line": 252,
          "content": "def log_ai_response_async(**kwargs) -> Dict[str, Any]:"
        },
        {
          "line": 253,
          "content": "    \"\"\""
        },
        {
          "line": 265,
          "content": "    \"\"\""
        },
        {
          "line": 267,
          "content": "    return logger.log_response(**kwargs)"
        },
        {
          "line": 271,
          "content": "def log_ai_response_enhanced(**kwargs) -> Dict[str, Any]:"
        },
        {
          "line": 272,
          "content": "    \"\"\""
        },
        {
          "line": 276,
          "content": "    \"\"\""
        },
        {
          "line": 282,
          "content": "        if result['status'] == 'queued':"
        },
        {
          "line": 283,
          "content": "            return result"
        },
        {
          "line": 290,
          "content": "    import uuid"
        },
        {
          "line": 306,
          "content": "    while retry_count < LOG_MAX_RETRIES and not success:"
        },
        {
          "line": 319,
          "content": "            if retry_count < LOG_MAX_RETRIES:"
        },
        {
          "line": 322,
          "content": "    if success:"
        },
        {
          "line": 323,
          "content": "        return {"
        },
        {
          "line": 329,
          "content": "        return {"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/utils/ai_response_wrapper.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "    \"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\""
        },
        {
          "line": 61,
          "content": "    \"\"\""
        },
        {
          "line": 83,
          "content": "    \"\"\""
        },
        {
          "line": 124,
          "content": "    \"\"\"获取增强版日志记录器实例\"\"\""
        },
        {
          "line": 125,
          "content": "    from utils.ai_response_logger_enhanced import get_enhanced_logger"
        },
        {
          "line": 126,
          "content": "    return get_enhanced_logger()"
        },
        {
          "line": 129,
          "content": "def get_user_responses(user_id: str, **kwargs):"
        },
        {
          "line": 130,
          "content": "    \"\"\"获取特定用户的响应记录\"\"\""
        },
        {
          "line": 136,
          "content": "    \"\"\"获取系统级别的响应记录\"\"\""
        },
        {
          "line": 138,
          "content": "    return logger.get_system_responses(**kwargs)"
        },
        {
          "line": 141,
          "content": "def get_user_statistics(user_id: str, **kwargs):"
        },
        {
          "line": 142,
          "content": "    \"\"\"获取特定用户的统计信息\"\"\""
        },
        {
          "line": 148,
          "content": "    \"\"\"获取所有用户的统计信息\"\"\""
        },
        {
          "line": 150,
          "content": "    return logger.get_all_users_statistics(**kwargs)"
        },
        {
          "line": 154,
          "content": "def log_detailed_response("
        },
        {
          "line": 162,
          "content": "    \"\"\""
        },
        {
          "line": 164,
          "content": "    \"\"\""
        },
        {
          "line": 165,
          "content": "    return log_ai_response_with_context("
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/repositories/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/repositories/task_status_repository.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 21,
          "content": "    \"\"\"获取数据库连接上下文管理器\"\"\""
        },
        {
          "line": 34,
          "content": "def save_task_status("
        },
        {
          "line": 43,
          "content": "    \"\"\""
        },
        {
          "line": 57,
          "content": "    \"\"\""
        },
        {
          "line": 65,
          "content": "        if row:"
        },
        {
          "line": 73,
          "content": "            ''', ("
        },
        {
          "line": 86,
          "content": "            ''', ("
        },
        {
          "line": 93,
          "content": "        return record_id"
        },
        {
          "line": 96,
          "content": "def get_task_status(task_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 97,
          "content": "    \"\"\""
        },
        {
          "line": 105,
          "content": "    \"\"\""
        },
        {
          "line": 112,
          "content": "        ''', (task_id,))"
        },
        {
          "line": 130,
          "content": "    \"\"\""
        },
        {
          "line": 142,
          "content": "    \"\"\""
        },
        {
          "line": 168,
          "content": "        ''', values)"
        },
        {
          "line": 172,
          "content": "        if updated_count > 0:"
        },
        {
          "line": 174,
          "content": "            return True"
        },
        {
          "line": 177,
          "content": "            return False"
        },
        {
          "line": 183,
          "content": "def get_task_status_repository():"
        },
        {
          "line": 184,
          "content": "    \"\"\"获取全局任务状态仓库实例\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/repositories/dimension_result_repository.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "\"\"\""
        },
        {
          "line": 28,
          "content": "    \"\"\"获取数据库连接上下文管理器\"\"\""
        },
        {
          "line": 41,
          "content": "class DimensionResultRepository:"
        },
        {
          "line": 42,
          "content": "    \"\"\""
        },
        {
          "line": 62,
          "content": "    \"\"\""
        },
        {
          "line": 64,
          "content": "    def __init__(self):"
        },
        {
          "line": 68,
          "content": "    def _ensure_table_exists(self):"
        },
        {
          "line": 69,
          "content": "        \"\"\"确保表存在（如果不存在则创建）\"\"\""
        },
        {
          "line": 83,
          "content": "        \"\"\""
        },
        {
          "line": 94,
          "content": "            for index_sql in create_index_sqls:"
        },
        {
          "line": 99,
          "content": "    def save_dimension("
        },
        {
          "line": 110,
          "content": "        \"\"\""
        },
        {
          "line": 125,
          "content": "        \"\"\""
        },
        {
          "line": 128,
          "content": "            data_json = json.dumps(data, ensure_ascii=False, default=str) if data else None"
        },
        {
          "line": 136,
          "content": "                ''', ("
        },
        {
          "line": 168,
          "content": "        \"\"\""
        },
        {
          "line": 177,
          "content": "        \"\"\""
        },
        {
          "line": 188,
          "content": "                    ''', (execution_id, dimension_type))"
        },
        {
          "line": 194,
          "content": "                    ''', (execution_id,))"
        },
        {
          "line": 231,
          "content": "        \"\"\""
        },
        {
          "line": 239,
          "content": "        \"\"\""
        },
        {
          "line": 286,
          "content": "        \"\"\""
        },
        {
          "line": 297,
          "content": "        \"\"\""
        },
        {
          "line": 305,
          "content": "                ''', (status, error_message, execution_id, dimension_name))"
        },
        {
          "line": 309,
          "content": "                if updated_count > 0:"
        },
        {
          "line": 314,
          "content": "                    return True"
        },
        {
          "line": 320,
          "content": "                    return False"
        },
        {
          "line": 327,
          "content": "            return False"
        },
        {
          "line": 329,
          "content": "    def delete_dimensions_by_execution(self, execution_id: str) -> int:"
        },
        {
          "line": 330,
          "content": "        \"\"\""
        },
        {
          "line": 338,
          "content": "        \"\"\""
        },
        {
          "line": 345,
          "content": "                ''', (execution_id,))"
        },
        {
          "line": 367,
          "content": "    \"\"\"获取全局维度结果仓库实例\"\"\""
        },
        {
          "line": 369,
          "content": "    if _dimension_repo is None:"
        },
        {
          "line": 371,
          "content": "    return _dimension_repo"
        },
        {
          "line": 375,
          "content": "def save_dimension_result("
        },
        {
          "line": 385,
          "content": "    \"\"\""
        },
        {
          "line": 398,
          "content": "    \"\"\""
        },
        {
          "line": 399,
          "content": "    return get_dimension_repository().save_dimension("
        },
        {
          "line": 411,
          "content": "def save_dimension_results_batch("
        },
        {
          "line": 415,
          "content": "    \"\"\""
        },
        {
          "line": 424,
          "content": "    \"\"\""
        },
        {
          "line": 434,
          "content": "            for result in results:"
        },
        {
          "line": 435,
          "content": "                if result.get('status') != 'success' or not result.get('data'):"
        },
        {
          "line": 440,
          "content": "                score = max(0, 100 - (rank - 1) * 10) if rank > 0 else None"
        },
        {
          "line": 446,
          "content": "                ''', ("
        },
        {
          "line": 471,
          "content": "    \"\"\"获取维度结果\"\"\""
        },
        {
          "line": 472,
          "content": "    return get_dimension_repository().get_dimensions_by_execution(execution_id)"
        },
        {
          "line": 478,
          "content": "def get_dimension_repository():"
        },
        {
          "line": 479,
          "content": "    \"\"\"获取全局维度结果仓库实例\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/repositories/report_snapshot_repository.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "\"\"\""
        },
        {
          "line": 28,
          "content": "    \"\"\"获取数据库连接上下文管理器\"\"\""
        },
        {
          "line": 41,
          "content": "class ReportSnapshotRepository:"
        },
        {
          "line": 42,
          "content": "    \"\"\""
        },
        {
          "line": 60,
          "content": "    \"\"\""
        },
        {
          "line": 62,
          "content": "    def __init__(self):"
        },
        {
          "line": 66,
          "content": "    def _ensure_table_exists(self):"
        },
        {
          "line": 67,
          "content": "        \"\"\"确保表存在（如果不存在则创建）\"\"\""
        },
        {
          "line": 82,
          "content": "        \"\"\""
        },
        {
          "line": 96,
          "content": "        \"\"\""
        },
        {
          "line": 119,
          "content": "        \"\"\""
        },
        {
          "line": 133,
          "content": "        \"\"\""
        },
        {
          "line": 154,
          "content": "                ''', ("
        },
        {
          "line": 169,
          "content": "            return execution_id"
        },
        {
          "line": 175,
          "content": "    def get_snapshot(self, execution_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 176,
          "content": "        \"\"\""
        },
        {
          "line": 184,
          "content": "        \"\"\""
        },
        {
          "line": 192,
          "content": "                ''', (execution_id,))"
        },
        {
          "line": 225,
          "content": "        \"\"\""
        },
        {
          "line": 235,
          "content": "        \"\"\""
        },
        {
          "line": 252,
          "content": "                ''', (user_id, limit, offset))"
        },
        {
          "line": 255,
          "content": "                for row in cursor.fetchall():"
        },
        {
          "line": 270,
          "content": "                return results"
        },
        {
          "line": 274,
          "content": "            return []"
        },
        {
          "line": 276,
          "content": "    def verify_consistency(self, execution_id: str) -> Tuple[bool, Optional[str]]:"
        },
        {
          "line": 277,
          "content": "        \"\"\""
        },
        {
          "line": 285,
          "content": "        \"\"\""
        },
        {
          "line": 294,
          "content": "                ''', (execution_id,))"
        },
        {
          "line": 319,
          "content": "        \"\"\""
        },
        {
          "line": 327,
          "content": "        \"\"\""
        },
        {
          "line": 334,
          "content": "                ''', (execution_id,))"
        },
        {
          "line": 338,
          "content": "                if deleted_count > 0:"
        },
        {
          "line": 340,
          "content": "                    return True"
        },
        {
          "line": 343,
          "content": "                    return False"
        },
        {
          "line": 347,
          "content": "            return False"
        },
        {
          "line": 349,
          "content": "    def get_statistics(self) -> Dict[str, Any]:"
        },
        {
          "line": 350,
          "content": "        \"\"\""
        },
        {
          "line": 355,
          "content": "        \"\"\""
        },
        {
          "line": 375,
          "content": "                ''')"
        },
        {
          "line": 386,
          "content": "                ''')"
        },
        {
          "line": 389,
          "content": "                    for row in cursor.fetchall()"
        },
        {
          "line": 392,
          "content": "                return {"
        },
        {
          "line": 402,
          "content": "            return {}"
        },
        {
          "line": 408,
          "content": "def get_snapshot_repository() -> ReportSnapshotRepository:"
        },
        {
          "line": 409,
          "content": "    \"\"\"获取全局快照仓库实例\"\"\""
        },
        {
          "line": 423,
          "content": "    \"\"\""
        },
        {
          "line": 428,
          "content": "    \"\"\""
        },
        {
          "line": 438,
          "content": "    \"\"\""
        },
        {
          "line": 443,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 7,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/feature_flags.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 7,
          "content": "    from wechat_backend.v2.feature_flags import should_use_v2, FEATURE_FLAGS"
        },
        {
          "line": 9,
          "content": "    if should_use_v2(user_id):"
        },
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 79,
          "content": "    \"\"\""
        },
        {
          "line": 88,
          "content": "    \"\"\""
        },
        {
          "line": 96,
          "content": "    \"\"\""
        },
        {
          "line": 104,
          "content": "    \"\"\""
        },
        {
          "line": 109,
          "content": "    \"\"\""
        },
        {
          "line": 120,
          "content": "    \"\"\""
        },
        {
          "line": 128,
          "content": "    \"\"\""
        },
        {
          "line": 142,
          "content": "    \"\"\""
        },
        {
          "line": 162,
          "content": "    \"\"\""
        },
        {
          "line": 167,
          "content": "    \"\"\""
        },
        {
          "line": 172,
          "content": "    \"\"\""
        },
        {
          "line": 180,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/exceptions.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "\"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\"诊断系统基础异常类"
        },
        {
          "line": 27,
          "content": "    \"\"\""
        },
        {
          "line": 42,
          "content": "        \"\"\"转换为字典格式\"\"\""
        },
        {
          "line": 43,
          "content": "        return {"
        },
        {
          "line": 50,
          "content": "class DiagnosisTimeoutError(DiagnosisError):"
        },
        {
          "line": 51,
          "content": "    \"\"\"诊断任务执行超时异常\"\"\""
        },
        {
          "line": 72,
          "content": "    \"\"\"数据验证异常\"\"\""
        },
        {
          "line": 77,
          "content": "    def __init__("
        },
        {
          "line": 90,
          "content": "class DiagnosisStateError(DiagnosisError):"
        },
        {
          "line": 91,
          "content": "    \"\"\"状态机异常\"\"\""
        },
        {
          "line": 112,
          "content": "    \"\"\"AI 平台调用异常\"\"\""
        },
        {
          "line": 117,
          "content": "    def __init__("
        },
        {
          "line": 132,
          "content": "class DataPersistenceError(DiagnosisError):"
        },
        {
          "line": 133,
          "content": "    \"\"\"数据持久化异常\"\"\""
        },
        {
          "line": 152,
          "content": "    \"\"\"数据库操作异常\"\"\""
        },
        {
          "line": 157,
          "content": "    def __init__("
        },
        {
          "line": 170,
          "content": "class DeadLetterQueueError(DiagnosisError):"
        },
        {
          "line": 171,
          "content": "    \"\"\"死信队列相关异常\"\"\""
        },
        {
          "line": 178,
          "content": "    \"\"\"重试耗尽异常\"\"\""
        },
        {
          "line": 183,
          "content": "    def __init__(self, original_error: Exception, retry_count: int):"
        },
        {
          "line": 192,
          "content": "class RepositoryError(DiagnosisError):"
        },
        {
          "line": 193,
          "content": "    \"\"\"仓库操作异常\"\"\""
        },
        {
          "line": 214,
          "content": "    \"\"\"统计算法基础异常类"
        },
        {
          "line": 223,
          "content": "    \"\"\""
        },
        {
          "line": 230,
          "content": "    \"\"\"统计数据验证异常"
        },
        {
          "line": 233,
          "content": "    \"\"\""
        },
        {
          "line": 254,
          "content": "    \"\"\"统计算法配置异常"
        },
        {
          "line": 257,
          "content": "    \"\"\""
        },
        {
          "line": 278,
          "content": "    \"\"\"统计算法处理异常"
        },
        {
          "line": 281,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/test_engine/progress_tracker.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Progress tracker for test execution"
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\"Status of a test execution\"\"\""
        },
        {
          "line": 25,
          "content": "class TestProgress:"
        },
        {
          "line": 26,
          "content": "    \"\"\"Represents the progress of a test execution\"\"\""
        },
        {
          "line": 49,
          "content": "    \"\"\"Tracks progress of test executions\"\"\""
        },
        {
          "line": 51,
          "content": "    def __init__(self):"
        },
        {
          "line": 56,
          "content": "    def create_execution(self, execution_id: str, total_tests: int, metadata: Dict[str, Any] = None) -> TestProgress:"
        },
        {
          "line": 57,
          "content": "        \"\"\"Create a new test execution tracking record\"\"\""
        },
        {
          "line": 69,
          "content": "        \"\"\"Update the number of running tests\"\"\""
        },
        {
          "line": 71,
          "content": "            if execution_id not in self.executions:"
        },
        {
          "line": 82,
          "content": "            api_logger.debug(f\"Updated running tests for {execution_id}: {execution.running_tests} running\")"
        },
        {
          "line": 83,
          "content": "            return execution"
        },
        {
          "line": 85,
          "content": "    def update_completed(self, execution_id: str, result: Dict[str, Any] = None, increment: int = 1) -> TestProgress:"
        },
        {
          "line": 86,
          "content": "        \"\"\"Update the number of completed tests\"\"\""
        },
        {
          "line": 95,
          "content": "            # Add result if provided"
        },
        {
          "line": 121,
          "content": "        \"\"\"Update the number of failed tests\"\"\""
        },
        {
          "line": 123,
          "content": "            if execution_id not in self.executions:"
        },
        {
          "line": 135,
          "content": "            if execution.completed_tests + execution.failed_tests >= execution.total_tests:"
        },
        {
          "line": 136,
          "content": "                if execution.failed_tests == 0:"
        },
        {
          "line": 139,
          "content": "                elif execution.failed_tests > 0 and execution.completed_tests > 0:"
        },
        {
          "line": 148,
          "content": "            api_logger.warning(f\"Updated failed tests for {execution_id}: {execution.failed_tests} failed, {execution.progress_percentage:.1f}% complete\")"
        },
        {
          "line": 149,
          "content": "            return execution"
        },
        {
          "line": 151,
          "content": "    def get_progress(self, execution_id: str) -> Optional[TestProgress]:"
        },
        {
          "line": 152,
          "content": "        \"\"\"Get the progress of a specific execution\"\"\""
        },
        {
          "line": 157,
          "content": "        \"\"\"Get all tracked executions\"\"\""
        },
        {
          "line": 159,
          "content": "            return list(self.executions.values())"
        },
        {
          "line": 161,
          "content": "    def remove_execution(self, execution_id: str) -> bool:"
        },
        {
          "line": 162,
          "content": "        \"\"\"Remove an execution from tracking\"\"\""
        },
        {
          "line": 171,
          "content": "        \"\"\"Reset an execution to initial state\"\"\""
        },
        {
          "line": 173,
          "content": "            if execution_id not in self.executions:"
        },
        {
          "line": 174,
          "content": "                return False"
        },
        {
          "line": 187,
          "content": "            return True"
        },
        {
          "line": 189,
          "content": "    def get_status_summary(self) -> Dict[str, Any]:"
        },
        {
          "line": 190,
          "content": "        \"\"\"Get a summary of all executions\"\"\""
        },
        {
          "line": 206,
          "content": "        \"\"\"Convert execution to dictionary for serialization\"\"\""
        },
        {
          "line": 207,
          "content": "        return {"
        },
        {
          "line": 215,
          "content": "            'start_time': execution.start_time.isoformat() if execution.start_time else None,"
        },
        {
          "line": 216,
          "content": "            'end_time': execution.end_time.isoformat() if execution.end_time else None,"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/test_engine/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "Contains all components for test execution, scheduling, and progress management"
        },
        {
          "line": 4,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/test_engine/test_matrix_mode.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\"测试矩阵模式执行\"\"\""
        },
        {
          "line": 32,
          "content": "        for i in range(1, 4)  # 3 个问题"
        },
        {
          "line": 36,
          "content": "    for task in test_tasks:"
        },
        {
          "line": 48,
          "content": "    def callback(task, result):"
        },
        {
          "line": 53,
          "content": "        status = \"✓\" if result.get('success') else \"✗\""
        },
        {
          "line": 55,
          "content": "        question = task.question[:40] + \"...\" if len(task.question) > 40 else task.question"
        },
        {
          "line": 76,
          "content": "    from collections import defaultdict"
        },
        {
          "line": 78,
          "content": "    for r in results:"
        },
        {
          "line": 80,
          "content": "        orig_id = task.metadata.get('original_task_id', task.id) if task.metadata else task.id"
        },
        {
          "line": 83,
          "content": "            'question_index': task.metadata.get('question_index') if task.metadata else None,"
        },
        {
          "line": 84,
          "content": "            'platform_index': task.metadata.get('platform_index') if task.metadata else None,"
        },
        {
          "line": 88,
          "content": "    for orig_id, items in grouped.items():"
        },
        {
          "line": 90,
          "content": "        platforms = set(item['platform'] for item in items)"
        },
        {
          "line": 91,
          "content": "        print(f\"  问题：{items[0]['question_index'] if items[0]['question_index'] else 'N/A'}\")"
        },
        {
          "line": 93,
          "content": "        for item in items:"
        },
        {
          "line": 94,
          "content": "            status = \"✓\" if item['success'] else \"✗\""
        },
        {
          "line": 101,
          "content": "    return stats"
        },
        {
          "line": 103,
          "content": "if __name__ == '__main__':"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/test_engine/scheduler.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 18,
          "content": "# from config_manager import Config as PlatformConfigManager"
        },
        {
          "line": 65,
          "content": "    \"\"\"Different strategies for executing tests\"\"\""
        },
        {
          "line": 73,
          "content": "class TestTask:"
        },
        {
          "line": 74,
          "content": "    \"\"\"Represents a single test task to be executed\"\"\""
        },
        {
          "line": 86,
          "content": "    \"\"\"Manages scheduling and execution of test tasks\"\"\""
        },
        {
          "line": 88,
          "content": "    def __init__(self, max_workers: int = 3, strategy: ExecutionStrategy = ExecutionStrategy.CONCURRENT):"
        },
        {
          "line": 93,
          "content": "        self.task_queue = queue.Queue()  # Add task queue for controlled execution"
        },
        {
          "line": 96,
          "content": "    def schedule_tests("
        },
        {
          "line": 103,
          "content": "        if self.strategy == ExecutionStrategy.SEQUENTIAL:"
        },
        {
          "line": 106,
          "content": "        elif self.strategy == ExecutionStrategy.CONCURRENT:"
        },
        {
          "line": 109,
          "content": "        elif self.strategy == ExecutionStrategy.BATCH:"
        },
        {
          "line": 111,
          "content": "            # For now, batch strategy defaults to sequential for reliability"
        },
        {
          "line": 113,
          "content": "        elif self.strategy == ExecutionStrategy.MATRIX:"
        },
        {
          "line": 117,
          "content": "            # Default to sequential for safety"
        },
        {
          "line": 125,
          "content": "            'completed_tasks': len([r for r in results if r.get('success', False)]),"
        },
        {
          "line": 126,
          "content": "            'failed_tasks': len([r for r in results if not r.get('success', False)]),"
        },
        {
          "line": 133,
          "content": "        return stats"
        },
        {
          "line": 135,
          "content": "    def _execute_sequential("
        },
        {
          "line": 141,
          "content": "        for task in test_tasks:"
        },
        {
          "line": 144,
          "content": "            if callback:"
        },
        {
          "line": 146,
          "content": "        return results"
        },
        {
          "line": 148,
          "content": "    def _execute_matrix("
        },
        {
          "line": 153,
          "content": "        \"\"\""
        },
        {
          "line": 157,
          "content": "        \"\"\""
        },
        {
          "line": 170,
          "content": "        for platform_name, platform_key in available_platforms:"
        },
        {
          "line": 171,
          "content": "            if self.platform_config_manager.is_platform_configured(platform_key):"
        },
        {
          "line": 177,
          "content": "        if not configured_platforms:"
        },
        {
          "line": 179,
          "content": "            return results"
        },
        {
          "line": 185,
          "content": "        for task_idx, task in enumerate(test_tasks):"
        },
        {
          "line": 186,
          "content": "            for platform_idx, (platform_name, platform_key) in enumerate(configured_platforms):"
        },
        {
          "line": 214,
          "content": "                if callback:"
        },
        {
          "line": 217,
          "content": "        return results"
        },
        {
          "line": 219,
          "content": "    def _execute_concurrent("
        },
        {
          "line": 226,
          "content": "        # Add tasks to queue for controlled execution"
        },
        {
          "line": 227,
          "content": "        for task in test_tasks:"
        },
        {
          "line": 230,
          "content": "        api_logger.info(f\"Queued {len(test_tasks)} test cases for execution with max_workers={self.max_workers}\")"
        },
        {
          "line": 234,
          "content": "        for i in range(min(len(test_tasks), self.max_workers)):  # Only submit up to max_workers initially"
        },
        {
          "line": 235,
          "content": "            if not self.task_queue.empty():"
        },
        {
          "line": 241,
          "content": "        while futures:"
        },
        {
          "line": 242,
          "content": "            # Wait for at least one task to complete"
        },
        {
          "line": 244,
          "content": "            for future, task in futures:"
        },
        {
          "line": 245,
          "content": "                if future.done():"
        },
        {
          "line": 249,
          "content": "            for future, task in completed_futures:"
        },
        {
          "line": 254,
          "content": "                    if callback:"
        },
        {
          "line": 260,
          "content": "            # Submit new tasks if available and we have capacity"
        },
        {
          "line": 261,
          "content": "            while len(futures) < self.max_workers and not self.task_queue.empty():"
        },
        {
          "line": 266,
          "content": "        return results"
        },
        {
          "line": 268,
          "content": "    def _execute_single_task_with_queue(self, task: TestTask) -> Dict[str, Any]:"
        },
        {
          "line": 269,
          "content": "        \"\"\"Executes a single test task with retry mechanism using real AI clients.\"\"\""
        },
        {
          "line": 289,
          "content": "                # Use synchronous send_prompt method instead of async query"
        },
        {
          "line": 301,
          "content": "                # Log response time for monitoring"
        },
        {
          "line": 391,
          "content": "        \"\"\"Maps display model name to actual model ID for the platform.\"\"\""
        },
        {
          "line": 407,
          "content": "        return actual_model_id"
        },
        {
          "line": 409,
          "content": "    def _execute_single_task(self, task: TestTask) -> Dict[str, Any]:"
        },
        {
          "line": 410,
          "content": "        \"\"\"Executes a single test task with retry mechanism using real AI clients.\"\"\""
        },
        {
          "line": 430,
          "content": "                # Use synchronous send_prompt method instead of async query"
        },
        {
          "line": 538,
          "content": "        \"\"\"Maps a model name to its platform name.\"\"\""
        },
        {
          "line": 566,
          "content": "        if model_name in exact_matches:"
        },
        {
          "line": 567,
          "content": "            return exact_matches[model_name]"
        },
        {
          "line": 571,
          "content": "        if 'deepseek' in model_name_lower:"
        },
        {
          "line": 572,
          "content": "            return 'deepseek'"
        },
        {
          "line": 573,
          "content": "        if '豆包' in model_name or 'doubao' in model_name_lower:"
        },
        {
          "line": 574,
          "content": "            return 'doubao'"
        },
        {
          "line": 575,
          "content": "        if '元宝' in model_name or 'hunyuan' in model_name_lower:"
        },
        {
          "line": 576,
          "content": "            return 'yuanbao'"
        },
        {
          "line": 577,
          "content": "        if '通义千问' in model_name or '千问' in model_name or 'qwen' in model_name_lower:"
        },
        {
          "line": 578,
          "content": "            return 'qwen'"
        },
        {
          "line": 579,
          "content": "        if '文心一言' in model_name:"
        },
        {
          "line": 580,
          "content": "            return 'wenxin'"
        },
        {
          "line": 581,
          "content": "        if 'ernie' in model_name_lower:"
        },
        {
          "line": 582,
          "content": "            return 'wenxin'"
        },
        {
          "line": 583,
          "content": "        if 'kimi' in model_name_lower or '月之暗面' in model_name or 'moonshot' in model_name_lower:"
        },
        {
          "line": 584,
          "content": "            return 'kimi'"
        },
        {
          "line": 585,
          "content": "        if '讯飞星火' in model_name or 'spark' in model_name_lower:"
        },
        {
          "line": 586,
          "content": "            return 'spark'"
        },
        {
          "line": 587,
          "content": "        if 'doubao' in model_name_lower:"
        },
        {
          "line": 588,
          "content": "            return 'doubao'"
        },
        {
          "line": 589,
          "content": "        if 'yuanbao' in model_name_lower:"
        },
        {
          "line": 590,
          "content": "            return 'yuanbao'"
        },
        {
          "line": 591,
          "content": "        if '智谱' in model_name or '智谱ai' in model_name_lower or 'zhipu' in model_name_lower or 'glm' in model_name_lower:"
        },
        {
          "line": 592,
          "content": "            return 'zhipu'"
        },
        {
          "line": 593,
          "content": "        if 'gpt' in model_name_lower:"
        },
        {
          "line": 594,
          "content": "            return 'openai'"
        },
        {
          "line": 595,
          "content": "        if 'claude' in model_name_lower:"
        },
        {
          "line": 596,
          "content": "            return 'anthropic'"
        },
        {
          "line": 597,
          "content": "        if 'gemini' in model_name_lower:"
        },
        {
          "line": 598,
          "content": "            return 'google'"
        },
        {
          "line": 600,
          "content": "        return 'unknown'"
        },
        {
          "line": 602,
          "content": "    def shutdown(self):"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/test_engine/executor.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Test Executor - Main entry point for test execution"
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\"Main executor that coordinates test execution with progress tracking\"\"\""
        },
        {
          "line": 22,
          "content": "    def __init__(self, max_workers: int = 1, strategy: ExecutionStrategy = ExecutionStrategy.SEQUENTIAL):"
        },
        {
          "line": 23,
          "content": "        \"\"\""
        },
        {
          "line": 29,
          "content": "        \"\"\""
        },
        {
          "line": 37,
          "content": "    def execute_tests("
        },
        {
          "line": 45,
          "content": "        \"\"\""
        },
        {
          "line": 57,
          "content": "        \"\"\""
        },
        {
          "line": 61,
          "content": "        api_logger.info(f\"Starting execution {execution_id} for {total_tests} test cases\")"
        },
        {
          "line": 63,
          "content": "        # Create progress tracking for this execution"
        },
        {
          "line": 76,
          "content": "        main_brand = test_cases[0].brand_name if test_cases else 'unknown'"
        },
        {
          "line": 77,
          "content": "        all_brands = list(set(case.brand_name for case in test_cases))"
        },
        {
          "line": 79,
          "content": "        api_logger.info(f\"Created RealtimeAnalyzer for execution {execution_id} - Brand: {main_brand}, All brands: {all_brands}\")"
        },
        {
          "line": 82,
          "content": "        questions = list(set(case.question for case in test_cases))"
        },
        {
          "line": 84,
          "content": "        api_logger.info(f\"Created IncrementalAggregator for execution {execution_id} - Questions: {len(questions)}\")"
        },
        {
          "line": 88,
          "content": "        api_logger.info(f\"Created RealtimePersistence for execution {execution_id}\")"
        },
        {
          "line": 90,
          "content": "        # Convert TestCases to TestTasks for the scheduler"
        },
        {
          "line": 92,
          "content": "        for test_case in test_cases:"
        },
        {
          "line": 103,
          "content": "        # Define callback for progress updates and checkpoint saving"
        },
        {
          "line": 104,
          "content": "        def progress_callback(task: TestTask, result: Dict[str, Any]):"
        },
        {
          "line": 105,
          "content": "            if result.get('success', False):"
        },
        {
          "line": 114,
          "content": "                if model_name.lower() in ['豆包', 'doubao']:"
        },
        {
          "line": 116,
          "content": "                elif model_name.lower() in ['deepseek', 'deepseekr1']:"
        },
        {
          "line": 118,
          "content": "                elif model_name.lower() in ['qwen', '通义千问', '千问']:"
        },
        {
          "line": 120,
          "content": "                elif model_name.lower() in ['zhipu', '智谱ai', '智谱']:"
        },
        {
          "line": 128,
          "content": "                if isinstance(result_dict, dict):"
        },
        {
          "line": 139,
          "content": "                    'error': result.get('error', '') if not result.get('success', False) else '',"
        },
        {
          "line": 165,
          "content": "            if analyzer:"
        },
        {
          "line": 176,
          "content": "            if aggregator:"
        },
        {
          "line": 182,
          "content": "                if persistence_service and current_progress.completed_tests % 3 == 0:"
        },
        {
          "line": 189,
          "content": "            # Call the external progress update callback if provided"
        },
        {
          "line": 190,
          "content": "            if on_progress_update:"
        },
        {
          "line": 193,
          "content": "        import threading"
        },
        {
          "line": 194,
          "content": "        import concurrent.futures"
        },
        {
          "line": 195,
          "content": "        from functools import partial"
        },
        {
          "line": 198,
          "content": "        import time"
        },
        {
          "line": 201,
          "content": "        if timeout > 0:"
        },
        {
          "line": 202,
          "content": "            if self.scheduler.strategy == ExecutionStrategy.SEQUENTIAL:"
        },
        {
          "line": 204,
          "content": "                api_logger.info(f\"Running sequential execution without ThreadPoolExecutor overhead for stability\")"
        },
        {
          "line": 209,
          "content": "                if elapsed_time > timeout:"
        },
        {
          "line": 214,
          "content": "                # Create a partial function with the arguments"
        },
        {
          "line": 241,
          "content": "        return results"
        },
        {
          "line": 243,
          "content": "    def get_execution_progress(self, execution_id: str) -> TestProgress:"
        },
        {
          "line": 244,
          "content": "        \"\"\"Get the progress of a specific execution\"\"\""
        },
        {
          "line": 248,
          "content": "        \"\"\"Get all tracked executions\"\"\""
        },
        {
          "line": 249,
          "content": "        return self.progress_tracker.get_all_executions()"
        },
        {
          "line": 251,
          "content": "    def cancel_execution(self, execution_id: str) -> bool:"
        },
        {
          "line": 252,
          "content": "        \"\"\"Cancel an ongoing execution (currently just marks as failed)\"\"\""
        },
        {
          "line": 267,
          "content": "        \"\"\"Shutdown the executor and cleanup resources\"\"\""
        },
        {
          "line": 273,
          "content": "def run_brand_cognition_test("
        },
        {
          "line": 278,
          "content": "    max_workers: int = 3  # Reduced from 10 to 3 to prevent API timeouts"
        },
        {
          "line": 280,
          "content": "    \"\"\""
        },
        {
          "line": 292,
          "content": "    \"\"\""
        },
        {
          "line": 293,
          "content": "    from question_system import TestCaseGenerator"
        },
        {
          "line": 302,
          "content": "    def progress_callback(execution_id, progress):"
        },
        {
          "line": 310,
          "content": "    return results"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/question_system/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "Contains all components for question management and test case generation"
        },
        {
          "line": 4,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/question_system/question_templates.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "    \"\"\"Categories of questions for brand cognition testing\"\"\""
        },
        {
          "line": 23,
          "content": "class QuestionTemplate:"
        },
        {
          "line": 24,
          "content": "    \"\"\"Represents a question template with category and content\"\"\""
        },
        {
          "line": 35,
          "content": "    \"\"\"Represents a custom question provided by the user\"\"\""
        },
        {
          "line": 42,
          "content": "class QuestionManager:"
        },
        {
          "line": 43,
          "content": "    \"\"\"Manages standard question templates and custom questions\"\"\""
        },
        {
          "line": 46,
          "content": "        \"\"\"Initialize with standard question templates\"\"\""
        },
        {
          "line": 49,
          "content": "    def _load_standard_templates(self) -> List[QuestionTemplate]:"
        },
        {
          "line": 50,
          "content": "        \"\"\"Load standard question templates for brand cognition testing\"\"\""
        },
        {
          "line": 163,
          "content": "        \"\"\"Get all templates for a specific category\"\"\""
        },
        {
          "line": 164,
          "content": "        return [t for t in self.standard_templates if t.category == category and t.is_active]"
        },
        {
          "line": 166,
          "content": "    def get_all_templates(self) -> List[QuestionTemplate]:"
        },
        {
          "line": 167,
          "content": "        \"\"\"Get all active standard templates\"\"\""
        },
        {
          "line": 171,
          "content": "        \"\"\""
        },
        {
          "line": 179,
          "content": "        \"\"\""
        },
        {
          "line": 218,
          "content": "        \"\"\""
        },
        {
          "line": 226,
          "content": "        \"\"\""
        },
        {
          "line": 236,
          "content": "        # Capitalize first letter if it's lowercase"
        },
        {
          "line": 243,
          "content": "        \"\"\""
        },
        {
          "line": 244,
          "content": "        Create custom question objects from raw question strings"
        },
        {
          "line": 251,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/question_system/test_case_generator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 2,
          "content": "Test case generator for AI platform testing"
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "    \"\"\"Status of a test case\"\"\""
        },
        {
          "line": 22,
          "content": "class TestCase:"
        },
        {
          "line": 23,
          "content": "    \"\"\"Represents a single test case for AI platform evaluation\"\"\""
        },
        {
          "line": 40,
          "content": "        \"\"\"Mark the test case as running\"\"\""
        },
        {
          "line": 43,
          "content": "        api_logger.info(f\"Started executing test case {self.id} for model {self.ai_model}\")"
        },
        {
          "line": 45,
          "content": "    def complete_execution(self, result: Dict[str, Any]):"
        },
        {
          "line": 46,
          "content": "        \"\"\"Mark the test case as completed with results\"\"\""
        },
        {
          "line": 53,
          "content": "        \"\"\"Mark the test case as failed\"\"\""
        },
        {
          "line": 57,
          "content": "        api_logger.error(f\"Failed test case {self.id} for model {self.ai_model}: {error_message}\")"
        },
        {
          "line": 60,
          "content": "class TestCaseGenerator:"
        },
        {
          "line": 61,
          "content": "    \"\"\"Generates test cases for AI platform evaluation\"\"\""
        },
        {
          "line": 72,
          "content": "        \"\"\""
        },
        {
          "line": 73,
          "content": "        Generate test cases for the given inputs"
        },
        {
          "line": 82,
          "content": "        \"\"\""
        },
        {
          "line": 108,
          "content": "        \"\"\""
        },
        {
          "line": 120,
          "content": "        \"\"\""
        },
        {
          "line": 123,
          "content": "        # Add custom questions if provided"
        },
        {
          "line": 130,
          "content": "        # Add default questions if requested"
        },
        {
          "line": 132,
          "content": "            # Use default questions if no custom questions provided"
        },
        {
          "line": 151,
          "content": "        \"\"\""
        },
        {
          "line": 152,
          "content": "        Execute test cases sequentially (for simpler implementation)"
        },
        {
          "line": 160,
          "content": "        \"\"\""
        },
        {
          "line": 167,
          "content": "                # Create AI client for this model"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/sync/sync_storage.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "\"\"\""
        },
        {
          "line": 54,
          "content": "\"\"\""
        },
        {
          "line": 72,
          "content": "\"\"\""
        },
        {
          "line": 77,
          "content": "    \"\"\"同步数据存储管理器\"\"\""
        },
        {
          "line": 79,
          "content": "    def __init__(self, db_path: str = None):"
        },
        {
          "line": 84,
          "content": "    def get_connection(self):"
        },
        {
          "line": 85,
          "content": "        \"\"\"获取数据库连接\"\"\""
        },
        {
          "line": 95,
          "content": "        \"\"\"初始化数据库表\"\"\""
        },
        {
          "line": 100,
          "content": "            for index_sql in CREATE_SYNC_RESULTS_INDEXES:"
        },
        {
          "line": 104,
          "content": "    def save_result(self, user_id: str, result: Dict[str, Any]) -> bool:"
        },
        {
          "line": 105,
          "content": "        \"\"\""
        },
        {
          "line": 114,
          "content": "        \"\"\""
        },
        {
          "line": 116,
          "content": "        if not result_id:"
        },
        {
          "line": 118,
          "content": "            return False"
        },
        {
          "line": 133,
          "content": "                if exists:"
        },
        {
          "line": 149,
          "content": "                    \"\"\", ("
        },
        {
          "line": 171,
          "content": "                    \"\"\", ("
        },
        {
          "line": 189,
          "content": "                return True"
        },
        {
          "line": 193,
          "content": "            return False"
        },
        {
          "line": 195,
          "content": "    def get_results(self, user_id: str,"
        },
        {
          "line": 198,
          "content": "        \"\"\""
        },
        {
          "line": 208,
          "content": "        \"\"\""
        },
        {
          "line": 213,
          "content": "                if last_sync_timestamp:"
        },
        {
          "line": 221,
          "content": "                    \"\"\", (user_id, last_sync_timestamp, limit))"
        },
        {
          "line": 229,
          "content": "                    \"\"\", (user_id, limit))"
        },
        {
          "line": 234,
          "content": "                for row in rows:"
        },
        {
          "line": 237,
          "content": "                    for field in ['ai_models_used', 'questions_used', 'results_summary', 'detailed_results']:"
        },
        {
          "line": 239,
          "content": "                            if result.get(field):"
        },
        {
          "line": 242,
          "content": "                            result[field] = [] if field in ['ai_models_used', 'questions_used'] else {}"
        },
        {
          "line": 246,
          "content": "                return results"
        },
        {
          "line": 250,
          "content": "            return []"
        },
        {
          "line": 252,
          "content": "    def delete_result(self, user_id: str, result_id: str) -> bool:"
        },
        {
          "line": 253,
          "content": "        \"\"\""
        },
        {
          "line": 262,
          "content": "        \"\"\""
        },
        {
          "line": 271,
          "content": "                \"\"\", (result_id, user_id))"
        },
        {
          "line": 288,
          "content": "        \"\"\"更新用户元数据\"\"\""
        },
        {
          "line": 298,
          "content": "        \"\"\", (user_id,))"
        },
        {
          "line": 310,
          "content": "        \"\"\", ("
        },
        {
          "line": 317,
          "content": "    def get_user_metadata(self, user_id: str) -> Dict[str, Any]:"
        },
        {
          "line": 318,
          "content": "        \"\"\"获取用户元数据\"\"\""
        },
        {
          "line": 343,
          "content": "        \"\"\""
        },
        {
          "line": 352,
          "content": "        \"\"\""
        },
        {
          "line": 365,
          "content": "                \"\"\", (user_id, cutoff_date))"
        },
        {
          "line": 372,
          "content": "                if deleted_count > 0:"
        },
        {
          "line": 375,
          "content": "                return deleted_count"
        },
        {
          "line": 379,
          "content": "            return 0"
        },
        {
          "line": 381,
          "content": "    def get_all_results_count(self) -> int:"
        },
        {
          "line": 382,
          "content": "        \"\"\"获取所有结果数量\"\"\""
        },
        {
          "line": 400,
          "content": "    \"\"\"获取同步存储实例\"\"\""
        },
        {
          "line": 402,
          "content": "    if _sync_storage is None:"
        },
        {
          "line": 404,
          "content": "    return _sync_storage"
        },
        {
          "line": 407,
          "content": "def init_sync_storage() -> SyncStorageManager:"
        },
        {
          "line": 408,
          "content": "    \"\"\"初始化同步存储\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/monitoring/alert_system.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "    \"\"\"告警严重程度\"\"\""
        },
        {
          "line": 24,
          "content": "class AlertCondition:"
        },
        {
          "line": 25,
          "content": "    \"\"\"告警条件\"\"\""
        },
        {
          "line": 33,
          "content": "        \"\"\""
        },
        {
          "line": 40,
          "content": "        \"\"\""
        },
        {
          "line": 50,
          "content": "        \"\"\"评估当前值是否满足告警条件\"\"\""
        },
        {
          "line": 53,
          "content": "        if self.comparison == \">\":"
        },
        {
          "line": 55,
          "content": "        elif self.comparison == \">=\":"
        },
        {
          "line": 57,
          "content": "        elif self.comparison == \"<\":"
        },
        {
          "line": 59,
          "content": "        elif self.comparison == \"<=\":"
        },
        {
          "line": 61,
          "content": "        elif self.comparison == \"==\":"
        },
        {
          "line": 63,
          "content": "        elif self.comparison == \"!=\":"
        },
        {
          "line": 67,
          "content": "            return False"
        },
        {
          "line": 70,
          "content": "        if condition_met:"
        },
        {
          "line": 78,
          "content": "        return self.violation_count >= self.consecutive_violations"
        },
        {
          "line": 81,
          "content": "class Alert:"
        },
        {
          "line": 82,
          "content": "    \"\"\"告警实体\"\"\""
        },
        {
          "line": 90,
          "content": "        \"\"\""
        },
        {
          "line": 97,
          "content": "        \"\"\""
        },
        {
          "line": 109,
          "content": "        \"\"\"检查告警条件是否满足\"\"\""
        },
        {
          "line": 110,
          "content": "        return self.condition.evaluate(current_value)"
        },
        {
          "line": 112,
          "content": "    def trigger(self):"
        },
        {
          "line": 113,
          "content": "        \"\"\"触发告警\"\"\""
        },
        {
          "line": 122,
          "content": "        \"\"\"检查是否应该发送通知（考虑抑制时间）\"\"\""
        },
        {
          "line": 123,
          "content": "        if not self.active:"
        },
        {
          "line": 124,
          "content": "            return False"
        },
        {
          "line": 126,
          "content": "        if self.last_notified_at is None:"
        },
        {
          "line": 127,
          "content": "            return True"
        },
        {
          "line": 130,
          "content": "        return time_since_last_notification >= timedelta(minutes=self.suppression_duration_minutes)"
        },
        {
          "line": 132,
          "content": "    def notify(self):"
        },
        {
          "line": 133,
          "content": "        \"\"\"发送通知\"\"\""
        },
        {
          "line": 140,
          "content": "        \"\"\"停用告警\"\"\""
        },
        {
          "line": 145,
          "content": "class AlertSystem:"
        },
        {
          "line": 146,
          "content": "    \"\"\"告警系统\"\"\""
        },
        {
          "line": 157,
          "content": "        \"\"\"添加告警\"\"\""
        },
        {
          "line": 162,
          "content": "    def remove_alert(self, alert_name: str):"
        },
        {
          "line": 163,
          "content": "        \"\"\"移除告警\"\"\""
        },
        {
          "line": 170,
          "content": "        \"\"\"添加告警回调函数\"\"\""
        },
        {
          "line": 173,
          "content": "    def evaluate_alerts(self, metric_values: Dict[str, float]):"
        },
        {
          "line": 174,
          "content": "        \"\"\"评估所有告警\"\"\""
        },
        {
          "line": 199,
          "content": "        \"\"\"启动监控线程\"\"\""
        },
        {
          "line": 200,
          "content": "        if not self.is_running:"
        },
        {
          "line": 206,
          "content": "    def stop_monitoring(self):"
        },
        {
          "line": 207,
          "content": "        \"\"\"停止监控线程\"\"\""
        },
        {
          "line": 214,
          "content": "        \"\"\"监控循环\"\"\""
        },
        {
          "line": 215,
          "content": "        from wechat_backend.monitoring.metrics_collector import get_metrics_collector"
        },
        {
          "line": 217,
          "content": "        while self.is_running:"
        },
        {
          "line": 236,
          "content": "    def get_active_alerts(self) -> List[Alert]:"
        },
        {
          "line": 237,
          "content": "        \"\"\"获取活跃的告警\"\"\""
        },
        {
          "line": 247,
          "content": "    \"\"\"获取告警系统实例\"\"\""
        },
        {
          "line": 249,
          "content": "    if _alert_system is None:"
        },
        {
          "line": 251,
          "content": "    return _alert_system"
        },
        {
          "line": 254,
          "content": "def add_alert(name: str, condition: AlertCondition, severity: AlertSeverity, **kwargs):"
        },
        {
          "line": 255,
          "content": "    \"\"\"便捷函数：添加告警\"\"\""
        },
        {
          "line": 262,
          "content": "    \"\"\"便捷函数：启动告警监控\"\"\""
        },
        {
          "line": 267,
          "content": "def stop_alert_monitoring():"
        },
        {
          "line": 268,
          "content": "    \"\"\"便捷函数：停止告警监控\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/monitoring/alert_manager.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "    from wechat_backend.monitoring.alert_manager import AlertManager"
        },
        {
          "line": 23,
          "content": "\"\"\""
        },
        {
          "line": 40,
          "content": "    \"\"\"告警级别\"\"\""
        },
        {
          "line": 47,
          "content": "class AlertManager:"
        },
        {
          "line": 48,
          "content": "    \"\"\"告警管理器\"\"\""
        },
        {
          "line": 55,
          "content": "        \"\"\"加载告警历史\"\"\""
        },
        {
          "line": 56,
          "content": "        if ALERT_HISTORY_FILE.exists():"
        },
        {
          "line": 59,
          "content": "                    return json.load(f)"
        },
        {
          "line": 63,
          "content": "                return []"
        },
        {
          "line": 64,
          "content": "        return []"
        },
        {
          "line": 66,
          "content": "    def _save_alert_history(self):"
        },
        {
          "line": 67,
          "content": "        \"\"\"保存告警历史\"\"\""
        },
        {
          "line": 77,
          "content": "        \"\"\"加载告警阈值配置\"\"\""
        },
        {
          "line": 78,
          "content": "        return {"
        },
        {
          "line": 86,
          "content": "    def check_and_alert("
        },
        {
          "line": 94,
          "content": "        \"\"\""
        },
        {
          "line": 106,
          "content": "        \"\"\""
        },
        {
          "line": 108,
          "content": "        if threshold is None:"
        },
        {
          "line": 109,
          "content": "            if metric_name in self.alert_thresholds:"
        },
        {
          "line": 112,
          "content": "        if threshold is None:"
        },
        {
          "line": 113,
          "content": "            return False"
        },
        {
          "line": 116,
          "content": "        if value <= threshold:"
        },
        {
          "line": 117,
          "content": "            return False"
        },
        {
          "line": 135,
          "content": "        if alert_level == AlertLevel.CRITICAL:"
        },
        {
          "line": 137,
          "content": "        elif alert_level == AlertLevel.ERROR:"
        },
        {
          "line": 139,
          "content": "        elif alert_level == AlertLevel.WARNING:"
        },
        {
          "line": 144,
          "content": "        return True"
        },
        {
          "line": 146,
          "content": "    def check_error_rate(self, error_count: int, total_count: int):"
        },
        {
          "line": 147,
          "content": "        \"\"\"检查错误率\"\"\""
        },
        {
          "line": 161,
          "content": "        \"\"\"检查响应时间\"\"\""
        },
        {
          "line": 169,
          "content": "    def check_ai_failure_rate(self, failure_count: int, total_count: int):"
        },
        {
          "line": 170,
          "content": "        \"\"\"检查 AI 调用失败率\"\"\""
        },
        {
          "line": 184,
          "content": "        \"\"\"检查认证失败率\"\"\""
        },
        {
          "line": 185,
          "content": "        if total_count == 0:"
        },
        {
          "line": 197,
          "content": "    def get_recent_alerts(self, limit: int = 10, level: Optional[str] = None) -> List[Dict]:"
        },
        {
          "line": 198,
          "content": "        \"\"\"获取最近的告警\"\"\""
        },
        {
          "line": 207,
          "content": "        \"\"\"获取告警统计\"\"\""
        },
        {
          "line": 217,
          "content": "        for alert in recent_alerts:"
        },
        {
          "line": 224,
          "content": "        if recent_alerts:"
        },
        {
          "line": 227,
          "content": "        return summary"
        },
        {
          "line": 229,
          "content": "    def clear_old_alerts(self, days: int = 7):"
        },
        {
          "line": 230,
          "content": "        \"\"\"清理旧告警\"\"\""
        },
        {
          "line": 247,
          "content": "    \"\"\"获取告警管理器实例\"\"\""
        },
        {
          "line": 249,
          "content": "    if _alert_manager is None:"
        },
        {
          "line": 251,
          "content": "    return _alert_manager"
        },
        {
          "line": 255,
          "content": "def monitor_execution(metric_name: str):"
        },
        {
          "line": 256,
          "content": "    \"\"\""
        },
        {
          "line": 263,
          "content": "    \"\"\""
        },
        {
          "line": 264,
          "content": "    from functools import wraps"
        },
        {
          "line": 265,
          "content": "    import time"
        },
        {
          "line": 267,
          "content": "    def decorator(func):"
        },
        {
          "line": 269,
          "content": "        def wrapper(*args, **kwargs):"
        },
        {
          "line": 272,
          "content": "                return func(*args, **kwargs)"
        },
        {
          "line": 278,
          "content": "        return wrapper"
        },
        {
          "line": 280,
          "content": "    return decorator"
        },
        {
          "line": 283,
          "content": "if __name__ == '__main__':"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/monitoring/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\"监控模块初始化\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/monitoring/logging_enhancements.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 21,
          "content": "    \"\"\"日志事件类型\"\"\""
        },
        {
          "line": 31,
          "content": "class StructuredLogger:"
        },
        {
          "line": 32,
          "content": "    \"\"\"结构化日志记录器\"\"\""
        },
        {
          "line": 38,
          "content": "        \"\"\"记录结构化日志\"\"\""
        },
        {
          "line": 48,
          "content": "    def info(self, event_type: LogEventType, message: str, **kwargs):"
        },
        {
          "line": 49,
          "content": "        \"\"\"信息级别日志\"\"\""
        },
        {
          "line": 53,
          "content": "        \"\"\"警告级别日志\"\"\""
        },
        {
          "line": 56,
          "content": "    def error(self, event_type: LogEventType, message: str, **kwargs):"
        },
        {
          "line": 57,
          "content": "        \"\"\"错误级别日志\"\"\""
        },
        {
          "line": 61,
          "content": "        \"\"\"严重级别日志\"\"\""
        },
        {
          "line": 65,
          "content": "class AuditLogger(StructuredLogger):"
        },
        {
          "line": 66,
          "content": "    \"\"\"审计日志记录器\"\"\""
        },
        {
          "line": 72,
          "content": "        \"\"\"记录API访问\"\"\""
        },
        {
          "line": 83,
          "content": "    def log_authentication(self, username: str, success: bool, ip_address: str = None, reason: str = None):"
        },
        {
          "line": 84,
          "content": "        \"\"\"记录身份验证\"\"\""
        },
        {
          "line": 95,
          "content": "        \"\"\"记录授权\"\"\""
        },
        {
          "line": 98,
          "content": "            f\"授权{'通过' if granted else '拒绝'}\","
        },
        {
          "line": 106,
          "content": "    def log_data_access(self, user_id: str, resource: str, action: str, success: bool):"
        },
        {
          "line": 107,
          "content": "        \"\"\"记录数据访问\"\"\""
        },
        {
          "line": 118,
          "content": "        \"\"\"记录配置变更\"\"\""
        },
        {
          "line": 129,
          "content": "class SecurityLogger(StructuredLogger):"
        },
        {
          "line": 130,
          "content": "    \"\"\"安全日志记录器\"\"\""
        },
        {
          "line": 136,
          "content": "        \"\"\"记录安全事件\"\"\""
        },
        {
          "line": 145,
          "content": "    def log_potential_attack(self, attack_type: str, ip_address: str, user_agent: str = None, **details):"
        },
        {
          "line": 146,
          "content": "        \"\"\"记录潜在攻击\"\"\""
        },
        {
          "line": 157,
          "content": "        \"\"\"记录暴力破解尝试\"\"\""
        },
        {
          "line": 166,
          "content": "    def log_unauthorized_access(self, user_id: str, resource: str, ip_address: str):"
        },
        {
          "line": 167,
          "content": "        \"\"\"记录未授权访问\"\"\""
        },
        {
          "line": 177,
          "content": "        \"\"\"记录权限提升尝试\"\"\""
        },
        {
          "line": 187,
          "content": "class APILogger(StructuredLogger):"
        },
        {
          "line": 188,
          "content": "    \"\"\"API日志记录器\"\"\""
        },
        {
          "line": 199,
          "content": "        \"\"\"记录API请求\"\"\""
        },
        {
          "line": 210,
          "content": "    def log_response(self,"
        },
        {
          "line": 216,
          "content": "        \"\"\"记录API响应\"\"\""
        },
        {
          "line": 233,
          "content": "        \"\"\"记录API错误\"\"\""
        },
        {
          "line": 251,
          "content": "def get_audit_logger() -> AuditLogger:"
        },
        {
          "line": 252,
          "content": "    \"\"\"获取审计日志记录器\"\"\""
        },
        {
          "line": 260,
          "content": "    \"\"\"获取安全日志记录器\"\"\""
        },
        {
          "line": 262,
          "content": "    if _security_logger is None:"
        },
        {
          "line": 264,
          "content": "    return _security_logger"
        },
        {
          "line": 267,
          "content": "def get_api_logger() -> APILogger:"
        },
        {
          "line": 268,
          "content": "    \"\"\"获取API日志记录器\"\"\""
        },
        {
          "line": 277,
          "content": "    \"\"\"便捷函数：记录API访问\"\"\""
        },
        {
          "line": 282,
          "content": "def log_security_event(event_type: str, severity: str, description: str, **details):"
        },
        {
          "line": 283,
          "content": "    \"\"\"便捷函数：记录安全事件\"\"\""
        },
        {
          "line": 289,
          "content": "    \"\"\"便捷函数：记录API请求\"\"\""
        },
        {
          "line": 294,
          "content": "def log_api_response(endpoint: str, status_code: int, response_time: float, response_size: int = 0, user_id: str = None):"
        },
        {
          "line": 295,
          "content": "    \"\"\"便捷函数：记录API响应\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/monitoring/metrics_collector.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\"指标类型枚举\"\"\""
        },
        {
          "line": 26,
          "content": "class MetricsCollector:"
        },
        {
          "line": 27,
          "content": "    \"\"\"指标收集器\"\"\""
        },
        {
          "line": 30,
          "content": "        \"\"\""
        },
        {
          "line": 33,
          "content": "        \"\"\""
        },
        {
          "line": 48,
          "content": "        \"\"\"记录API调用指标\"\"\""
        },
        {
          "line": 72,
          "content": "    def record_error(self, platform: str, error_type: str, error_message: str = \"\"):"
        },
        {
          "line": 73,
          "content": "        \"\"\"记录错误指标\"\"\""
        },
        {
          "line": 85,
          "content": "        \"\"\"记录安全事件\"\"\""
        },
        {
          "line": 99,
          "content": "    def increment_counter(self, name: str, amount: int = 1):"
        },
        {
          "line": 100,
          "content": "        \"\"\"增加计数器\"\"\""
        },
        {
          "line": 105,
          "content": "        \"\"\"设置仪表盘值\"\"\""
        },
        {
          "line": 109,
          "content": "    def get_api_call_stats(self, platform: str = None, hours: int = 1) -> Dict[str, Any]:"
        },
        {
          "line": 110,
          "content": "        \"\"\"获取API调用统计信息\"\"\""
        },
        {
          "line": 153,
          "content": "        \"\"\"获取错误统计信息\"\"\""
        },
        {
          "line": 157,
          "content": "            errors = [e for e in self.metrics[MetricType.ERROR_RATE.value]"
        },
        {
          "line": 158,
          "content": "                     if e['timestamp'] >= cutoff_time and"
        },
        {
          "line": 161,
          "content": "            if not errors:"
        },
        {
          "line": 162,
          "content": "                return {'total_errors': 0, 'error_types': {}}"
        },
        {
          "line": 165,
          "content": "            for error in errors:"
        },
        {
          "line": 168,
          "content": "            return {"
        },
        {
          "line": 170,
          "content": "                'error_rate': len(errors) / self.get_total_api_calls(platform, hours) if self.get_total_api_calls(platform, hours) > 0 else 0,"
        },
        {
          "line": 175,
          "content": "    def get_total_api_calls(self, platform: str = None, hours: int = 1) -> int:"
        },
        {
          "line": 176,
          "content": "        \"\"\"获取指定时间内API调用总数\"\"\""
        },
        {
          "line": 186,
          "content": "        \"\"\"获取安全事件\"\"\""
        },
        {
          "line": 190,
          "content": "            events = [e for e in self.metrics[MetricType.SECURITY_EVENT.value]"
        },
        {
          "line": 191,
          "content": "                     if e['timestamp'] >= cutoff_time]"
        },
        {
          "line": 192,
          "content": "            return events"
        },
        {
          "line": 194,
          "content": "    def get_counters(self) -> Dict[str, int]:"
        },
        {
          "line": 195,
          "content": "        \"\"\"获取所有计数器\"\"\""
        },
        {
          "line": 200,
          "content": "        \"\"\"获取所有仪表盘值\"\"\""
        },
        {
          "line": 202,
          "content": "            return dict(self.gauges)"
        },
        {
          "line": 204,
          "content": "    def cleanup_old_metrics(self):"
        },
        {
          "line": 205,
          "content": "        \"\"\"清理旧的指标数据\"\"\""
        },
        {
          "line": 221,
          "content": "    \"\"\"获取指标收集器实例\"\"\""
        },
        {
          "line": 223,
          "content": "    if _metrics_collector is None:"
        },
        {
          "line": 225,
          "content": "    return _metrics_collector"
        },
        {
          "line": 228,
          "content": "def record_api_call(platform: str, endpoint: str, status_code: int, response_time: float, **kwargs):"
        },
        {
          "line": 229,
          "content": "    \"\"\"便捷函数：记录API调用\"\"\""
        },
        {
          "line": 235,
          "content": "    \"\"\"便捷函数：记录错误\"\"\""
        },
        {
          "line": 240,
          "content": "def record_security_event(event_type: str, severity: str, details: Dict[str, Any]):"
        },
        {
          "line": 241,
          "content": "    \"\"\"便捷函数：记录安全事件\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/monitoring/monitoring_config.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "    \"\"\""
        },
        {
          "line": 13,
          "content": "    \"\"\""
        },
        {
          "line": 122,
          "content": "    \"\"\""
        },
        {
          "line": 124,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/monitoring/state_consistency_monitor.py",
      "lines": [
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "    from state_consistency_monitor import StateConsistencyMonitor"
        },
        {
          "line": 18,
          "content": "\"\"\""
        },
        {
          "line": 42,
          "content": "    \"\"\"一致性级别\"\"\""
        },
        {
          "line": 50,
          "content": "class ConsistencyCheckResult:"
        },
        {
          "line": 51,
          "content": "    \"\"\"一致性检查结果\"\"\""
        },
        {
          "line": 65,
          "content": "    \"\"\"状态一致性监控器\"\"\""
        },
        {
          "line": 67,
          "content": "    def __init__(self, auto_fix: bool = True):"
        },
        {
          "line": 68,
          "content": "        \"\"\""
        },
        {
          "line": 73,
          "content": "        \"\"\""
        },
        {
          "line": 86,
          "content": "    def check_and_log(self, task_data: Dict[str, Any]) -> ConsistencyCheckResult:"
        },
        {
          "line": 87,
          "content": "        \"\"\""
        },
        {
          "line": 95,
          "content": "        \"\"\""
        },
        {
          "line": 106,
          "content": "            if result.level != ConsistencyLevel.CONSISTENT:"
        },
        {
          "line": 111,
          "content": "                if len(self.recent_issues) > 100:"
        },
        {
          "line": 114,
          "content": "            if result.level == ConsistencyLevel.CRITICAL:"
        },
        {
          "line": 121,
          "content": "        if self.auto_fix and result.auto_fixed:"
        },
        {
          "line": 124,
          "content": "        return result"
        },
        {
          "line": 126,
          "content": "    def _check_consistency(self, task_data: Dict[str, Any]) -> ConsistencyCheckResult:"
        },
        {
          "line": 127,
          "content": "        \"\"\""
        },
        {
          "line": 135,
          "content": "        \"\"\""
        },
        {
          "line": 147,
          "content": "        if status == 'completed' and stage != 'completed':"
        },
        {
          "line": 152,
          "content": "            if self.auto_fix:"
        },
        {
          "line": 157,
          "content": "        if status == 'failed' and stage != 'failed':"
        },
        {
          "line": 162,
          "content": "            if self.auto_fix:"
        },
        {
          "line": 167,
          "content": "        if is_completed:"
        },
        {
          "line": 168,
          "content": "            if status == 'completed' and progress != 100:"
        },
        {
          "line": 172,
          "content": "            if status == 'failed' and progress != 0:"
        },
        {
          "line": 186,
          "content": "        if (status, stage) not in valid_combinations:"
        },
        {
          "line": 187,
          "content": "            if not issues:  # 避免重复报告"
        },
        {
          "line": 192,
          "content": "        if len(issues) >= 3:"
        },
        {
          "line": 194,
          "content": "        elif len(issues) >= 2:"
        },
        {
          "line": 196,
          "content": "        elif len(issues) >= 1:"
        },
        {
          "line": 199,
          "content": "        return ConsistencyCheckResult("
        },
        {
          "line": 212,
          "content": "    def _log_result(self, result: ConsistencyCheckResult):"
        },
        {
          "line": 213,
          "content": "        \"\"\"记录检查结果\"\"\""
        },
        {
          "line": 227,
          "content": "        \"\"\"获取统计信息\"\"\""
        },
        {
          "line": 229,
          "content": "            return {"
        },
        {
          "line": 235,
          "content": "                    if self.check_count > 0 else 100"
        },
        {
          "line": 241,
          "content": "    def get_recent_issues(self, limit: int = 10) -> List[Dict]:"
        },
        {
          "line": 242,
          "content": "        \"\"\"获取最近的问题\"\"\""
        },
        {
          "line": 248,
          "content": "        \"\"\"生成监控报告\"\"\""
        },
        {
          "line": 264,
          "content": "        for level, count in stats['by_level'].items():"
        },
        {
          "line": 268,
          "content": "        if stats['recent_issues_count'] > 0:"
        },
        {
          "line": 270,
          "content": "            for issue in self.get_recent_issues(10):"
        },
        {
          "line": 278,
          "content": "        return \"\\n\".join(report"
        },
        {
          "line": 282,
          "content": "def monitor_state_consistency(monitor: StateConsistencyMonitor):"
        },
        {
          "line": 283,
          "content": "    \"\"\""
        },
        {
          "line": 292,
          "content": "    \"\"\""
        },
        {
          "line": 293,
          "content": "    def decorator(func):"
        },
        {
          "line": 294,
          "content": "        def wrapper(*args, **kwargs):"
        },
        {
          "line": 298,
          "content": "            if isinstance(result, dict):"
        },
        {
          "line": 300,
          "content": "            elif isinstance(result, tuple) and len(result) > 0:"
        },
        {
          "line": 303,
          "content": "                if isinstance(data, dict):"
        },
        {
          "line": 306,
          "content": "            return result"
        },
        {
          "line": 307,
          "content": "        return wrapper"
        },
        {
          "line": 308,
          "content": "    return decorator"
        },
        {
          "line": 315,
          "content": "def get_monitor() -> StateConsistencyMonitor:"
        },
        {
          "line": 316,
          "content": "    \"\"\"获取全局监控实例\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/monitoring/monitoring_decorator.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 28,
          "content": "    \"\"\""
        },
        {
          "line": 35,
          "content": "    \"\"\""
        },
        {
          "line": 145,
          "content": "    \"\"\""
        },
        {
          "line": 147,
          "content": "    \"\"\""
        },
        {
          "line": 167,
          "content": "    \"\"\""
        },
        {
          "line": 169,
          "content": "    \"\"\""
        },
        {
          "line": 236,
          "content": "    \"\"\"便捷函数：记录API调用指标\"\"\""
        },
        {
          "line": 240,
          "content": "def log_error_metric(platform: str, error_type: str, error_message: str = \"\"):"
        },
        {
          "line": 241,
          "content": "    \"\"\"便捷函数：记录错误指标\"\"\""
        },
        {
          "line": 246,
          "content": "    \"\"\"启动监控系统\"\"\""
        },
        {
          "line": 247,
          "content": "    from .monitoring.alert_system import start_alert_monitoring"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/performance/async_execution_engine.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "    from wechat_backend.performance.async_execution_engine import execute_async"
        },
        {
          "line": 14,
          "content": "    result = await execute_async("
        },
        {
          "line": 20,
          "content": "\"\"\""
        },
        {
          "line": 29,
          "content": "    \"\"\"异步执行引擎\"\"\""
        },
        {
          "line": 31,
          "content": "    def __init__(self, max_concurrent: int = 3):"
        },
        {
          "line": 32,
          "content": "        \"\"\""
        },
        {
          "line": 37,
          "content": "        \"\"\""
        },
        {
          "line": 45,
          "content": "    def set_progress_callback(self, callback: Callable):"
        },
        {
          "line": 46,
          "content": "        \"\"\"设置进度回调函数\"\"\""
        },
        {
          "line": 57,
          "content": "        \"\"\""
        },
        {
          "line": 69,
          "content": "        \"\"\""
        },
        {
          "line": 123,
          "content": "        \"\"\""
        },
        {
          "line": 133,
          "content": "        \"\"\""
        },
        {
          "line": 177,
          "content": "    \"\"\""
        },
        {
          "line": 192,
          "content": "        results = await execute_async("
        },
        {
          "line": 198,
          "content": "    \"\"\""
        },
        {
          "line": 230,
          "content": "    \"\"\""
        },
        {
          "line": 240,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views/audit_views.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "# Global store for execution progress (in production, use Redis or database)"
        },
        {
          "line": 20,
          "content": "    \"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views/report_views.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 69,
          "content": "# Global store for execution progress (in production, use Redis or database)"
        },
        {
          "line": 76,
          "content": "    \"\"\"获取PDF格式的报告\"\"\""
        },
        {
          "line": 85,
          "content": "        if not brand_name:"
        },
        {
          "line": 86,
          "content": "            return jsonify({'error': 'brand_name is required'}), 400"
        },
        {
          "line": 88,
          "content": "        if days <= 0 or days > 365:"
        },
        {
          "line": 89,
          "content": "            return jsonify({'error': 'days must be between 1 and 365'}), 400"
        },
        {
          "line": 92,
          "content": "        if not sql_protector.validate_input(brand_name):"
        },
        {
          "line": 93,
          "content": "            return jsonify({'error': 'Invalid brand_name'}), 400"
        },
        {
          "line": 97,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 104,
          "content": "        from flask import Response"
        },
        {
          "line": 105,
          "content": "        return Response("
        },
        {
          "line": 113,
          "content": "        return jsonify({'error': 'Failed to generate PDF report', 'details': str(e)}), 500"
        },
        {
          "line": 117,
          "content": "from wechat_backend.ai_adapters.workflow_manager import WorkflowManager"
        },
        {
          "line": 127,
          "content": "def get_executive_report():"
        },
        {
          "line": 128,
          "content": "    \"\"\"获取高管视角报告\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views/user_views.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 65,
          "content": "# Global store for execution progress (in production, use Redis or database)"
        },
        {
          "line": 73,
          "content": "    \"\"\"Handle WeChat server verification\"\"\""
        },
        {
          "line": 75,
          "content": "    from wechat_backend.logging_config import api_logger"
        },
        {
          "line": 78,
          "content": "    if request.method == 'GET':"
        },
        {
          "line": 89,
          "content": "        if verify_wechat_signature(token, signature, timestamp, nonce):"
        },
        {
          "line": 91,
          "content": "            return echostr"
        },
        {
          "line": 93,
          "content": "            api_logger.error(f\"Signature verification failed. Expected signature for token={token}, timestamp={timestamp}, nonce={nonce}\")"
        },
        {
          "line": 100,
          "content": "            return 'Verification failed', 403"
        },
        {
          "line": 101,
          "content": "    elif request.method == 'POST':"
        },
        {
          "line": 103,
          "content": "        return 'success'"
        },
        {
          "line": 110,
          "content": "def wechat_login():"
        },
        {
          "line": 111,
          "content": "    \"\"\"Handle login with WeChat Mini Program code\"\"\""
        },
        {
          "line": 170,
          "content": "    \"\"\"Send verification code to user\"\"\""
        },
        {
          "line": 174,
          "content": "    if not data:"
        },
        {
          "line": 175,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 178,
          "content": "    if not phone:"
        },
        {
          "line": 179,
          "content": "        return jsonify({'error': 'Phone number is required'}), 400"
        },
        {
          "line": 182,
          "content": "    import re"
        },
        {
          "line": 184,
          "content": "    if not re.match(phone_pattern, phone):"
        },
        {
          "line": 185,
          "content": "        return jsonify({'error': 'Invalid phone number format'}), 400"
        },
        {
          "line": 188,
          "content": "    import random"
        },
        {
          "line": 192,
          "content": "    from wechat_backend.database import save_verification_code"
        },
        {
          "line": 196,
          "content": "    # For development, log the code for testing"
        },
        {
          "line": 199,
          "content": "    # For testing purposes, return the code in the response (remove in production!)"
        },
        {
          "line": 200,
          "content": "    return jsonify({"
        },
        {
          "line": 204,
          "content": "        # REMOVE THIS IN PRODUCTION - for testing only!"
        },
        {
          "line": 213,
          "content": "def register_user():"
        },
        {
          "line": 214,
          "content": "    \"\"\"Register new user with phone and password\"\"\""
        },
        {
          "line": 243,
          "content": "    # Check if phone already registered"
        },
        {
          "line": 285,
          "content": "    \"\"\"Login with phone and password\"\"\""
        },
        {
          "line": 289,
          "content": "    if not data:"
        },
        {
          "line": 290,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 295,
          "content": "    if not phone or not password:"
        },
        {
          "line": 296,
          "content": "        return jsonify({'error': 'Phone and password are required'}), 400"
        },
        {
          "line": 299,
          "content": "    from wechat_backend.database import get_user_by_phone"
        },
        {
          "line": 302,
          "content": "    if not user:"
        },
        {
          "line": 303,
          "content": "        api_logger.warning(f\"Login failed: user not found for {phone}\")"
        },
        {
          "line": 304,
          "content": "        return jsonify({'error': 'Invalid phone or password'}), 401"
        },
        {
          "line": 307,
          "content": "    import bcrypt"
        },
        {
          "line": 309,
          "content": "        if not bcrypt.checkpw(password.encode('utf-8'), user['password_hash'].encode('utf-8')):"
        },
        {
          "line": 310,
          "content": "            api_logger.warning(f\"Login failed: incorrect password for {phone}\")"
        },
        {
          "line": 311,
          "content": "            return jsonify({'error': 'Invalid phone or password'}), 401"
        },
        {
          "line": 314,
          "content": "        return jsonify({'error': 'Login failed'}), 500"
        },
        {
          "line": 317,
          "content": "    from wechat_backend.security.auth import jwt_manager"
        },
        {
          "line": 322,
          "content": "    from wechat_backend.database import save_refresh_token"
        },
        {
          "line": 327,
          "content": "    return jsonify({"
        },
        {
          "line": 347,
          "content": "def validate_token():"
        },
        {
          "line": 348,
          "content": "    \"\"\"Validate access token\"\"\""
        },
        {
          "line": 357,
          "content": "        # Try to get token from Authorization header"
        },
        {
          "line": 389,
          "content": "    \"\"\"Refresh access token using refresh token\"\"\""
        },
        {
          "line": 393,
          "content": "    if not data:"
        },
        {
          "line": 394,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 398,
          "content": "    if not refresh_token_str:"
        },
        {
          "line": 399,
          "content": "        # Try to get refresh token from cookie or header"
        },
        {
          "line": 402,
          "content": "    if not refresh_token_str:"
        },
        {
          "line": 403,
          "content": "        return jsonify({'error': 'Refresh token is required'}), 400"
        },
        {
          "line": 406,
          "content": "    from wechat_backend.database import verify_refresh_token"
        },
        {
          "line": 409,
          "content": "    if not user_id:"
        },
        {
          "line": 410,
          "content": "        return jsonify({'error': 'Invalid or expired refresh token'}), 401"
        },
        {
          "line": 413,
          "content": "        from wechat_backend.security.auth import jwt_manager"
        },
        {
          "line": 414,
          "content": "        if not jwt_manager:"
        },
        {
          "line": 415,
          "content": "            return jsonify({'error': 'JWT service unavailable'}), 500"
        },
        {
          "line": 424,
          "content": "        # Generate new refresh token (rotate refresh tokens for security)"
        },
        {
          "line": 432,
          "content": "        from wechat_backend.database import save_refresh_token"
        },
        {
          "line": 436,
          "content": "        from wechat_backend.database import revoke_refresh_token"
        },
        {
          "line": 439,
          "content": "        api_logger.info(f\"Token refreshed for user {user_id}\")"
        },
        {
          "line": 441,
          "content": "        return jsonify({"
        },
        {
          "line": 451,
          "content": "        return jsonify({'error': 'Token refresh failed'}), 500"
        },
        {
          "line": 459,
          "content": "def logout():"
        },
        {
          "line": 460,
          "content": "    \"\"\"Logout user (revoke refresh tokens)\"\"\""
        },
        {
          "line": 466,
          "content": "    # Option 1: Logout from current device only"
        },
        {
          "line": 472,
          "content": "    # Option 2: Logout from all devices (if requested)"
        },
        {
          "line": 492,
          "content": "    \"\"\"Get user profile information\"\"\""
        },
        {
          "line": 496,
          "content": "    # Convert user_id to int if it's a string"
        },
        {
          "line": 501,
          "content": "        return jsonify({'error': 'Invalid user ID'}), 400"
        },
        {
          "line": 503,
          "content": "    # Fetch user profile from database"
        },
        {
          "line": 504,
          "content": "    from wechat_backend.database import get_user_by_id"
        },
        {
          "line": 507,
          "content": "    if not user:"
        },
        {
          "line": 509,
          "content": "        return jsonify({'error': 'User not found'}), 404"
        },
        {
          "line": 511,
          "content": "    # Mask phone number for privacy"
        },
        {
          "line": 513,
          "content": "    if user.get('phone'):"
        },
        {
          "line": 515,
          "content": "        if len(phone) >= 7:"
        },
        {
          "line": 520,
          "content": "    return jsonify({"
        },
        {
          "line": 538,
          "content": "def put_user_profile():"
        },
        {
          "line": 539,
          "content": "    \"\"\"Update user profile information (PUT method)\"\"\""
        },
        {
          "line": 549,
          "content": "    \"\"\"Update user profile information\"\"\""
        },
        {
          "line": 550,
          "content": "    return update_user_profile_data()"
        },
        {
          "line": 555,
          "content": "def update_user_profile_data():"
        },
        {
          "line": 556,
          "content": "    \"\"\"Helper function to update user profile\"\"\""
        },
        {
          "line": 560,
          "content": "    # Convert user_id to int if it's a string"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views/analytics_views.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 69,
          "content": "# Global store for execution progress (in production, use Redis or database)"
        },
        {
          "line": 119,
          "content": "    \"\"\"获取干预行动建议\"\"\""
        },
        {
          "line": 124,
          "content": "    if not data:"
        },
        {
          "line": 125,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 133,
          "content": "        if not isinstance(source_intelligence, dict):"
        },
        {
          "line": 134,
          "content": "            return jsonify({'error': 'source_intelligence must be a dictionary'}), 400"
        },
        {
          "line": 136,
          "content": "        if not isinstance(evidence_chain, list):"
        },
        {
          "line": 137,
          "content": "            return jsonify({'error': 'evidence_chain must be a list'}), 400"
        },
        {
          "line": 141,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 156,
          "content": "        for rec in recommendations:"
        },
        {
          "line": 168,
          "content": "        return jsonify({"
        },
        {
          "line": 176,
          "content": "        return jsonify({'error': 'Failed to generate recommendations', 'details': str(e)}), 500"
        },
        {
          "line": 189,
          "content": "def configure_cruise_task():"
        },
        {
          "line": 190,
          "content": "    \"\"\"配置定时诊断任务\"\"\""
        },
        {
          "line": 251,
          "content": "    \"\"\"取消定时诊断任务\"\"\""
        },
        {
          "line": 256,
          "content": "    if not data:"
        },
        {
          "line": 257,
          "content": "        return jsonify({'error': 'No JSON data provided'}), 400"
        },
        {
          "line": 261,
          "content": "        if not job_id:"
        },
        {
          "line": 262,
          "content": "            return jsonify({'error': 'job_id is required'}), 400"
        },
        {
          "line": 266,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 272,
          "content": "        return jsonify({"
        },
        {
          "line": 280,
          "content": "        return jsonify({'error': 'Failed to cancel cruise task', 'details': str(e)}), 500"
        },
        {
          "line": 289,
          "content": "def get_cruise_tasks():"
        },
        {
          "line": 290,
          "content": "    \"\"\"获取所有已调度的巡航任务\"\"\""
        },
        {
          "line": 316,
          "content": "    \"\"\"获取趋势数据\"\"\""
        },
        {
          "line": 325,
          "content": "        if not brand_name:"
        },
        {
          "line": 326,
          "content": "            return jsonify({'error': 'brand_name is required'}), 400"
        },
        {
          "line": 328,
          "content": "        if days <= 0 or days > 365:"
        },
        {
          "line": 329,
          "content": "            return jsonify({'error': 'days must be between 1 and 365'}), 400"
        },
        {
          "line": 333,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 339,
          "content": "        return jsonify({"
        },
        {
          "line": 349,
          "content": "        return jsonify({'error': 'Failed to retrieve trend data', 'details': str(e)}), 500"
        },
        {
          "line": 362,
          "content": "def get_market_benchmark():"
        },
        {
          "line": 363,
          "content": "    \"\"\"获取市场基准对比数据\"\"\""
        },
        {
          "line": 417,
          "content": "    \"\"\"获取品牌认知趋势预测和风险因素\"\"\""
        },
        {
          "line": 427,
          "content": "        if not brand_name:"
        },
        {
          "line": 428,
          "content": "            return jsonify({'error': 'brand_name is required'}), 400"
        },
        {
          "line": 430,
          "content": "        if days <= 0 or days > 30:"
        },
        {
          "line": 431,
          "content": "            return jsonify({'error': 'days must be between 1 and 30'}), 400"
        },
        {
          "line": 433,
          "content": "        if history_days <= 0 or history_days > 365:"
        },
        {
          "line": 434,
          "content": "            return jsonify({'error': 'history_days must be between 1 and 365'}), 400"
        },
        {
          "line": 437,
          "content": "        if not sql_protector.validate_input(brand_name):"
        },
        {
          "line": 438,
          "content": "            return jsonify({'error': 'Invalid brand_name'}), 400"
        },
        {
          "line": 442,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 448,
          "content": "        if not trend_data:"
        },
        {
          "line": 449,
          "content": "            return jsonify({"
        },
        {
          "line": 451,
          "content": "                'message': 'No historical data available for prediction',"
        },
        {
          "line": 457,
          "content": "        from wechat_backend.analytics.prediction_engine import PredictionEngine"
        },
        {
          "line": 462,
          "content": "        for data_point in trend_data:"
        },
        {
          "line": 475,
          "content": "        for data_point in trend_data[-7:]:  # 使用最近7天的数据"
        },
        {
          "line": 476,
          "content": "            if data_point.get('overall_score', 100) < 60:  # 假设分数低于60表示有问题"
        },
        {
          "line": 485,
          "content": "        for entry in historical_data:"
        },
        {
          "line": 486,
          "content": "            entry['evidence_chain'] = evidence_chain if entry['overall_score'] and entry['overall_score'] < 60 else []"
        },
        {
          "line": 491,
          "content": "        return jsonify({"
        },
        {
          "line": 500,
          "content": "        return jsonify({'error': 'Failed to generate prediction forecast', 'details': str(e)}), 500"
        },
        {
          "line": 504,
          "content": "from wechat_backend.analytics.workflow_manager import WorkflowManager"
        },
        {
          "line": 508,
          "content": "from wechat_backend.analytics.asset_intelligence_engine import AssetIntelligenceEngine"
        },
        {
          "line": 518,
          "content": "def optimize_assets():"
        },
        {
          "line": 519,
          "content": "    \"\"\"资产优化接口 - 分析官方资产与AI偏好的匹配度并提供优化建议\"\"\""
        },
        {
          "line": 601,
          "content": "    \"\"\"获取枢纽摘要数据 - 品牌GEO运营分析汇总\"\"\""
        },
        {
          "line": 610,
          "content": "        if not brand_name:"
        },
        {
          "line": 611,
          "content": "            return jsonify({'error': 'brand_name is required'}), 400"
        },
        {
          "line": 613,
          "content": "        if days <= 0 or days > 365:"
        },
        {
          "line": 614,
          "content": "            return jsonify({'error': 'days must be between 1 and 365'}), 400"
        },
        {
          "line": 617,
          "content": "        if not sql_protector.validate_input(brand_name):"
        },
        {
          "line": 618,
          "content": "            return jsonify({'error': 'Invalid brand_name'}), 400"
        },
        {
          "line": 622,
          "content": "        return jsonify({'error': 'Invalid input data'}), 400"
        },
        {
          "line": 628,
          "content": "        return jsonify({"
        },
        {
          "line": 635,
          "content": "        return jsonify({'error': 'Failed to generate hub summary', 'details': str(e)}), 500"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views/diagnosis_views.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 6,
          "content": "\"\"\""
        },
        {
          "line": 85,
          "content": "# Global store for execution progress (in production, use Redis or database)"
        },
        {
          "line": 95,
          "content": "    \"\"\"Perform brand cognition test across multiple AI platforms (Async) with Multi-Brand Support\"\"\""
        },
        {
          "line": 102,
          "content": "    if request.method == 'OPTIONS':"
        },
        {
          "line": 108,
          "content": "        return response, 200"
        },
        {
          "line": 120,
          "content": "    if data is None:"
        },
        {
          "line": 121,
          "content": "        return jsonify({\"status\": \"error\", \"error\": \"Empty or invalid JSON\", \"code\": 400}), 400"
        },
        {
          "line": 127,
          "content": "        if 'brand_list' not in data:"
        },
        {
          "line": 128,
          "content": "            return jsonify({\"status\": \"error\", \"error\": 'Missing brand_list in request data', \"code\": 400, 'received_fields': list(data.keys())}), 400"
        },
        {
          "line": 129,
          "content": "        if not isinstance(data['brand_list'], list):"
        },
        {
          "line": 130,
          "content": "            return jsonify({\"status\": \"error\", \"error\": 'brand_list must be a list', \"code\": 400, 'received': type(data['brand_list']).__name__, 'received_value': data['brand_list']}), 400"
        },
        {
          "line": 132,
          "content": "        if not brand_list:"
        },
        {
          "line": 133,
          "content": "            return jsonify({\"status\": \"error\", \"error\": 'brand_list cannot be empty', \"code\": 400, 'received': brand_list}), 400"
        },
        {
          "line": 136,
          "content": "        for brand in brand_list:"
        },
        {
          "line": 137,
          "content": "            if not isinstance(brand, str):"
        },
        {
          "line": 138,
          "content": "                return jsonify({\"status\": \"error\", \"error\": f'Each brand in brand_list must be a string, got {type(brand)}', \"code\": 400, 'problematic_value': brand}), 400"
        },
        {
          "line": 139,
          "content": "            if not validate_safe_text(brand, max_length=100):"
        },
        {
          "line": 140,
          "content": "                return jsonify({\"status\": \"error\", \"error\": f'Invalid brand name: {brand}', \"code\": 400}), 400"
        },
        {
          "line": 148,
          "content": "        if 'selectedModels' not in data:"
        },
        {
          "line": 149,
          "content": "            return jsonify({\"status\": \"error\", \"error\": 'Missing selectedModels in request data', \"code\": 400, 'received_fields': list(data.keys())}), 400"
        },
        {
          "line": 150,
          "content": "        if not isinstance(data['selectedModels'], list):"
        },
        {
          "line": 151,
          "content": "            return jsonify({\"status\": \"error\", \"error\": 'selectedModels must be a list', \"code\": 400, 'received': type(data['selectedModels']).__name__, 'received_value': data['selectedModels']}), 400"
        },
        {
          "line": 153,
          "content": "        if not selected_models:"
        },
        {
          "line": 154,
          "content": "            return jsonify({\"status\": \"error\", \"error\": 'At least one AI model must be selected', \"code\": 400, 'received': selected_models}), 400"
        },
        {
          "line": 159,
          "content": "        for model in selected_models:"
        },
        {
          "line": 160,
          "content": "            if isinstance(model, dict):"
        },
        {
          "line": 163,
          "content": "                if model_name:"
        },
        {
          "line": 167,
          "content": "                    for key, value in model.items():"
        },
        {
          "line": 168,
          "content": "                        if key in ['name', 'id', 'value', 'label'] and isinstance(value, str):"
        },
        {
          "line": 171,
          "content": "            elif isinstance(model, str):"
        },
        {
          "line": 182,
          "content": "        original_model_names = [model.get('name', model) if isinstance(model, dict) else model for model in data['selectedModels']]"
        },
        {
          "line": 183,
          "content": "        converted_model_names = [model['name'] for model in selected_models]"
        },
        {
          "line": 186,
          "content": "        if not selected_models:"
        },
        {
          "line": 187,
          "content": "            return jsonify({\"status\": \"error\", \"error\": 'No valid AI models found after parsing', \"code\": 400}), 400"
        },
        {
          "line": 191,
          "content": "        if 'custom_question' in data:"
        },
        {
          "line": 193,
          "content": "            if not isinstance(data['custom_question'], str):"
        },
        {
          "line": 194,
          "content": "                return jsonify({\"status\": \"error\", \"error\": 'custom_question must be a string', \"code\": 400, 'received': type(data['custom_question']).__name__, 'received_value': data['custom_question']}), 400"
        },
        {
          "line": 198,
          "content": "            if question_text:"
        },
        {
          "line": 200,
          "content": "                import re"
        },
        {
          "line": 204,
          "content": "                custom_questions = [q.strip() + ('?' if not q.strip().endswith('?') else '') for q in raw_questions if q.strip()]"
        },
        {
          "line": 209,
          "content": "                for i, q in enumerate(custom_questions):"
        },
        {
          "line": 213,
          "content": "        elif 'customQuestions' in data:"
        },
        {
          "line": 215,
          "content": "            if not isinstance(data['customQuestions'], list):"
        },
        {
          "line": 216,
          "content": "                return jsonify({\"status\": \"error\", \"error\": 'customQuestions must be a list', \"code\": 400, 'received': type(data['customQuestions']).__name__, 'received_value': data['customQuestions']}), 400"
        },
        {
          "line": 223,
          "content": "        user_openid = data.get('userOpenid') or (user_id if user_id != 'anonymous' else 'anonymous')"
        },
        {
          "line": 234,
          "content": "        from wechat_backend.ai_adapters.factory import AIAdapterFactory"
        },
        {
          "line": 235,
          "content": "        from wechat_backend.ai_adapters.base_adapter import AIPlatformType"
        },
        {
          "line": 240,
          "content": "        api_logger.info(f\"All registered adapters: {[pt.value for pt in AIAdapterFactory._adapters.keys()]}\")"
        },
        {
          "line": 244,
          "content": "        for model in selected_models:"
        },
        {
          "line": 245,
          "content": "            model_name = model['name'] if isinstance(model, dict) else model"
        },
        {
          "line": 250,
          "content": "            if not AIAdapterFactory.is_platform_available(normalized_model_name):"
        },
        {
          "line": 252,
          "content": "                registered_keys = [pt.value for pt in AIAdapterFactory._adapters.keys()]"
        },
        {
          "line": 254,
          "content": "                return jsonify({"
        },
        {
          "line": 264,
          "content": "            from wechat_backend.config_manager import config_manager"
        },
        {
          "line": 266,
          "content": "            if not api_key:"
        },
        {
          "line": 267,
          "content": "                return jsonify({\"status\": \"error\", \"error\": f'Model {model_name} not configured - missing API key', \"code\": 400, 'message': 'API Key 缺失'}), 400"
        },
        {
          "line": 270,
          "content": "        for question in custom_questions:"
        },
        {
          "line": 271,
          "content": "            if not isinstance(question, str):"
        },
        {
          "line": 272,
          "content": "                return jsonify({'error': f'Each question in customQuestions must be a string, got {type(question)}'}), 400"
        },
        {
          "line": 273,
          "content": "            if not validate_safe_text(question, max_length=500):"
        },
        {
          "line": 274,
          "content": "                return jsonify({'error': f'Unsafe question content: {question}'}), 400"
        },
        {
          "line": 278,
          "content": "        return jsonify({'error': f'Invalid input data: {str(e)}'}), 400"
        },
        {
          "line": 286,
          "content": "    def on_timeout(eid: str):"
        },
        {
          "line": 287,
          "content": "        \"\"\"超时回调：记录日志并标记任务超时\"\"\""
        },
        {
          "line": 375,
          "content": "        \"\"\""
        },
        {
          "line": 381,
          "content": "        \"\"\""
        },
        {
          "line": 716,
          "content": "    \"\"\""
        },
        {
          "line": 719,
          "content": "    \"\"\""
        },
        {
          "line": 913,
          "content": "    \"\"\""
        },
        {
          "line": 916,
          "content": "    \"\"\""
        },
        {
          "line": 1110,
          "content": "    \"\"\""
        },
        {
          "line": 1113,
          "content": "    \"\"\""
        },
        {
          "line": 1307,
          "content": "    \"\"\""
        },
        {
          "line": 1310,
          "content": "    \"\"\""
        },
        {
          "line": 1521,
          "content": "    \"\"\""
        },
        {
          "line": 1523,
          "content": "    \"\"\""
        },
        {
          "line": 1530,
          "content": "        # Only create AIJudgeClient if judge parameters are provided"
        },
        {
          "line": 1535,
          "content": "            # Check if any judge parameters are provided (even partially)"
        },
        {
          "line": 1599,
          "content": "                        # Only evaluate with AI judge if it's available"
        },
        {
          "line": 1601,
          "content": "                            # Add timeout protection for individual AI judge calls"
        },
        {
          "line": 1603,
          "content": "                                # Temporarily disable the global alarm for this call"
        },
        {
          "line": 1606,
          "content": "                                # Set a shorter timeout for individual evaluations"
        },
        {
          "line": 1800,
          "content": "                            # Add a basic judge result with scores from evaluator for scoring calculations"
        },
        {
          "line": 2058,
          "content": "        # Print JSON sample for verification"
        },
        {
          "line": 2148,
          "content": "        # Print JSON sample for verification"
        },
        {
          "line": 2160,
          "content": "    \"\"\""
        },
        {
          "line": 2170,
          "content": "    \"\"\""
        },
        {
          "line": 2375,
          "content": "    # This function is now replaced by the real processor, but we keep it for other potential uses"
        },
        {
          "line": 2394,
          "content": "    # ... (This function remains the same)"
        },
        {
          "line": 2415,
          "content": "    \"\"\"获取所有AI平台的状态信息\"\"\""
        },
        {
          "line": 2418,
          "content": "        from wechat_backend.config_manager import ConfigurationManager as PlatformConfigManager"
        },
        {
          "line": 2429,
          "content": "        for platform in supported_platforms:"
        },
        {
          "line": 2431,
          "content": "            if config and config.api_key:"
        },
        {
          "line": 2437,
          "content": "                    'status': status.value if status else 'active',"
        },
        {
          "line": 2440,
          "content": "                        'daily_limit': quota_info.daily_limit if quota_info else None,"
        },
        {
          "line": 2441,
          "content": "                        'used_today': quota_info.used_today if quota_info else 0,"
        },
        {
          "line": 2442,
          "content": "                        'remaining': quota_info.remaining if quota_info else None"
        },
        {
          "line": 2443,
          "content": "                    } if quota_info else None,"
        },
        {
          "line": 2456,
          "content": "        return jsonify({'status': 'success', 'platforms': status_info})"
        },
        {
          "line": 2460,
          "content": "        return jsonify({'status': 'error', 'message': str(e)}), 500"
        },
        {
          "line": 2467,
          "content": "def get_test_progress():"
        },
        {
          "line": 2468,
          "content": "    \"\"\""
        },
        {
          "line": 2479,
          "content": "    \"\"\""
        },
        {
          "line": 2482,
          "content": "    if not execution_id:"
        },
        {
          "line": 2483,
          "content": "        return jsonify({'error': 'Missing executionId parameter'}), 400"
        },
        {
          "line": 2486,
          "content": "    if execution_id in execution_store:"
        },
        {
          "line": 2515,
          "content": "        if progress_data.get('status') in ['completed', 'failed']:"
        },
        {
          "line": 2519,
          "content": "        return jsonify(progress_data)"
        },
        {
          "line": 2525,
          "content": "        from wechat_backend.diagnosis_report_repository import DiagnosisReportRepository"
        },
        {
          "line": 2531,
          "content": "        if report:"
        },
        {
          "line": 2548,
          "content": "            if report.get('error_message'):"
        },
        {
          "line": 2552,
          "content": "            if report.get('is_completed') == 1 or report.get('status') in ['completed', 'failed']:"
        },
        {
          "line": 2557,
          "content": "            if report.get('status') == 'completed':"
        },
        {
          "line": 2559,
          "content": "                    from wechat_backend.diagnosis_report_repository import DiagnosisResultRepository"
        },
        {
          "line": 2568,
          "content": "            return jsonify(db_data)"
        },
        {
          "line": 2571,
          "content": "            return jsonify({"
        },
        {
          "line": 2579,
          "content": "        return jsonify({"
        },
        {
          "line": 2593,
          "content": "def stream_progress(execution_id):"
        },
        {
          "line": 2594,
          "content": "    \"\"\""
        },
        {
          "line": 2605,
          "content": "    \"\"\""
        },
        {
          "line": 2616,
          "content": "    return create_sse_response(client_id)"
        },
        {
          "line": 2625,
          "content": "def submit_brand_test():"
        },
        {
          "line": 2626,
          "content": "    \"\"\"提交品牌AI诊断任务\"\"\""
        },
        {
          "line": 2890,
          "content": "    \"\"\""
        },
        {
          "line": 2902,
          "content": "    \"\"\""
        },
        {
          "line": 3068,
          "content": "    \"\"\"获取诊断任务的完整情报深度结果\"\"\""
        },
        {
          "line": 3069,
          "content": "    if not task_id:"
        },
        {
          "line": 3070,
          "content": "        return jsonify({'error': 'Task ID is required'}), 400"
        },
        {
          "line": 3074,
          "content": "    if not task_status or not task_status.is_completed:"
        },
        {
          "line": 3075,
          "content": "        return jsonify({'error': 'Task not completed or not found'}), 400"
        },
        {
          "line": 3080,
          "content": "    if not deep_intelligence_result:"
        },
        {
          "line": 3081,
          "content": "        return jsonify({'error': 'Deep intelligence result not found'}), 404"
        },
        {
          "line": 3084,
          "content": "    return jsonify(deep_intelligence_result.to_dict()), 200"
        },
        {
          "line": 3088,
          "content": "from wechat_backend.diagnosis_report_service import get_report_service"
        },
        {
          "line": 3100,
          "content": "#         'competitor_brands': competitor_brands if 'competitor_brands' in locals() else [],"
        },
        {
          "line": 3102,
          "content": "#         'custom_questions': raw_questions if 'raw_questions' in locals() else []"
        },
        {
          "line": 3112,
          "content": "#     if 'competitive_analysis' in execution_store[execution_id]:"
        },
        {
          "line": 3114,
          "content": "#     if 'brand_scores' in execution_store[execution_id]:"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views/diagnosis_retry_api.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 37,
          "content": "    \"\"\""
        },
        {
          "line": 61,
          "content": "    \"\"\""
        },
        {
          "line": 227,
          "content": "    \"\"\""
        },
        {
          "line": 244,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views/admin_views.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 69,
          "content": "# Global store for execution progress (in production, use Redis or database)"
        },
        {
          "line": 89,
          "content": "    \"\"\""
        },
        {
          "line": 124,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views/sync_views.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 69,
          "content": "# Global store for execution progress (in production, use Redis or database)"
        },
        {
          "line": 75,
          "content": "    \"\"\""
        },
        {
          "line": 79,
          "content": "    - last_sync_timestamp: Last sync timestamp (optional, for incremental sync)"
        },
        {
          "line": 83,
          "content": "    - cloud_results: Results from cloud"
        },
        {
          "line": 85,
          "content": "    - last_sync_timestamp: Timestamp for next sync"
        },
        {
          "line": 86,
          "content": "    \"\"\""
        },
        {
          "line": 100,
          "content": "    # Initialize sync database if needed"
        },
        {
          "line": 117,
          "content": "    # 3. Get current timestamp for next sync"
        },
        {
          "line": 139,
          "content": "    \"\"\""
        },
        {
          "line": 140,
          "content": "    Download user data from cloud (incremental download)"
        },
        {
          "line": 143,
          "content": "    - last_sync_timestamp: Last sync timestamp (optional, for incremental sync)"
        },
        {
          "line": 146,
          "content": "    - cloud_results: Results from cloud"
        },
        {
          "line": 147,
          "content": "    - last_sync_timestamp: Timestamp for next sync"
        },
        {
          "line": 148,
          "content": "    \"\"\""
        },
        {
          "line": 161,
          "content": "    # Initialize sync database if needed"
        },
        {
          "line": 168,
          "content": "    # Get current timestamp for next sync"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/views/diagnosis_api.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "\"\"\""
        },
        {
          "line": 30,
          "content": "    \"\"\""
        },
        {
          "line": 59,
          "content": "    \"\"\""
        },
        {
          "line": 89,
          "content": "    \"\"\""
        },
        {
          "line": 130,
          "content": "    \"\"\""
        },
        {
          "line": 163,
          "content": "    \"\"\""
        },
        {
          "line": 176,
          "content": "    \"\"\""
        },
        {
          "line": 209,
          "content": "    \"\"\"注册诊断 API\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/roi_calculator.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "    \"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\""
        },
        {
          "line": 60,
          "content": "        \"\"\""
        },
        {
          "line": 68,
          "content": "        \"\"\""
        },
        {
          "line": 122,
          "content": "        \"\"\"计算曝光 ROI\"\"\""
        },
        {
          "line": 125,
          "content": "        for platform in platform_data:"
        },
        {
          "line": 136,
          "content": "        exposure_roi = round(estimated_value / investment, 2) if investment > 0 else 0"
        },
        {
          "line": 138,
          "content": "        return {"
        },
        {
          "line": 145,
          "content": "    def _calculate_sentiment_roi(self, brand_name: str,"
        },
        {
          "line": 148,
          "content": "        \"\"\"计算情感 ROI\"\"\""
        },
        {
          "line": 183,
          "content": "        \"\"\"计算排名 ROI\"\"\""
        },
        {
          "line": 184,
          "content": "        if not platform_data:"
        },
        {
          "line": 185,
          "content": "            return {"
        },
        {
          "line": 193,
          "content": "        rankings = [p.get('rank', 10) for p in platform_data]"
        },
        {
          "line": 197,
          "content": "        top_3_count = sum(1 for r in rankings if r <= 3)"
        },
        {
          "line": 198,
          "content": "        top_10_count = sum(1 for r in rankings if r <= 10)"
        },
        {
          "line": 203,
          "content": "        return {"
        },
        {
          "line": 211,
          "content": "    def _calculate_overall_roi(self, exposure: Dict[str, Any],"
        },
        {
          "line": 214,
          "content": "        \"\"\"计算综合 ROI\"\"\""
        },
        {
          "line": 239,
          "content": "        \"\"\"计算行业对比\"\"\""
        },
        {
          "line": 240,
          "content": "        return {"
        },
        {
          "line": 261,
          "content": "    def _determine_roi_grade(self, overall_roi: float) -> str:"
        },
        {
          "line": 262,
          "content": "        \"\"\"确定 ROI 等级\"\"\""
        },
        {
          "line": 280,
          "content": "    \"\"\"获取 ROI 计算器实例\"\"\""
        },
        {
          "line": 282,
          "content": "    if _roi_calculator is None:"
        },
        {
          "line": 284,
          "content": "    return _roi_calculator"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/diagnosis_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 26,
          "content": "    \"\"\""
        },
        {
          "line": 36,
          "content": "        \"\"\""
        },
        {
          "line": 50,
          "content": "        \"\"\""
        },
        {
          "line": 110,
          "content": "        \"\"\""
        },
        {
          "line": 121,
          "content": "        \"\"\""
        },
        {
          "line": 143,
          "content": "        \"\"\""
        },
        {
          "line": 152,
          "content": "        \"\"\""
        },
        {
          "line": 169,
          "content": "        \"\"\""
        },
        {
          "line": 178,
          "content": "        \"\"\""
        },
        {
          "line": 198,
          "content": "        \"\"\""
        },
        {
          "line": 207,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/quality_scorer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 6,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "    \"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\""
        },
        {
          "line": 39,
          "content": "        \"\"\""
        },
        {
          "line": 50,
          "content": "        \"\"\""
        },
        {
          "line": 94,
          "content": "        \"\"\""
        },
        {
          "line": 103,
          "content": "        \"\"\""
        },
        {
          "line": 125,
          "content": "        \"\"\""
        },
        {
          "line": 129,
          "content": "        \"\"\""
        },
        {
          "line": 144,
          "content": "        \"\"\""
        },
        {
          "line": 148,
          "content": "        \"\"\""
        },
        {
          "line": 163,
          "content": "        \"\"\""
        },
        {
          "line": 165,
          "content": "        \"\"\""
        },
        {
          "line": 176,
          "content": "        \"\"\""
        },
        {
          "line": 178,
          "content": "        \"\"\""
        },
        {
          "line": 192,
          "content": "    \"\"\""
        },
        {
          "line": 194,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/async_export_service.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 22,
          "content": "    \"\"\""
        },
        {
          "line": 25,
          "content": "    \"\"\""
        },
        {
          "line": 37,
          "content": "        \"\"\"启动工作线程\"\"\""
        },
        {
          "line": 38,
          "content": "        for i in range(self.max_workers):"
        },
        {
          "line": 43,
          "content": "    def _worker_loop(self):"
        },
        {
          "line": 44,
          "content": "        \"\"\"工作线程循环\"\"\""
        },
        {
          "line": 60,
          "content": "        \"\"\"处理单个任务\"\"\""
        },
        {
          "line": 90,
          "content": "            from wechat_backend.services.pdf_export_service import PDFExportService"
        },
        {
          "line": 127,
          "content": "    def _update_status(self, task_id: str, updates: Dict[str, Any]):"
        },
        {
          "line": 128,
          "content": "        \"\"\"更新任务状态\"\"\""
        },
        {
          "line": 135,
          "content": "        \"\"\"保存 PDF 文件\"\"\""
        },
        {
          "line": 147,
          "content": "        return file_path"
        },
        {
          "line": 149,
          "content": "    def submit_task(self, execution_id: str, level: str = 'full', sections: str = 'all') -> str:"
        },
        {
          "line": 150,
          "content": "        \"\"\""
        },
        {
          "line": 160,
          "content": "        \"\"\""
        },
        {
          "line": 161,
          "content": "        import uuid"
        },
        {
          "line": 185,
          "content": "        self.logger.info(f\"Task {task_id} submitted for execution_id={execution_id}\")"
        },
        {
          "line": 186,
          "content": "        return task_id"
        },
        {
          "line": 188,
          "content": "    def get_task_status(self, task_id: str) -> Dict[str, Any]:"
        },
        {
          "line": 189,
          "content": "        \"\"\"获取任务状态\"\"\""
        },
        {
          "line": 196,
          "content": "        \"\"\"获取队列统计信息\"\"\""
        },
        {
          "line": 197,
          "content": "        queued = sum(1 for t in self.task_status.values() if t.get('status') == 'queued')"
        },
        {
          "line": 198,
          "content": "        processing = sum(1 for t in self.task_status.values() if t.get('status') == 'processing')"
        },
        {
          "line": 199,
          "content": "        completed = sum(1 for t in self.task_status.values() if t.get('status') == 'completed')"
        },
        {
          "line": 200,
          "content": "        failed = sum(1 for t in self.task_status.values() if t.get('status') == 'failed')"
        },
        {
          "line": 202,
          "content": "        return {"
        },
        {
          "line": 204,
          "content": "            'active_workers': len([w for w in self.workers if w.is_alive()]),"
        },
        {
          "line": 212,
          "content": "    def cleanup_old_tasks(self, max_age_hours: int = 24):"
        },
        {
          "line": 213,
          "content": "        \"\"\"清理旧任务状态\"\"\""
        },
        {
          "line": 243,
          "content": "    \"\"\"获取异步导出服务实例\"\"\""
        },
        {
          "line": 245,
          "content": "    if _async_export_service is None:"
        },
        {
          "line": 247,
          "content": "    return _async_export_service"
        },
        {
          "line": 250,
          "content": "def queue_pdf_generation(execution_id: str, level: str = 'full', sections: str = 'all') -> str:"
        },
        {
          "line": 251,
          "content": "    \"\"\""
        },
        {
          "line": 261,
          "content": "    \"\"\""
        },
        {
          "line": 263,
          "content": "    return service.submit_task(execution_id, level, sections)"
        },
        {
          "line": 266,
          "content": "def get_export_task_status(task_id: str) -> Dict[str, Any]:"
        },
        {
          "line": 267,
          "content": "    \"\"\""
        },
        {
          "line": 275,
          "content": "    \"\"\""
        },
        {
          "line": 277,
          "content": "    return service.get_task_status(task_id)"
        },
        {
          "line": 280,
          "content": "def start_cleanup_thread(interval_hours: int = 1, max_age_hours: int = 24):"
        },
        {
          "line": 281,
          "content": "    \"\"\"启动定期清理线程\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/competitive_analysis_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\""
        },
        {
          "line": 22,
          "content": "    \"\"\""
        },
        {
          "line": 30,
          "content": "        \"\"\""
        },
        {
          "line": 40,
          "content": "        \"\"\""
        },
        {
          "line": 72,
          "content": "        \"\"\""
        },
        {
          "line": 80,
          "content": "        \"\"\""
        },
        {
          "line": 95,
          "content": "        \"\"\""
        },
        {
          "line": 103,
          "content": "        \"\"\""
        },
        {
          "line": 134,
          "content": "        \"\"\""
        },
        {
          "line": 142,
          "content": "        \"\"\""
        },
        {
          "line": 151,
          "content": "        \"\"\""
        },
        {
          "line": 160,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/sse_service_v2.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "\"\"\""
        },
        {
          "line": 33,
          "content": "    \"\"\"SSE 连接\"\"\""
        },
        {
          "line": 35,
          "content": "    def __init__(self, execution_id: str, client_id: str):"
        },
        {
          "line": 45,
          "content": "    def send(self, event_type: str, data: Dict[str, Any]):"
        },
        {
          "line": 46,
          "content": "        \"\"\"发送消息到队列\"\"\""
        },
        {
          "line": 62,
          "content": "        \"\"\"获取待发送的消息\"\"\""
        },
        {
          "line": 66,
          "content": "            return messages"
        },
        {
          "line": 68,
          "content": "    def heartbeat(self):"
        },
        {
          "line": 69,
          "content": "        \"\"\"更新心跳\"\"\""
        },
        {
          "line": 73,
          "content": "        \"\"\"检查是否过期\"\"\""
        },
        {
          "line": 74,
          "content": "        return datetime.now() - self.last_heartbeat > timedelta(seconds=CONNECTION_TIMEOUT)"
        },
        {
          "line": 76,
          "content": "    def close(self):"
        },
        {
          "line": 77,
          "content": "        \"\"\"关闭连接\"\"\""
        },
        {
          "line": 82,
          "content": "    \"\"\"SSE 连接管理器\"\"\""
        },
        {
          "line": 84,
          "content": "    def __init__(self):"
        },
        {
          "line": 92,
          "content": "    def add_connection(self, execution_id: str, client_id: str) -> SSEConnection:"
        },
        {
          "line": 93,
          "content": "        \"\"\"添加新连接\"\"\""
        },
        {
          "line": 106,
          "content": "        \"\"\"移除连接\"\"\""
        },
        {
          "line": 108,
          "content": "            if client_id in self.connections:"
        },
        {
          "line": 114,
          "content": "                if execution_id in self.execution_connections:"
        },
        {
          "line": 116,
          "content": "                    if not self.execution_connections[execution_id]:"
        },
        {
          "line": 121,
          "content": "    def broadcast(self, execution_id: str, event_type: str, data: Dict[str, Any]):"
        },
        {
          "line": 122,
          "content": "        \"\"\"向指定执行 ID 的所有连接广播消息\"\"\""
        },
        {
          "line": 137,
          "content": "        \"\"\"获取连接统计\"\"\""
        },
        {
          "line": 139,
          "content": "            return {"
        },
        {
          "line": 145,
          "content": "    def cleanup_inactive(self):"
        },
        {
          "line": 146,
          "content": "        \"\"\"清理过期连接\"\"\""
        },
        {
          "line": 166,
          "content": "    \"\"\"获取 SSE Manager 单例\"\"\""
        },
        {
          "line": 168,
          "content": "    if _sse_manager is None:"
        },
        {
          "line": 170,
          "content": "            if _sse_manager is None:"
        },
        {
          "line": 172,
          "content": "    return _sse_manager"
        },
        {
          "line": 175,
          "content": "def sse_response(client_id: str):"
        },
        {
          "line": 176,
          "content": "    \"\"\""
        },
        {
          "line": 184,
          "content": "    \"\"\""
        },
        {
          "line": 188,
          "content": "    if not execution_id:"
        },
        {
          "line": 189,
          "content": "        return Response("
        },
        {
          "line": 198,
          "content": "    def generate():"
        },
        {
          "line": 199,
          "content": "        \"\"\"生成 SSE 事件流\"\"\""
        },
        {
          "line": 246,
          "content": "    \"\"\""
        },
        {
          "line": 255,
          "content": "    \"\"\""
        },
        {
          "line": 268,
          "content": "    \"\"\""
        },
        {
          "line": 274,
          "content": "    \"\"\""
        },
        {
          "line": 284,
          "content": "    \"\"\""
        },
        {
          "line": 290,
          "content": "    \"\"\""
        },
        {
          "line": 300,
          "content": "    \"\"\""
        },
        {
          "line": 306,
          "content": "    \"\"\""
        },
        {
          "line": 316,
          "content": "    \"\"\""
        },
        {
          "line": 323,
          "content": "    \"\"\""
        },
        {
          "line": 341,
          "content": "    \"\"\"启动后台清理线程\"\"\""
        },
        {
          "line": 344,
          "content": "    def cleanup_loop():"
        },
        {
          "line": 345,
          "content": "        while True:"
        },
        {
          "line": 358,
          "content": "def register_sse_routes(app):"
        },
        {
          "line": 359,
          "content": "    \"\"\"注册 SSE 路由\"\"\""
        },
        {
          "line": 363,
          "content": "        \"\"\"SSE 进度推送端点\"\"\""
        },
        {
          "line": 364,
          "content": "        return sse_response(client_id)"
        },
        {
          "line": 367,
          "content": "    def sse_stats():"
        },
        {
          "line": 368,
          "content": "        \"\"\"SSE 连接统计\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/enhanced_pdf_service.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 30,
          "content": "    \"\"\""
        },
        {
          "line": 33,
          "content": "    \"\"\""
        },
        {
          "line": 56,
          "content": "        \"\"\"注册中文字体\"\"\""
        },
        {
          "line": 65,
          "content": "        for font_path in font_paths:"
        },
        {
          "line": 78,
          "content": "    def _create_styles(self):"
        },
        {
          "line": 79,
          "content": "        \"\"\"创建样式\"\"\""
        },
        {
          "line": 176,
          "content": "        \"\"\""
        },
        {
          "line": 186,
          "content": "        \"\"\""
        },
        {
          "line": 249,
          "content": "        \"\"\"创建封面\"\"\""
        },
        {
          "line": 299,
          "content": "        return elements"
        },
        {
          "line": 301,
          "content": "    def _create_executive_summary(self, report_data: Dict[str, Any]) -> List:"
        },
        {
          "line": 302,
          "content": "        \"\"\"创建执行摘要\"\"\""
        },
        {
          "line": 341,
          "content": "        \"\"\"创建品牌健康度章节\"\"\""
        },
        {
          "line": 360,
          "content": "        for dim_key, dim_name in dimension_names.items():"
        },
        {
          "line": 362,
          "content": "            if score >= 80:"
        },
        {
          "line": 364,
          "content": "            elif score >= 70:"
        },
        {
          "line": 366,
          "content": "            elif score >= 60:"
        },
        {
          "line": 386,
          "content": "        return elements"
        },
        {
          "line": 388,
          "content": "    def _create_platform_analysis(self, report_data: Dict[str, Any]) -> List:"
        },
        {
          "line": 389,
          "content": "        \"\"\"创建平台分析章节\"\"\""
        },
        {
          "line": 423,
          "content": "        \"\"\"创建竞品分析章节\"\"\""
        },
        {
          "line": 446,
          "content": "        if competitors:"
        },
        {
          "line": 451,
          "content": "            for comp in competitors[:5]:"
        },
        {
          "line": 475,
          "content": "        return elements"
        },
        {
          "line": 477,
          "content": "    def _create_negative_sources(self, report_data: Dict[str, Any]) -> List:"
        },
        {
          "line": 478,
          "content": "        \"\"\"创建负面信源章节\"\"\""
        },
        {
          "line": 535,
          "content": "        \"\"\"创建 ROI 分析章节\"\"\""
        },
        {
          "line": 552,
          "content": "        for i, row in enumerate(table_data[1:], 1):"
        },
        {
          "line": 554,
          "content": "            actual = float(row[1].replace('x', '').split()[0]) if row[1] else 0"
        },
        {
          "line": 555,
          "content": "            if actual > industry_avg:"
        },
        {
          "line": 557,
          "content": "            elif actual < industry_avg:"
        },
        {
          "line": 576,
          "content": "        return elements"
        },
        {
          "line": 578,
          "content": "    def _create_action_plan(self, report_data: Dict[str, Any]) -> List:"
        },
        {
          "line": 579,
          "content": "        \"\"\"创建行动计划章节\"\"\""
        },
        {
          "line": 643,
          "content": "    \"\"\"获取增强版 PDF 服务实例\"\"\""
        },
        {
          "line": 645,
          "content": "    if _enhanced_pdf_service is None:"
        },
        {
          "line": 647,
          "content": "    return _enhanced_pdf_service"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/export_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\""
        },
        {
          "line": 22,
          "content": "    \"\"\""
        },
        {
          "line": 29,
          "content": "        \"\"\""
        },
        {
          "line": 38,
          "content": "        \"\"\""
        },
        {
          "line": 70,
          "content": "        \"\"\""
        },
        {
          "line": 79,
          "content": "        \"\"\""
        },
        {
          "line": 104,
          "content": "        \"\"\""
        },
        {
          "line": 114,
          "content": "        \"\"\""
        },
        {
          "line": 137,
          "content": "        \"\"\""
        },
        {
          "line": 146,
          "content": "        \"\"\""
        },
        {
          "line": 179,
          "content": "        \"\"\""
        },
        {
          "line": 181,
          "content": "        return html"
        },
        {
          "line": 184,
          "content": "    def _generate_brand_scores_html(brand_scores: Dict[str, Any]) -> str:"
        },
        {
          "line": 185,
          "content": "        \"\"\""
        },
        {
          "line": 193,
          "content": "        \"\"\""
        },
        {
          "line": 194,
          "content": "        if not brand_scores:"
        },
        {
          "line": 195,
          "content": "            return '<p>暂无评分数据</p>'"
        },
        {
          "line": 199,
          "content": "        for brand, scores in brand_scores.items():"
        },
        {
          "line": 206,
          "content": "            \"\"\""
        },
        {
          "line": 213,
          "content": "        \"\"\""
        },
        {
          "line": 221,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/recommendation_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 31,
          "content": "        \"\"\""
        },
        {
          "line": 41,
          "content": "        \"\"\""
        },
        {
          "line": 72,
          "content": "        \"\"\""
        },
        {
          "line": 80,
          "content": "        \"\"\""
        },
        {
          "line": 114,
          "content": "        \"\"\""
        },
        {
          "line": 122,
          "content": "        \"\"\""
        },
        {
          "line": 156,
          "content": "        \"\"\""
        },
        {
          "line": 164,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/action_plan_generator.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "    \"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\""
        },
        {
          "line": 143,
          "content": "        \"\"\""
        },
        {
          "line": 151,
          "content": "        \"\"\""
        },
        {
          "line": 220,
          "content": "        \"\"\"基于负面信源生成行动\"\"\""
        },
        {
          "line": 228,
          "content": "        if critical_count > 0:"
        },
        {
          "line": 229,
          "content": "            for source in sources[:3]:  # 最多处理前 3 个"
        },
        {
          "line": 230,
          "content": "                if source.get('severity') in ['critical', 'high']:"
        },
        {
          "line": 235,
          "content": "                        priority='critical' if source.get('severity') == 'critical' else 'high'"
        },
        {
          "line": 240,
          "content": "        return actions"
        },
        {
          "line": 242,
          "content": "    def _generate_competitive_actions(self, brand_name: str, health_data: Dict[str, Any],"
        },
        {
          "line": 244,
          "content": "        \"\"\"基于竞品对比生成行动\"\"\""
        },
        {
          "line": 274,
          "content": "        \"\"\"基于 ROI 指标生成行动\"\"\""
        },
        {
          "line": 281,
          "content": "        if industry_comparison.get('exposure_roi_vs_industry', 0) < 0:"
        },
        {
          "line": 287,
          "content": "        return actions"
        },
        {
          "line": 289,
          "content": "    def _generate_health_actions(self, brand_name: str,"
        },
        {
          "line": 291,
          "content": "        \"\"\"基于健康度生成常规行动\"\"\""
        },
        {
          "line": 348,
          "content": "        \"\"\"实例化行动模板\"\"\""
        },
        {
          "line": 349,
          "content": "        import re"
        },
        {
          "line": 354,
          "content": "        for key, value in template.items():"
        },
        {
          "line": 355,
          "content": "            if isinstance(value, str):"
        },
        {
          "line": 358,
          "content": "                for k, v in replacements.items():"
        },
        {
          "line": 360,
          "content": "            elif isinstance(value, list):"
        },
        {
          "line": 366,
          "content": "        if priority:"
        },
        {
          "line": 376,
          "content": "        return action"
        },
        {
          "line": 378,
          "content": "    def _calculate_priority_score(self, priority: str, impact: str, effort: str) -> float:"
        },
        {
          "line": 379,
          "content": "        \"\"\"计算优先级分数\"\"\""
        },
        {
          "line": 408,
          "content": "        \"\"\"计算总预算\"\"\""
        },
        {
          "line": 409,
          "content": "        return sum(a.get('estimated_budget', 0) for a in actions)"
        },
        {
          "line": 411,
          "content": "    def _estimate_improvement(self, health_data: Dict[str, Any],"
        },
        {
          "line": 413,
          "content": "        \"\"\"评估预期效果\"\"\""
        },
        {
          "line": 439,
          "content": "    \"\"\"获取行动计划生成器实例\"\"\""
        },
        {
          "line": 441,
          "content": "    if _action_plan_generator is None:"
        },
        {
          "line": 443,
          "content": "    return _action_plan_generator"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/sse_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\"SSE 连接\"\"\""
        },
        {
          "line": 18,
          "content": "    def __init__(self, execution_id: str, client_id: str):"
        },
        {
          "line": 26,
          "content": "    def send(self, event_type: str, data: Dict[str, Any]):"
        },
        {
          "line": 27,
          "content": "        \"\"\"发送消息到队列\"\"\""
        },
        {
          "line": 38,
          "content": "        \"\"\"获取待发送的消息\"\"\""
        },
        {
          "line": 41,
          "content": "        return messages"
        },
        {
          "line": 43,
          "content": "    def heartbeat(self):"
        },
        {
          "line": 44,
          "content": "        \"\"\"更新心跳\"\"\""
        },
        {
          "line": 48,
          "content": "        \"\"\"关闭连接\"\"\""
        },
        {
          "line": 52,
          "content": "class SSEManager:"
        },
        {
          "line": 53,
          "content": "    \"\"\"SSE 连接管理器\"\"\""
        },
        {
          "line": 63,
          "content": "        \"\"\"添加新连接\"\"\""
        },
        {
          "line": 68,
          "content": "            if execution_id not in self.execution_connections:"
        },
        {
          "line": 72,
          "content": "            api_logger.info(f\"[SSE] New connection: {client_id} for execution {execution_id}\")"
        },
        {
          "line": 73,
          "content": "            return connection"
        },
        {
          "line": 75,
          "content": "    def remove_connection(self, client_id: str):"
        },
        {
          "line": 76,
          "content": "        \"\"\"移除连接\"\"\""
        },
        {
          "line": 92,
          "content": "        \"\"\"向指定执行 ID 的所有连接广播消息\"\"\""
        },
        {
          "line": 94,
          "content": "            if execution_id not in self.execution_connections:"
        },
        {
          "line": 99,
          "content": "        for client_id in client_ids:"
        },
        {
          "line": 100,
          "content": "            if client_id in self.connections:"
        },
        {
          "line": 102,
          "content": "                if connection.is_active:"
        },
        {
          "line": 105,
          "content": "    def get_connection(self, client_id: str) -> Optional[SSEConnection]:"
        },
        {
          "line": 106,
          "content": "        \"\"\"获取连接\"\"\""
        },
        {
          "line": 110,
          "content": "        \"\"\"清理非活动连接\"\"\""
        },
        {
          "line": 115,
          "content": "            for client_id, connection in self.connections.items():"
        },
        {
          "line": 117,
          "content": "                if elapsed > timeout_seconds:"
        },
        {
          "line": 120,
          "content": "        for client_id in to_remove:"
        },
        {
          "line": 124,
          "content": "    def get_stats(self) -> Dict[str, Any]:"
        },
        {
          "line": 125,
          "content": "        \"\"\"获取统计信息\"\"\""
        },
        {
          "line": 142,
          "content": "    \"\"\"获取全局 SSE 管理器\"\"\""
        },
        {
          "line": 144,
          "content": "    if _sse_manager is None:"
        },
        {
          "line": 146,
          "content": "    return _sse_manager"
        },
        {
          "line": 149,
          "content": "def create_sse_response(client_id: str) -> Response:"
        },
        {
          "line": 150,
          "content": "    \"\"\""
        },
        {
          "line": 158,
          "content": "    \"\"\""
        },
        {
          "line": 162,
          "content": "    if not connection:"
        },
        {
          "line": 163,
          "content": "        api_logger.error(f\"[SSE] Connection not found for client: {client_id}\")"
        },
        {
          "line": 164,
          "content": "        return Response("
        },
        {
          "line": 174,
          "content": "    def generate():"
        },
        {
          "line": 175,
          "content": "        \"\"\"生成 SSE 事件流\"\"\""
        },
        {
          "line": 213,
          "content": "    \"\"\""
        },
        {
          "line": 222,
          "content": "    \"\"\""
        },
        {
          "line": 235,
          "content": "    \"\"\""
        },
        {
          "line": 241,
          "content": "    \"\"\""
        },
        {
          "line": 251,
          "content": "    \"\"\""
        },
        {
          "line": 257,
          "content": "    \"\"\""
        },
        {
          "line": 267,
          "content": "    \"\"\""
        },
        {
          "line": 274,
          "content": "    \"\"\""
        },
        {
          "line": 289,
          "content": "    \"\"\"启动后台清理线程\"\"\""
        },
        {
          "line": 292,
          "content": "    def cleanup_loop():"
        },
        {
          "line": 293,
          "content": "        while True:"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/pdf_export_service.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\"PDF 导出服务\"\"\""
        },
        {
          "line": 25,
          "content": "    def __init__(self):"
        },
        {
          "line": 30,
          "content": "    def _register_chinese_font(self):"
        },
        {
          "line": 31,
          "content": "        \"\"\"注册中文字体以支持中文 PDF\"\"\""
        },
        {
          "line": 59,
          "content": "        \"\"\""
        },
        {
          "line": 69,
          "content": "        \"\"\""
        },
        {
          "line": 76,
          "content": "        \"\"\""
        },
        {
          "line": 84,
          "content": "        \"\"\""
        },
        {
          "line": 107,
          "content": "        \"\"\"创建样式\"\"\""
        },
        {
          "line": 111,
          "content": "        font_name = 'Chinese' if self.chinese_font_registered else 'Helvetica'"
        },
        {
          "line": 146,
          "content": "        return {"
        },
        {
          "line": 153,
          "content": "    def _create_title(self, brand_name: str, styles: Dict[str, ParagraphStyle]) -> Paragraph:"
        },
        {
          "line": 154,
          "content": "        \"\"\"创建标题\"\"\""
        },
        {
          "line": 176,
          "content": "        \"\"\"创建基本信息\"\"\""
        },
        {
          "line": 184,
          "content": "        <b>竞品对比：</b>{competitors if competitors else '无'}<br/>"
        },
        {
          "line": 185,
          "content": "        <b>AI 模型：</b>{ai_models if ai_models else '无'}<br/>"
        },
        {
          "line": 187,
          "content": "        \"\"\""
        },
        {
          "line": 192,
          "content": "        \"\"\"创建总体评分\"\"\""
        },
        {
          "line": 196,
          "content": "        if overall_score >= 90:"
        },
        {
          "line": 199,
          "content": "        elif overall_score >= 75:"
        },
        {
          "line": 202,
          "content": "        elif overall_score >= 60:"
        },
        {
          "line": 212,
          "content": "        \"\"\""
        },
        {
          "line": 217,
          "content": "        \"\"\"创建平台评分表格\"\"\""
        },
        {
          "line": 224,
          "content": "        for ps in platform_scores:"
        },
        {
          "line": 228,
          "content": "            if score >= 90:"
        },
        {
          "line": 230,
          "content": "            elif score >= 75:"
        },
        {
          "line": 232,
          "content": "            elif score >= 60:"
        },
        {
          "line": 252,
          "content": "        from reportlab.platypus import Flowable"
        },
        {
          "line": 253,
          "content": "        class TableFlowable(Flowable):"
        },
        {
          "line": 254,
          "content": "            def __init__(self, table):"
        },
        {
          "line": 258,
          "content": "            def draw(self):"
        },
        {
          "line": 264,
          "content": "        return Paragraph(f\"共测试 {len(platform_scores)} 个 AI 平台，详见表格\", styles['normal'])"
        },
        {
          "line": 266,
          "content": "    def _create_dimension_scores(self, dimension_scores: Dict[str, Any], styles: Dict[str, ParagraphStyle]) -> Paragraph:"
        },
        {
          "line": 267,
          "content": "        \"\"\"创建维度评分\"\"\""
        },
        {
          "line": 312,
          "content": "        \"\"\"创建优化建议\"\"\""
        },
        {
          "line": 317,
          "content": "        for i, rec in enumerate(recommendations, 1):"
        },
        {
          "line": 325,
          "content": "            \"\"\""
        },
        {
          "line": 338,
          "content": "    \"\"\"获取 PDF 导出服务实例\"\"\""
        },
        {
          "line": 340,
          "content": "    if _pdf_export_service is None:"
        },
        {
          "line": 342,
          "content": "    return _pdf_export_service"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/report_generation_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 32,
          "content": "        \"\"\""
        },
        {
          "line": 43,
          "content": "        \"\"\""
        },
        {
          "line": 75,
          "content": "        \"\"\""
        },
        {
          "line": 83,
          "content": "        \"\"\""
        },
        {
          "line": 103,
          "content": "        \"\"\""
        },
        {
          "line": 112,
          "content": "        \"\"\""
        },
        {
          "line": 163,
          "content": "        \"\"\""
        },
        {
          "line": 172,
          "content": "        \"\"\""
        },
        {
          "line": 182,
          "content": "        \"\"\""
        },
        {
          "line": 190,
          "content": "        \"\"\""
        },
        {
          "line": 229,
          "content": "        \"\"\""
        },
        {
          "line": 231,
          "content": "        return html"
        },
        {
          "line": 234,
          "content": "    def _generate_brand_scores_html(brand_scores: Dict[str, Any]) -> str:"
        },
        {
          "line": 235,
          "content": "        \"\"\""
        },
        {
          "line": 243,
          "content": "        \"\"\""
        },
        {
          "line": 244,
          "content": "        if not brand_scores:"
        },
        {
          "line": 245,
          "content": "            return '<p>暂无评分数据</p>'"
        },
        {
          "line": 249,
          "content": "        for brand, scores in brand_scores.items():"
        },
        {
          "line": 256,
          "content": "            \"\"\""
        },
        {
          "line": 263,
          "content": "        \"\"\""
        },
        {
          "line": 271,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/brand_analysis_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\"品牌分析服务\"\"\""
        },
        {
          "line": 20,
          "content": "    def __init__(self):"
        },
        {
          "line": 23,
          "content": "    def analyze_brand_mentions("
        },
        {
          "line": 29,
          "content": "        \"\"\""
        },
        {
          "line": 39,
          "content": "        \"\"\""
        },
        {
          "line": 48,
          "content": "        for result in results:"
        },
        {
          "line": 53,
          "content": "        if not competitor_brands:"
        },
        {
          "line": 54,
          "content": "            competitor_brands = list(set([b['name'] for b in all_top3_brands if b['name'] != user_brand]))[:3]"
        },
        {
          "line": 58,
          "content": "        for result in results:"
        },
        {
          "line": 69,
          "content": "            'mentioned_count': sum(1 for m in user_brand_mentions if m['brand_mentioned']),"
        },
        {
          "line": 71,
          "content": "            'mention_rate': sum(1 for m in user_brand_mentions if m['brand_mentioned']) / len(results),"
        },
        {
          "line": 77,
          "content": "        for competitor in competitor_brands:"
        },
        {
          "line": 79,
          "content": "            for result in results:"
        },
        {
          "line": 90,
          "content": "                'mentioned_count': sum(1 for m in competitor_mentions if m['brand_mentioned']),"
        },
        {
          "line": 101,
          "content": "        return analysis"
        },
        {
          "line": 103,
          "content": "    def _extract_top3_brands(self, response: str) -> List[Dict[str, Any]]:"
        },
        {
          "line": 104,
          "content": "        \"\"\"从回答中提取 TOP3 品牌\"\"\""
        },
        {
          "line": 124,
          "content": "        \"\"\"分析品牌在回答中的表现\"\"\""
        },
        {
          "line": 138,
          "content": "            if json_match:"
        },
        {
          "line": 141,
          "content": "                return {"
        },
        {
          "line": 153,
          "content": "        return {"
        },
        {
          "line": 155,
          "content": "            'rank': -1 if not mentioned else 0,"
        },
        {
          "line": 161,
          "content": "    def _calc_average_rank(self, mentions: List[Dict]) -> float:"
        },
        {
          "line": 162,
          "content": "        \"\"\"计算平均排名\"\"\""
        },
        {
          "line": 167,
          "content": "        \"\"\"计算平均情感分\"\"\""
        },
        {
          "line": 168,
          "content": "        sentiments = [m['sentiment'] for m in mentions if m['brand_mentioned']]"
        },
        {
          "line": 169,
          "content": "        return sum(sentiments) / len(sentiments) if sentiments else 0"
        },
        {
          "line": 171,
          "content": "    def _generate_comparison("
        },
        {
          "line": 176,
          "content": "        \"\"\"生成对比分析\"\"\""
        },
        {
          "line": 196,
          "content": "    \"\"\"获取品牌分析服务实例\"\"\""
        },
        {
          "line": 197,
          "content": "    return BrandAnalysisService()"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/semantic_analysis_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\""
        },
        {
          "line": 22,
          "content": "    \"\"\""
        },
        {
          "line": 30,
          "content": "        \"\"\""
        },
        {
          "line": 40,
          "content": "        \"\"\""
        },
        {
          "line": 91,
          "content": "        \"\"\""
        },
        {
          "line": 100,
          "content": "        \"\"\""
        },
        {
          "line": 124,
          "content": "        \"\"\""
        },
        {
          "line": 133,
          "content": "        \"\"\""
        },
        {
          "line": 144,
          "content": "        \"\"\""
        },
        {
          "line": 153,
          "content": "        \"\"\""
        },
        {
          "line": 161,
          "content": "        \"\"\""
        },
        {
          "line": 170,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/diagnosis_monitor_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "\"\"\""
        },
        {
          "line": 39,
          "content": "    \"\"\""
        },
        {
          "line": 42,
          "content": "    \"\"\""
        },
        {
          "line": 65,
          "content": "        ''')"
        },
        {
          "line": 79,
          "content": "def save_metric_to_db(metric: Dict):"
        },
        {
          "line": 80,
          "content": "    \"\"\""
        },
        {
          "line": 85,
          "content": "    \"\"\""
        },
        {
          "line": 97,
          "content": "        ''', ("
        },
        {
          "line": 124,
          "content": "    \"\"\"诊断指标记录\"\"\""
        },
        {
          "line": 126,
          "content": "    def __init__("
        },
        {
          "line": 148,
          "content": "        self.completion_rate = (completed_tasks / max(total_tasks, 1)) * 100 if total_tasks > 0 else 0"
        },
        {
          "line": 150,
          "content": "    def to_dict(self) -> Dict:"
        },
        {
          "line": 151,
          "content": "        \"\"\"转换为字典\"\"\""
        },
        {
          "line": 180,
          "content": "    \"\"\""
        },
        {
          "line": 193,
          "content": "    \"\"\""
        },
        {
          "line": 228,
          "content": "    \"\"\""
        },
        {
          "line": 236,
          "content": "    \"\"\""
        },
        {
          "line": 332,
          "content": "    \"\"\"计算百分位数\"\"\""
        },
        {
          "line": 333,
          "content": "    if not data:"
        },
        {
          "line": 334,
          "content": "        return 0"
        },
        {
          "line": 338,
          "content": "    if index >= len(sorted_data):"
        },
        {
          "line": 341,
          "content": "    return round(sorted_data[index], 2)"
        },
        {
          "line": 344,
          "content": "def _empty_dashboard() -> Dict:"
        },
        {
          "line": 345,
          "content": "    \"\"\"返回空大盘数据\"\"\""
        },
        {
          "line": 378,
          "content": "    \"\"\"清理过期指标数据\"\"\""
        },
        {
          "line": 385,
          "content": "            date_str for date_str in _diagnosis_metrics.keys()"
        },
        {
          "line": 386,
          "content": "            if date_str < cutoff_str"
        },
        {
          "line": 389,
          "content": "        for date_str in dates_to_remove:"
        },
        {
          "line": 392,
          "content": "        if dates_to_remove:"
        },
        {
          "line": 396,
          "content": "def get_recent_diagnosis_list(limit: int = 20) -> List[Dict]:"
        },
        {
          "line": 397,
          "content": "    \"\"\""
        },
        {
          "line": 405,
          "content": "    \"\"\""
        },
        {
          "line": 412,
          "content": "        for date_str in sorted_dates:"
        },
        {
          "line": 413,
          "content": "            for execution_id, metric in _diagnosis_metrics[date_str].items():"
        },
        {
          "line": 416,
          "content": "                if len(all_metrics) >= limit:"
        },
        {
          "line": 419,
          "content": "            if len(all_metrics) >= limit:"
        },
        {
          "line": 425,
          "content": "    return all_metrics[:limit]"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/report_data_service.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 22,
          "content": "    \"\"\""
        },
        {
          "line": 29,
          "content": "        \"\"\"获取数据库连接\"\"\""
        },
        {
          "line": 30,
          "content": "        if self.db is None:"
        },
        {
          "line": 32,
          "content": "            from wechat_backend.database_core import get_connection as get_db_conn"
        },
        {
          "line": 33,
          "content": "            import sqlite3"
        },
        {
          "line": 38,
          "content": "        return self.db"
        },
        {
          "line": 40,
          "content": "    def generate_full_report(self, execution_id: str) -> Dict[str, Any]:"
        },
        {
          "line": 41,
          "content": "        \"\"\""
        },
        {
          "line": 49,
          "content": "        \"\"\""
        },
        {
          "line": 57,
          "content": "            if not base_data:"
        },
        {
          "line": 67,
          "content": "            from wechat_backend.services.roi_calculator import get_roi_calculator"
        },
        {
          "line": 76,
          "content": "            from wechat_backend.services.action_plan_generator import get_action_plan_generator"
        },
        {
          "line": 107,
          "content": "            return {"
        },
        {
          "line": 128,
          "content": "    def _get_base_data(self, execution_id: str) -> Dict[str, Any]:"
        },
        {
          "line": 129,
          "content": "        \"\"\"获取基础诊断数据\"\"\""
        },
        {
          "line": 145,
          "content": "        \"\"\")"
        },
        {
          "line": 149,
          "content": "        if not rows:"
        },
        {
          "line": 156,
          "content": "            \"\"\", (execution_id,))"
        },
        {
          "line": 263,
          "content": "        \"\"\"构建平台评分列表\"\"\""
        },
        {
          "line": 269,
          "content": "        if isinstance(detailed_results, list):"
        },
        {
          "line": 270,
          "content": "            for result in detailed_results:"
        },
        {
          "line": 271,
          "content": "                if isinstance(result, dict):"
        },
        {
          "line": 279,
          "content": "        return platform_scores"
        },
        {
          "line": 281,
          "content": "    def _build_dimension_scores(self, base_data: Dict[str, Any]) -> Dict[str, Any]:"
        },
        {
          "line": 282,
          "content": "        \"\"\"构建维度评分\"\"\""
        },
        {
          "line": 291,
          "content": "        \"\"\"获取或生成竞品对比数据\"\"\""
        },
        {
          "line": 299,
          "content": "        \"\"\", (execution_id,))"
        },
        {
          "line": 337,
          "content": "        \"\"\"生成模拟竞品数据\"\"\""
        },
        {
          "line": 338,
          "content": "        import random"
        },
        {
          "line": 351,
          "content": "        for i, name in enumerate(competitor_names):"
        },
        {
          "line": 372,
          "content": "        return competitors"
        },
        {
          "line": 374,
          "content": "    def _build_radar_data(self, base_data: Dict[str, Any], competitors: List[Dict[str, Any]]) -> Dict[str, Any]:"
        },
        {
          "line": 375,
          "content": "        \"\"\"构建雷达图数据\"\"\""
        },
        {
          "line": 421,
          "content": "        \"\"\"生成对比摘要\"\"\""
        },
        {
          "line": 426,
          "content": "        for comp in competitors:"
        },
        {
          "line": 430,
          "content": "        my_rank = next(i for i, (name, score) in enumerate(all_scores) if name == base_data.get('brand_name', '我方品牌')) + 1"
        },
        {
          "line": 436,
          "content": "        return {"
        },
        {
          "line": 442,
          "content": "            'average_competitor_score': round(sum(s for _, s in all_scores[1:]) / len(all_scores[1:]), 1) if len(all_scores) > 1 else 0"
        },
        {
          "line": 445,
          "content": "    def _get_or_generate_negative_sources(self, execution_id: str, base_data: Dict[str, Any]) -> Dict[str, Any]:"
        },
        {
          "line": 446,
          "content": "        \"\"\"获取或生成负面信源数据\"\"\""
        },
        {
          "line": 455,
          "content": "        \"\"\", (execution_id,))"
        },
        {
          "line": 459,
          "content": "        if rows:"
        },
        {
          "line": 461,
          "content": "            for row in rows:"
        },
        {
          "line": 462,
          "content": "                columns = [description[0] for description in cursor.description]"
        },
        {
          "line": 466,
          "content": "            return {"
        },
        {
          "line": 474,
          "content": "        return {"
        },
        {
          "line": 480,
          "content": "    def _generate_mock_negative_sources(self, base_data: Dict[str, Any]) -> List[Dict[str, Any]]:"
        },
        {
          "line": 481,
          "content": "        \"\"\"生成模拟负面信源数据\"\"\""
        },
        {
          "line": 532,
          "content": "        \"\"\"生成负面信源摘要\"\"\""
        },
        {
          "line": 533,
          "content": "        if not sources:"
        },
        {
          "line": 534,
          "content": "            return {"
        },
        {
          "line": 545,
          "content": "        for source in sources:"
        },
        {
          "line": 549,
          "content": "        avg_sentiment = sum(s.get('sentiment_score', 0) for s in sources) / len(sources)"
        },
        {
          "line": 550,
          "content": "        total_reach = sum(s.get('estimated_reach', 0) for s in sources)"
        },
        {
          "line": 552,
          "content": "        return {"
        },
        {
          "line": 562,
          "content": "    def _calculate_roi(self, base_data: Dict[str, Any], competitive_data: Dict[str, Any]) -> Dict[str, Any]:"
        },
        {
          "line": 563,
          "content": "        \"\"\"计算 ROI 指标\"\"\""
        },
        {
          "line": 625,
          "content": "        \"\"\"生成行动计划\"\"\""
        },
        {
          "line": 633,
          "content": "        for source in negative_sources.get('sources', [])[:2]:"
        },
        {
          "line": 634,
          "content": "            if source.get('severity') in ['critical', 'high']:"
        },
        {
          "line": 718,
          "content": "        total_hours = sum(a.get('estimated_hours', 0) for a in all_actions)"
        },
        {
          "line": 721,
          "content": "        return {"
        },
        {
          "line": 737,
          "content": "    def _generate_executive_summary(self, base_data: Dict[str, Any], competitive_data: Dict[str, Any],"
        },
        {
          "line": 740,
          "content": "        \"\"\"生成执行摘要\"\"\""
        },
        {
          "line": 851,
          "content": "        \"\"\"生成摘要文本\"\"\""
        },
        {
          "line": 852,
          "content": "        findings_text = '\\n'.join([f\"• {finding}\" for finding in key_findings[:3]])"
        },
        {
          "line": 854,
          "content": "        return f\"\"\"{brand_name}品牌健康度评分为{overall_score}分，等级{health_grade}。"
        },
        {
          "line": 861,
          "content": "    def _save_report_data(self, execution_id: str, competitive_data: Dict[str, Any],"
        },
        {
          "line": 864,
          "content": "        \"\"\"保存报告数据到数据库\"\"\""
        },
        {
          "line": 880,
          "content": "            \"\"\", ("
        },
        {
          "line": 905,
          "content": "def get_report_data_service() -> ReportDataService:"
        },
        {
          "line": 906,
          "content": "    \"\"\"获取报告数据服务实例\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/services/analytics_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 8,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 30,
          "content": "        \"\"\""
        },
        {
          "line": 39,
          "content": "        \"\"\""
        },
        {
          "line": 97,
          "content": "        \"\"\""
        },
        {
          "line": 106,
          "content": "        \"\"\""
        },
        {
          "line": 154,
          "content": "        \"\"\""
        },
        {
          "line": 164,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/monetization_service.py",
      "lines": [
        {
          "line": 10,
          "content": "    \"\"\""
        },
        {
          "line": 12,
          "content": "    \"\"\""
        },
        {
          "line": 22,
          "content": "        \"\"\"检查用户是否有权限访问某个功能\"\"\""
        },
        {
          "line": 24,
          "content": "        return self.user_level in required_levels"
        },
        {
          "line": 26,
          "content": "class MonetizationService:"
        },
        {
          "line": 27,
          "content": "    \"\"\""
        },
        {
          "line": 29,
          "content": "    \"\"\""
        },
        {
          "line": 30,
          "content": "    def __init__(self, user_level: UserLevel):"
        },
        {
          "line": 34,
          "content": "    def strip_data_for_user(self, data: Dict[str, Any]) -> Dict[str, Any]:"
        },
        {
          "line": 35,
          "content": "        \"\"\""
        },
        {
          "line": 37,
          "content": "        \"\"\""
        },
        {
          "line": 38,
          "content": "        if self.user_level == UserLevel.FREE:"
        },
        {
          "line": 40,
          "content": "            if \"competitiveAnalysis\" in data and \"brandScores\" in data[\"competitiveAnalysis\"]:"
        },
        {
          "line": 41,
          "content": "                for brand, scores in data[\"competitiveAnalysis\"][\"brandScores\"].items():"
        },
        {
          "line": 43,
          "content": "                    if isinstance(scores, dict):"
        },
        {
          "line": 57,
          "content": "                        if \"enhanced_data\" in scores:"
        },
        {
          "line": 93,
          "content": "            if \"sourceIntelligenceMap\" in data:"
        },
        {
          "line": 99,
          "content": "        return data"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/asset_intelligence_engine.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\""
        },
        {
          "line": 47,
          "content": "        \"\"\""
        },
        {
          "line": 56,
          "content": "        \"\"\""
        },
        {
          "line": 97,
          "content": "        \"\"\""
        },
        {
          "line": 107,
          "content": "        \"\"\""
        },
        {
          "line": 150,
          "content": "        \"\"\""
        },
        {
          "line": 160,
          "content": "        \"\"\""
        },
        {
          "line": 209,
          "content": "        \"\"\""
        },
        {
          "line": 218,
          "content": "        \"\"\""
        },
        {
          "line": 244,
          "content": "        \"\"\""
        },
        {
          "line": 253,
          "content": "        \"\"\""
        },
        {
          "line": 279,
          "content": "        \"\"\""
        },
        {
          "line": 288,
          "content": "        \"\"\""
        },
        {
          "line": 330,
          "content": "    \"\"\""
        },
        {
          "line": 360,
          "content": "    for platform, analysis in result['platform_analyses'].items():"
        },
        {
          "line": 364,
          "content": "    for suggestion in result['optimization_suggestions']:"
        },
        {
          "line": 366,
          "content": "        if suggestion['suggested_keywords']:"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/source_intelligence_processor.py",
      "lines": [
        {
          "line": 11,
          "content": "    \"\"\""
        },
        {
          "line": 13,
          "content": "    \"\"\""
        },
        {
          "line": 42,
          "content": "    \"\"\""
        },
        {
          "line": 44,
          "content": "    \"\"\""
        },
        {
          "line": 100,
          "content": "        \"\"\""
        },
        {
          "line": 102,
          "content": "        \"\"\""
        },
        {
          "line": 186,
          "content": "        \"\"\""
        },
        {
          "line": 195,
          "content": "        \"\"\""
        },
        {
          "line": 224,
          "content": "    \"\"\""
        },
        {
          "line": 226,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/api_monitor.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\"API状态监控服务\"\"\""
        },
        {
          "line": 2,
          "content": "import time"
        },
        {
          "line": 3,
          "content": "from datetime import datetime, timedelta"
        },
        {
          "line": 4,
          "content": "from typing import Dict, List, Optional"
        },
        {
          "line": 5,
          "content": "from enum import Enum"
        },
        {
          "line": 6,
          "content": "import threading"
        },
        {
          "line": 7,
          "content": "from dataclasses import dataclass"
        },
        {
          "line": 10,
          "content": "class ApiStatus(Enum):"
        },
        {
          "line": 11,
          "content": "    \"\"\"API状态枚举\"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\"配额信息\"\"\""
        },
        {
          "line": 26,
          "content": "    def remaining(self) -> Optional[int]:"
        },
        {
          "line": 27,
          "content": "        if self.daily_limit is not None:"
        },
        {
          "line": 28,
          "content": "            return max(0, self.daily_limit - self.used_today)"
        },
        {
          "line": 29,
          "content": "        return None"
        },
        {
          "line": 32,
          "content": "class ApiMonitor:"
        },
        {
          "line": 33,
          "content": "    \"\"\"API状态监控服务\"\"\""
        },
        {
          "line": 41,
          "content": "        \"\"\"更新平台配置\"\"\""
        },
        {
          "line": 45,
          "content": "    def check_api_availability(self, platform: str) -> bool:"
        },
        {
          "line": 46,
          "content": "        \"\"\"检查API可用性\"\"\""
        },
        {
          "line": 62,
          "content": "        \"\"\"记录请求\"\"\""
        },
        {
          "line": 64,
          "content": "            if platform not in self.request_counts:"
        },
        {
          "line": 71,
          "content": "                t for t in self.request_counts[platform] if t > cutoff"
        },
        {
          "line": 74,
          "content": "    def get_rate_limit_remaining(self, platform: str) -> int:"
        },
        {
          "line": 75,
          "content": "        \"\"\"获取速率限制剩余\"\"\""
        },
        {
          "line": 90,
          "content": "        \"\"\"检查是否达到速率限制\"\"\""
        },
        {
          "line": 92,
          "content": "        if not config or not getattr(config, 'rate_limit_per_minute', None):"
        },
        {
          "line": 93,
          "content": "            return False"
        },
        {
          "line": 94,
          "content": "        return len(self.request_counts.get(platform, [])) >= config.rate_limit_per_minute"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/impact_calculator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "    \"\"\""
        },
        {
          "line": 12,
          "content": "    \"\"\""
        },
        {
          "line": 29,
          "content": "        \"\"\""
        },
        {
          "line": 40,
          "content": "        \"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\""
        },
        {
          "line": 75,
          "content": "        \"\"\""
        },
        {
          "line": 89,
          "content": "        \"\"\""
        },
        {
          "line": 97,
          "content": "        \"\"\""
        },
        {
          "line": 110,
          "content": "        \"\"\""
        },
        {
          "line": 118,
          "content": "        \"\"\""
        },
        {
          "line": 126,
          "content": "        \"\"\""
        },
        {
          "line": 134,
          "content": "        \"\"\""
        },
        {
          "line": 147,
          "content": "        \"\"\""
        },
        {
          "line": 155,
          "content": "        \"\"\""
        },
        {
          "line": 175,
          "content": "    \"\"\"测试影响力计算器\"\"\""
        },
        {
          "line": 204,
          "content": "    for i, case in enumerate(test_cases):"
        },
        {
          "line": 219,
          "content": "if __name__ == \"__main__\":"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/recommendation_generator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "    \"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\""
        },
        {
          "line": 57,
          "content": "        \"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\""
        },
        {
          "line": 119,
          "content": "        \"\"\""
        },
        {
          "line": 128,
          "content": "        \"\"\""
        },
        {
          "line": 155,
          "content": "        \"\"\""
        },
        {
          "line": 164,
          "content": "        \"\"\""
        },
        {
          "line": 187,
          "content": "        \"\"\""
        },
        {
          "line": 196,
          "content": "        \"\"\""
        },
        {
          "line": 217,
          "content": "        \"\"\""
        },
        {
          "line": 225,
          "content": "        \"\"\""
        },
        {
          "line": 232,
          "content": "        \"\"\""
        },
        {
          "line": 240,
          "content": "        \"\"\""
        },
        {
          "line": 262,
          "content": "        \"\"\""
        },
        {
          "line": 271,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/prediction_engine.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\""
        },
        {
          "line": 24,
          "content": "        \"\"\""
        },
        {
          "line": 34,
          "content": "        \"\"\""
        },
        {
          "line": 53,
          "content": "        \"\"\""
        },
        {
          "line": 62,
          "content": "        \"\"\""
        },
        {
          "line": 83,
          "content": "        \"\"\""
        },
        {
          "line": 92,
          "content": "        \"\"\""
        },
        {
          "line": 133,
          "content": "        \"\"\""
        },
        {
          "line": 142,
          "content": "        \"\"\""
        },
        {
          "line": 154,
          "content": "                # Create a unique identifier for this risk"
        },
        {
          "line": 157,
          "content": "                # Skip if we've already processed this risk"
        },
        {
          "line": 193,
          "content": "        \"\"\""
        },
        {
          "line": 202,
          "content": "        \"\"\""
        },
        {
          "line": 217,
          "content": "        \"\"\""
        },
        {
          "line": 225,
          "content": "        \"\"\""
        },
        {
          "line": 245,
          "content": "        \"\"\""
        },
        {
          "line": 253,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/workflow_manager.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 24,
          "content": "# Add the project root directory to the Python path to allow importing from utils"
        },
        {
          "line": 34,
          "content": "    \"\"\"任务优先级枚举\"\"\""
        },
        {
          "line": 41,
          "content": "class TaskStatus(Enum):"
        },
        {
          "line": 42,
          "content": "    \"\"\"任务状态枚举\"\"\""
        },
        {
          "line": 52,
          "content": "    \"\"\"工作流任务数据结构\"\"\""
        },
        {
          "line": 71,
          "content": "class WebhookManager:"
        },
        {
          "line": 72,
          "content": "    \"\"\"Webhook管理器 - 处理任务推送至第三方API\"\"\""
        },
        {
          "line": 86,
          "content": "        \"\"\""
        },
        {
          "line": 97,
          "content": "        \"\"\""
        },
        {
          "line": 143,
          "content": "        \"\"\""
        },
        {
          "line": 145,
          "content": "        \"\"\""
        },
        {
          "line": 176,
          "content": "    \"\"\"工作流管理器 - 智能任务分发系统\"\"\""
        },
        {
          "line": 178,
          "content": "    def __init__(self):"
        },
        {
          "line": 193,
          "content": "    def _start_background_processor(self):"
        },
        {
          "line": 194,
          "content": "        \"\"\"启动后台任务处理器\"\"\""
        },
        {
          "line": 214,
          "content": "        \"\"\"启动重试处理器\"\"\""
        },
        {
          "line": 215,
          "content": "        def retry_worker():"
        },
        {
          "line": 216,
          "content": "            while True:"
        },
        {
          "line": 219,
          "content": "                    if not self.retry_queue.empty():"
        },
        {
          "line": 223,
          "content": "                        if next_retry_time <= current_time:"
        },
        {
          "line": 240,
          "content": "    def create_task_package("
        },
        {
          "line": 251,
          "content": "        \"\"\""
        },
        {
          "line": 266,
          "content": "        \"\"\""
        },
        {
          "line": 289,
          "content": "        return task_package"
        },
        {
          "line": 291,
          "content": "    def dispatch_task("
        },
        {
          "line": 303,
          "content": "        \"\"\""
        },
        {
          "line": 319,
          "content": "        \"\"\""
        },
        {
          "line": 320,
          "content": "        import uuid"
        },
        {
          "line": 325,
          "content": "        debug_log(\"TASK_DISPATCH\", f\"Creating task package for task {task_id}\")"
        },
        {
          "line": 348,
          "content": "        debug_log(\"TASK_DISPATCH\", f\"Task {task_id} queued for dispatch to {webhook_url} with priority {priority.value}\")"
        },
        {
          "line": 350,
          "content": "        return task_id"
        },
        {
          "line": 352,
          "content": "    def _priority_to_number(self, priority: TaskPriority) -> int:"
        },
        {
          "line": 353,
          "content": "        \"\"\"将优先级转换为数字，用于队列排序\"\"\""
        },
        {
          "line": 363,
          "content": "        \"\"\"处理单个任务\"\"\""
        },
        {
          "line": 374,
          "content": "        if success:"
        },
        {
          "line": 383,
          "content": "            if retry_count < max_retries:"
        },
        {
          "line": 395,
          "content": "                debug_log(\"TASK_PROCESS\", f\"Task {task_id} failed, scheduled for retry #{retry_count + 1} at {next_retry_time} (delay: {delay_seconds}s)\")"
        },
        {
          "line": 402,
          "content": "    def _process_task_with_retry(self, task_data: Dict[str, Any]):"
        },
        {
          "line": 403,
          "content": "        \"\"\"处理重试任务\"\"\""
        },
        {
          "line": 442,
          "content": "        \"\"\"更新任务状态\"\"\""
        },
        {
          "line": 443,
          "content": "        # Extract execution_id from task_id if it contains one (for DEBUG_AI_CODE logging)"
        },
        {
          "line": 445,
          "content": "        execution_id = getattr(self, '_current_execution_id', 'unknown')  # Default to unknown if not set"
        },
        {
          "line": 451,
          "content": "        progress_value = getattr(self, '_current_progress', 0)  # Default to 0 if not set"
        },
        {
          "line": 459,
          "content": "        if ENABLE_DEBUG_AI_CODE:"
        },
        {
          "line": 462,
          "content": "    def get_task_status(self, task_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 463,
          "content": "        \"\"\"获取任务状态\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/interception_analyst.py",
      "lines": [
        {
          "line": 6,
          "content": "    \"\"\""
        },
        {
          "line": 9,
          "content": "    \"\"\""
        },
        {
          "line": 17,
          "content": "        \"\"\""
        },
        {
          "line": 25,
          "content": "        \"\"\""
        },
        {
          "line": 36,
          "content": "        \"\"\""
        },
        {
          "line": 43,
          "content": "        \"\"\""
        },
        {
          "line": 60,
          "content": "        \"\"\""
        },
        {
          "line": 68,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/report_generator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "\"\"\""
        },
        {
          "line": 30,
          "content": "    \"\"\"报告生成器 - 聚合测试结果、巡航趋势和工作流任务数据，计算ROI并生成报告\"\"\""
        },
        {
          "line": 32,
          "content": "    def __init__(self):"
        },
        {
          "line": 37,
          "content": "    def generate_executive_summary(self, brand_name: str, days: int = 30) -> Dict[str, Any]:"
        },
        {
          "line": 38,
          "content": "        \"\"\""
        },
        {
          "line": 47,
          "content": "        \"\"\""
        },
        {
          "line": 83,
          "content": "        return summary"
        },
        {
          "line": 85,
          "content": "    def _get_test_results(self, brand_name: str, days: int = 30) -> List[Dict[str, Any]]:"
        },
        {
          "line": 86,
          "content": "        \"\"\"获取测试结果数据\"\"\""
        },
        {
          "line": 98,
          "content": "        ''', (brand_name, start_date))"
        },
        {
          "line": 101,
          "content": "        for row in records_data:"
        },
        {
          "line": 105,
          "content": "            results_summary = json.loads(results_summary_str) if results_summary_str else {}"
        },
        {
          "line": 106,
          "content": "            detailed_results = json.loads(detailed_results_str) if detailed_results_str else []"
        },
        {
          "line": 112,
          "content": "                'ai_models_used': json.loads(ai_models_used) if ai_models_used else [],"
        },
        {
          "line": 113,
          "content": "                'questions_used': json.loads(questions_used) if questions_used else [],"
        },
        {
          "line": 120,
          "content": "        return test_results"
        },
        {
          "line": 122,
          "content": "    def _calculate_roi_metrics(self, test_results: List[Dict[str, Any]], trend_data: List[Dict[str, Any]]) -> Dict[str, Any]:"
        },
        {
          "line": 123,
          "content": "        \"\"\"计算ROI相关指标\"\"\""
        },
        {
          "line": 164,
          "content": "        \"\"\"计算预估曝光增量\"\"\""
        },
        {
          "line": 165,
          "content": "        if len(trend_data) < 2:"
        },
        {
          "line": 166,
          "content": "            return 0.0"
        },
        {
          "line": 173,
          "content": "        if initial_rank is None or final_rank is None:"
        },
        {
          "line": 174,
          "content": "            return 0.0"
        },
        {
          "line": 184,
          "content": "        return max(0, exposure_increment)  # 只返回非负值"
        },
        {
          "line": 186,
          "content": "    def _calculate_ranking_improvement(self, trend_data: List[Dict[str, Any]]) -> float:"
        },
        {
          "line": 187,
          "content": "        \"\"\"计算排名改善程度\"\"\""
        },
        {
          "line": 205,
          "content": "        \"\"\"计算情感趋势\"\"\""
        },
        {
          "line": 206,
          "content": "        if not trend_data:"
        },
        {
          "line": 207,
          "content": "            return {"
        },
        {
          "line": 214,
          "content": "        sentiment_scores = [point.get('sentiment_score', 0) for point in trend_data if point.get('sentiment_score') is not None]"
        },
        {
          "line": 216,
          "content": "        if not sentiment_scores:"
        },
        {
          "line": 217,
          "content": "            return {"
        },
        {
          "line": 226,
          "content": "        if len(sentiment_scores) >= 2:"
        },
        {
          "line": 231,
          "content": "            if change_magnitude > 0.1:"
        },
        {
          "line": 233,
          "content": "            elif change_magnitude < -0.1:"
        },
        {
          "line": 241,
          "content": "        return {"
        },
        {
          "line": 247,
          "content": "    def _calculate_avg_score(self, test_results: List[Dict[str, Any]]) -> float:"
        },
        {
          "line": 248,
          "content": "        \"\"\"计算平均分数\"\"\""
        },
        {
          "line": 256,
          "content": "        \"\"\"生成关键洞察\"\"\""
        },
        {
          "line": 260,
          "content": "        if test_results:"
        },
        {
          "line": 262,
          "content": "            if avg_score > 80:"
        },
        {
          "line": 264,
          "content": "            elif avg_score > 60:"
        },
        {
          "line": 270,
          "content": "        if trend_data:"
        },
        {
          "line": 272,
          "content": "            if ranking_improvement > 0:"
        },
        {
          "line": 274,
          "content": "            elif ranking_improvement < 0:"
        },
        {
          "line": 278,
          "content": "            if exposure_increment > 0:"
        },
        {
          "line": 283,
          "content": "        if roi_metrics['roi_percentage'] > 0:"
        },
        {
          "line": 285,
          "content": "        elif roi_metrics['roi_percentage'] < 0:"
        },
        {
          "line": 288,
          "content": "        return insights"
        },
        {
          "line": 290,
          "content": "    def _generate_recommendations(self, test_results: List[Dict[str, Any]], trend_data: List[Dict[str, Any]]) -> List[Dict[str, str]]:"
        },
        {
          "line": 291,
          "content": "        \"\"\"生成优化建议\"\"\""
        },
        {
          "line": 355,
          "content": "        \"\"\""
        },
        {
          "line": 364,
          "content": "        \"\"\""
        },
        {
          "line": 401,
          "content": "        \"\"\""
        },
        {
          "line": 454,
          "content": "        for insight in summary['key_insights']:"
        },
        {
          "line": 460,
          "content": "        for rec in summary['recommendations']:"
        },
        {
          "line": 477,
          "content": "        return pdf_data"
        },
        {
          "line": 479,
          "content": "    def get_hub_summary(self, brand_name: str, days: int = 7) -> Dict[str, Any]:"
        },
        {
          "line": 480,
          "content": "        \"\"\""
        },
        {
          "line": 489,
          "content": "        \"\"\""
        },
        {
          "line": 504,
          "content": "            if not test_results and not trend_data:"
        },
        {
          "line": 505,
          "content": "                return {"
        },
        {
          "line": 525,
          "content": "            return {"
        },
        {
          "line": 546,
          "content": "            self.logger.error(f\"Error generating hub summary for {brand_name}: {e}\")"
        },
        {
          "line": 547,
          "content": "            return {"
        },
        {
          "line": 569,
          "content": "if __name__ == \"__main__\":"
        },
        {
          "line": 572,
          "content": "    # Example: Generate summary for a brand"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/competitive_analyzer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "    \"\"\""
        },
        {
          "line": 14,
          "content": "    \"\"\""
        },
        {
          "line": 54,
          "content": "        \"\"\""
        },
        {
          "line": 65,
          "content": "        \"\"\""
        },
        {
          "line": 90,
          "content": "        \"\"\""
        },
        {
          "line": 99,
          "content": "        \"\"\""
        },
        {
          "line": 212,
          "content": "        \"\"\""
        },
        {
          "line": 224,
          "content": "        \"\"\""
        },
        {
          "line": 256,
          "content": "        \"\"\""
        },
        {
          "line": 265,
          "content": "        \"\"\""
        },
        {
          "line": 292,
          "content": "        \"\"\""
        },
        {
          "line": 301,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/source_aggregator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "    \"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\""
        },
        {
          "line": 39,
          "content": "        \"\"\""
        },
        {
          "line": 49,
          "content": "        \"\"\""
        },
        {
          "line": 66,
          "content": "        \"\"\""
        },
        {
          "line": 75,
          "content": "        \"\"\""
        },
        {
          "line": 124,
          "content": "        \"\"\""
        },
        {
          "line": 132,
          "content": "        \"\"\""
        },
        {
          "line": 153,
          "content": "        \"\"\""
        },
        {
          "line": 161,
          "content": "        \"\"\""
        },
        {
          "line": 173,
          "content": "        \"\"\""
        },
        {
          "line": 182,
          "content": "        \"\"\""
        },
        {
          "line": 230,
          "content": "        \"\"\""
        },
        {
          "line": 244,
          "content": "        \"\"\""
        },
        {
          "line": 324,
          "content": "        \"\"\""
        },
        {
          "line": 334,
          "content": "        \"\"\""
        },
        {
          "line": 357,
          "content": "        \"\"\""
        },
        {
          "line": 367,
          "content": "        \"\"\""
        },
        {
          "line": 395,
          "content": "        \"\"\""
        },
        {
          "line": 403,
          "content": "        \"\"\""
        },
        {
          "line": 420,
          "content": "        \"\"\""
        },
        {
          "line": 428,
          "content": "        \"\"\""
        },
        {
          "line": 455,
          "content": "        \"\"\""
        },
        {
          "line": 463,
          "content": "        \"\"\""
        },
        {
          "line": 469,
          "content": "        \"\"\""
        },
        {
          "line": 477,
          "content": "        \"\"\""
        },
        {
          "line": 497,
          "content": "        \"\"\""
        },
        {
          "line": 507,
          "content": "        \"\"\""
        },
        {
          "line": 534,
          "content": "        \"\"\""
        },
        {
          "line": 544,
          "content": "        \"\"\""
        },
        {
          "line": 585,
          "content": "        \"\"\""
        },
        {
          "line": 593,
          "content": "        \"\"\""
        },
        {
          "line": 600,
          "content": "        \"\"\""
        },
        {
          "line": 608,
          "content": "        \"\"\""
        },
        {
          "line": 642,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/rank_analyzer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 3,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "    \"\"\""
        },
        {
          "line": 14,
          "content": "    \"\"\""
        },
        {
          "line": 22,
          "content": "        \"\"\""
        },
        {
          "line": 31,
          "content": "        \"\"\""
        },
        {
          "line": 48,
          "content": "        \"\"\""
        },
        {
          "line": 57,
          "content": "        \"\"\""
        },
        {
          "line": 114,
          "content": "        \"\"\""
        },
        {
          "line": 124,
          "content": "        \"\"\""
        },
        {
          "line": 164,
          "content": "        \"\"\""
        },
        {
          "line": 173,
          "content": "        \"\"\""
        },
        {
          "line": 211,
          "content": "        \"\"\""
        },
        {
          "line": 220,
          "content": "        \"\"\""
        },
        {
          "line": 257,
          "content": "        \"\"\""
        },
        {
          "line": 266,
          "content": "        \"\"\""
        },
        {
          "line": 290,
          "content": "        \"\"\""
        },
        {
          "line": 299,
          "content": "        \"\"\""
        },
        {
          "line": 307,
          "content": "        \"\"\""
        },
        {
          "line": 316,
          "content": "        \"\"\""
        },
        {
          "line": 324,
          "content": "        \"\"\""
        },
        {
          "line": 333,
          "content": "        \"\"\""
        },
        {
          "line": 417,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/analytics/recommendation_system.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\"AI平台推荐系统\"\"\""
        },
        {
          "line": 2,
          "content": "from typing import Dict, List, Optional"
        },
        {
          "line": 3,
          "content": "from wechat_backend.analytics.api_monitor import ApiMonitor"
        },
        {
          "line": 6,
          "content": "class PlatformRecommendation:"
        },
        {
          "line": 7,
          "content": "    \"\"\"平台推荐系统\"\"\""
        },
        {
          "line": 14,
          "content": "        \"\"\"根据用户偏好和任务需求推荐平台\"\"\""
        },
        {
          "line": 19,
          "content": "            platform for platform, config in self.monitor.platform_status.items()"
        },
        {
          "line": 20,
          "content": "            if self.monitor.check_api_availability(platform)"
        },
        {
          "line": 35,
          "content": "        for platform in preferred_order:"
        },
        {
          "line": 36,
          "content": "            if platform in available_platforms:"
        },
        {
          "line": 40,
          "content": "        for platform in available_platforms:"
        },
        {
          "line": 41,
          "content": "            if platform not in recommendations:"
        },
        {
          "line": 44,
          "content": "        return recommendations"
        },
        {
          "line": 46,
          "content": "    def get_cost_efficient_platforms(self, budget_limit: float = None) -> List[str]:"
        },
        {
          "line": 47,
          "content": "        \"\"\"获取成本效益高的平台\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/config/ai_platforms.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "This module manages configuration for all AI platforms including:"
        },
        {
          "line": 14,
          "content": "\"\"\""
        },
        {
          "line": 53,
          "content": "    \"\"\""
        },
        {
          "line": 56,
          "content": "    Supports environment variable overrides for all configuration options."
        },
        {
          "line": 66,
          "content": "    \"\"\""
        },
        {
          "line": 69,
          "content": "    # Override from environment variables"
        },
        {
          "line": 95,
          "content": "    \"\"\""
        },
        {
          "line": 100,
          "content": "    \"\"\""
        },
        {
          "line": 105,
          "content": "    \"\"\""
        },
        {
          "line": 106,
          "content": "    Check if platform is configured (API Key exists)"
        },
        {
          "line": 112,
          "content": "        bool: True if API key is configured"
        },
        {
          "line": 113,
          "content": "    \"\"\""
        },
        {
          "line": 119,
          "content": "    \"\"\""
        },
        {
          "line": 120,
          "content": "    Get supported models for a platform"
        },
        {
          "line": 127,
          "content": "    \"\"\""
        },
        {
          "line": 133,
          "content": "    \"\"\""
        },
        {
          "line": 134,
          "content": "    Check if a model is supported by a platform"
        },
        {
          "line": 141,
          "content": "        bool: True if model is supported"
        },
        {
          "line": 142,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/config/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "    from wechat_backend.v2.config import get_platform_config, get_all_platforms"
        },
        {
          "line": 14,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/state_machine/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 7,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/state_machine/diagnosis_state_machine.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 50,
          "content": "    \"\"\""
        },
        {
          "line": 89,
          "content": "        \"\"\""
        },
        {
          "line": 98,
          "content": "        \"\"\""
        },
        {
          "line": 119,
          "content": "        \"\"\"获取执行 ID\"\"\""
        },
        {
          "line": 120,
          "content": "        return self._execution_id"
        },
        {
          "line": 122,
          "content": "    def get_current_state(self) -> DiagnosisState:"
        },
        {
          "line": 123,
          "content": "        \"\"\""
        },
        {
          "line": 128,
          "content": "        \"\"\""
        },
        {
          "line": 129,
          "content": "        return self._current_state"
        },
        {
          "line": 131,
          "content": "    def get_progress(self) -> int:"
        },
        {
          "line": 132,
          "content": "        \"\"\""
        },
        {
          "line": 137,
          "content": "        \"\"\""
        },
        {
          "line": 138,
          "content": "        return self._progress"
        },
        {
          "line": 140,
          "content": "    def get_metadata(self) -> Dict[str, Any]:"
        },
        {
          "line": 141,
          "content": "        \"\"\""
        },
        {
          "line": 146,
          "content": "        \"\"\""
        },
        {
          "line": 147,
          "content": "        return self._metadata.copy()"
        },
        {
          "line": 149,
          "content": "    def should_stop_polling(self) -> bool:"
        },
        {
          "line": 150,
          "content": "        \"\"\""
        },
        {
          "line": 157,
          "content": "        \"\"\""
        },
        {
          "line": 158,
          "content": "        return self._current_state.should_stop_polling"
        },
        {
          "line": 160,
          "content": "    def is_terminal_state(self) -> bool:"
        },
        {
          "line": 161,
          "content": "        \"\"\""
        },
        {
          "line": 166,
          "content": "        \"\"\""
        },
        {
          "line": 167,
          "content": "        return self._current_state.is_terminal"
        },
        {
          "line": 169,
          "content": "    def transition("
        },
        {
          "line": 175,
          "content": "        \"\"\""
        },
        {
          "line": 195,
          "content": "        \"\"\""
        },
        {
          "line": 197,
          "content": "        if self._current_state.is_terminal:"
        },
        {
          "line": 208,
          "content": "            return False"
        },
        {
          "line": 213,
          "content": "        if event not in allowed_transitions:"
        },
        {
          "line": 224,
          "content": "            return False"
        },
        {
          "line": 233,
          "content": "        if progress is not None:"
        },
        {
          "line": 237,
          "content": "        if self._current_state == DiagnosisState.COMPLETED:"
        },
        {
          "line": 261,
          "content": "        return True"
        },
        {
          "line": 263,
          "content": "    def _validate_progress(self, progress: int) -> int:"
        },
        {
          "line": 264,
          "content": "        \"\"\""
        },
        {
          "line": 275,
          "content": "        \"\"\""
        },
        {
          "line": 276,
          "content": "        if not isinstance(progress, int):"
        },
        {
          "line": 279,
          "content": "        if progress < 0 or progress > 100:"
        },
        {
          "line": 283,
          "content": "        if progress < self._progress:"
        },
        {
          "line": 294,
          "content": "        return progress"
        },
        {
          "line": 296,
          "content": "    def update_progress(self, progress: int) -> None:"
        },
        {
          "line": 297,
          "content": "        \"\"\""
        },
        {
          "line": 305,
          "content": "        \"\"\""
        },
        {
          "line": 321,
          "content": "    def persist_state(self) -> None:"
        },
        {
          "line": 322,
          "content": "        \"\"\""
        },
        {
          "line": 335,
          "content": "        \"\"\""
        },
        {
          "line": 336,
          "content": "        if self._repository is None:"
        },
        {
          "line": 384,
          "content": "            ) from e"
        },
        {
          "line": 386,
          "content": "    def reset(self) -> None:"
        },
        {
          "line": 387,
          "content": "        \"\"\""
        },
        {
          "line": 391,
          "content": "        \"\"\""
        },
        {
          "line": 408,
          "content": "    def to_dict(self) -> Dict[str, Any]:"
        },
        {
          "line": 409,
          "content": "        \"\"\""
        },
        {
          "line": 414,
          "content": "        \"\"\""
        },
        {
          "line": 415,
          "content": "        return {"
        },
        {
          "line": 426,
          "content": "    def __str__(self) -> str:"
        },
        {
          "line": 427,
          "content": "        \"\"\"字符串表示\"\"\""
        },
        {
          "line": 437,
          "content": "        \"\"\"详细字符串表示\"\"\""
        },
        {
          "line": 438,
          "content": "        return ("
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/state_machine/states.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "\"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\"诊断状态枚举"
        },
        {
          "line": 30,
          "content": "    \"\"\""
        },
        {
          "line": 45,
          "content": "        \"\"\""
        },
        {
          "line": 50,
          "content": "        \"\"\""
        },
        {
          "line": 60,
          "content": "        \"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\""
        },
        {
          "line": 72,
          "content": "        \"\"\""
        },
        {
          "line": 77,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/utils/sanitizer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "    \"\"\""
        },
        {
          "line": 29,
          "content": "    \"\"\""
        },
        {
          "line": 57,
          "content": "        \"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\""
        },
        {
          "line": 88,
          "content": "        \"\"\""
        },
        {
          "line": 98,
          "content": "        \"\"\""
        },
        {
          "line": 119,
          "content": "        \"\"\""
        },
        {
          "line": 127,
          "content": "        \"\"\""
        },
        {
          "line": 146,
          "content": "        \"\"\""
        },
        {
          "line": 155,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/repositories/diagnosis_result_repository.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 27,
          "content": "    \"\"\""
        },
        {
          "line": 41,
          "content": "    \"\"\""
        },
        {
          "line": 50,
          "content": "        \"\"\""
        },
        {
          "line": 55,
          "content": "        \"\"\""
        },
        {
          "line": 75,
          "content": "        \"\"\"获取数据库连接（上下文管理器）\"\"\""
        },
        {
          "line": 95,
          "content": "    def _init_db(self) -> None:"
        },
        {
          "line": 96,
          "content": "        \"\"\"初始化数据库表\"\"\""
        },
        {
          "line": 142,
          "content": "            ''')"
        },
        {
          "line": 177,
          "content": "    def _create_index_if_not_exists("
        },
        {
          "line": 183,
          "content": "        \"\"\"创建索引（如果不存在）\"\"\""
        },
        {
          "line": 190,
          "content": "        \"\"\""
        },
        {
          "line": 201,
          "content": "        \"\"\""
        },
        {
          "line": 216,
          "content": "                ''', ("
        },
        {
          "line": 224,
          "content": "                    json.dumps(result.geo_data, ensure_ascii=False) if result.geo_data else None,"
        },
        {
          "line": 225,
          "content": "                    1 if result.exposure else 0,"
        },
        {
          "line": 252,
          "content": "                return result_id"
        },
        {
          "line": 259,
          "content": "                    'execution_id': result.execution_id if hasattr(result, 'execution_id') else 'unknown',"
        },
        {
          "line": 264,
          "content": "            raise RepositoryError(f\"创建诊断结果失败：{e}\") from e"
        },
        {
          "line": 266,
          "content": "    def create_many(self, results: List[DiagnosisResult]) -> List[int]:"
        },
        {
          "line": 267,
          "content": "        \"\"\""
        },
        {
          "line": 278,
          "content": "        \"\"\""
        },
        {
          "line": 284,
          "content": "                for result in results:"
        },
        {
          "line": 295,
          "content": "                    ''', ("
        },
        {
          "line": 341,
          "content": "        \"\"\""
        },
        {
          "line": 349,
          "content": "        \"\"\""
        },
        {
          "line": 368,
          "content": "        \"\"\""
        },
        {
          "line": 378,
          "content": "        \"\"\""
        },
        {
          "line": 387,
          "content": "                ''', (report_id, limit, offset))"
        },
        {
          "line": 389,
          "content": "                return [DiagnosisResult.from_db_row(dict(row)) for row in cursor.fetchall()]"
        },
        {
          "line": 391,
          "content": "            return []"
        },
        {
          "line": 393,
          "content": "    def get_by_execution_id("
        },
        {
          "line": 399,
          "content": "        \"\"\""
        },
        {
          "line": 409,
          "content": "        \"\"\""
        },
        {
          "line": 418,
          "content": "                ''', (execution_id, limit, offset))"
        },
        {
          "line": 432,
          "content": "        \"\"\""
        },
        {
          "line": 444,
          "content": "        \"\"\""
        },
        {
          "line": 458,
          "content": "                ''', ("
        },
        {
          "line": 460,
          "content": "                    1 if exposure else 0,"
        },
        {
          "line": 469,
          "content": "                if affected:"
        },
        {
          "line": 480,
          "content": "                return affected"
        },
        {
          "line": 482,
          "content": "            return False"
        },
        {
          "line": 484,
          "content": "    def update_quality_score("
        },
        {
          "line": 490,
          "content": "        \"\"\""
        },
        {
          "line": 500,
          "content": "        \"\"\""
        },
        {
          "line": 512,
          "content": "                ''', ("
        },
        {
          "line": 524,
          "content": "        \"\"\""
        },
        {
          "line": 532,
          "content": "        \"\"\""
        },
        {
          "line": 545,
          "content": "        \"\"\""
        },
        {
          "line": 553,
          "content": "        \"\"\""
        },
        {
          "line": 572,
          "content": "                ''', (report_id,))"
        },
        {
          "line": 583,
          "content": "                ''', (report_id,))"
        },
        {
          "line": 598,
          "content": "                ''', (report_id,))"
        },
        {
          "line": 606,
          "content": "                            if row['total_count'] > 0 else 0"
        },
        {
          "line": 609,
          "content": "                    for row in cursor.fetchall()"
        },
        {
          "line": 612,
          "content": "                return {"
        },
        {
          "line": 621,
          "content": "            return {"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/repositories/diagnosis_repository.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        },
        {
          "line": 27,
          "content": "    \"\"\""
        },
        {
          "line": 44,
          "content": "    \"\"\""
        },
        {
          "line": 47,
          "content": "        \"\"\"初始化数据仓库\"\"\""
        },
        {
          "line": 51,
          "content": "    def get_connection(self):"
        },
        {
          "line": 52,
          "content": "        \"\"\""
        },
        {
          "line": 60,
          "content": "        \"\"\""
        },
        {
          "line": 67,
          "content": "            if conn:"
        },
        {
          "line": 81,
          "content": "            ) from e"
        },
        {
          "line": 83,
          "content": "            if conn:"
        },
        {
          "line": 86,
          "content": "    def update_state("
        },
        {
          "line": 96,
          "content": "        \"\"\""
        },
        {
          "line": 122,
          "content": "        \"\"\""
        },
        {
          "line": 137,
          "content": "        if is_completed:"
        },
        {
          "line": 157,
          "content": "                \"\"\""
        },
        {
          "line": 250,
          "content": "        \"\"\""
        },
        {
          "line": 261,
          "content": "        \"\"\""
        },
        {
          "line": 311,
          "content": "        \"\"\""
        },
        {
          "line": 327,
          "content": "        \"\"\""
        },
        {
          "line": 339,
          "content": "                \"\"\""
        },
        {
          "line": 348,
          "content": "                        1 if is_completed else 0,"
        },
        {
          "line": 349,
          "content": "                        1 if should_stop_polling else 0,"
        },
        {
          "line": 366,
          "content": "                return True"
        },
        {
          "line": 378,
          "content": "            return False"
        },
        {
          "line": 389,
          "content": "            return False"
        },
        {
          "line": 391,
          "content": "    def get_state(self, execution_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 392,
          "content": "        \"\"\""
        },
        {
          "line": 403,
          "content": "        \"\"\""
        },
        {
          "line": 415,
          "content": "                \"\"\""
        },
        {
          "line": 459,
          "content": "        \"\"\""
        },
        {
          "line": 474,
          "content": "        \"\"\""
        },
        {
          "line": 511,
          "content": "                \"\"\""
        },
        {
          "line": 545,
          "content": "                return report_id"
        },
        {
          "line": 560,
          "content": "            ) from e"
        },
        {
          "line": 575,
          "content": "            ) from e"
        },
        {
          "line": 577,
          "content": "    def get_by_execution_id(self, execution_id: str) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 578,
          "content": "        \"\"\""
        },
        {
          "line": 586,
          "content": "        \"\"\""
        },
        {
          "line": 594,
          "content": "                \"\"\""
        },
        {
          "line": 627,
          "content": "        \"\"\""
        },
        {
          "line": 635,
          "content": "        \"\"\""
        },
        {
          "line": 646,
          "content": "                ''', (execution_id,))"
        },
        {
          "line": 649,
          "content": "                if row:"
        },
        {
          "line": 652,
          "content": "                    return brand_count * model_count"
        },
        {
          "line": 653,
          "content": "                return 0"
        },
        {
          "line": 656,
          "content": "            return 0"
        },
        {
          "line": 658,
          "content": "    def get_status_summary(self, execution_id: str) -> Dict[str, Any]:"
        },
        {
          "line": 659,
          "content": "        \"\"\""
        },
        {
          "line": 667,
          "content": "        \"\"\""
        },
        {
          "line": 686,
          "content": "                ''', (execution_id,))"
        },
        {
          "line": 698,
          "content": "                ''', (execution_id,))"
        },
        {
          "line": 701,
          "content": "                stats: Dict[str, Any] = dict(stats_row) if stats_row else {'total': 0, 'success_count': 0}"
        },
        {
          "line": 703,
          "content": "                return {"
        },
        {
          "line": 720,
          "content": "            return {"
        },
        {
          "line": 726,
          "content": "    def get_by_user_id("
        },
        {
          "line": 732,
          "content": "        \"\"\""
        },
        {
          "line": 742,
          "content": "        \"\"\""
        },
        {
          "line": 756,
          "content": "                \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/repositories/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/repositories/api_call_log_repository.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 28,
          "content": "    \"\"\""
        },
        {
          "line": 41,
          "content": "    \"\"\""
        },
        {
          "line": 50,
          "content": "        \"\"\""
        },
        {
          "line": 55,
          "content": "        \"\"\""
        },
        {
          "line": 75,
          "content": "        \"\"\""
        },
        {
          "line": 80,
          "content": "        \"\"\""
        },
        {
          "line": 101,
          "content": "        \"\"\"初始化数据库表\"\"\""
        },
        {
          "line": 150,
          "content": "            ''')"
        },
        {
          "line": 191,
          "content": "        \"\"\"创建索引（如果不存在）\"\"\""
        },
        {
          "line": 198,
          "content": "    def create(self, log: APICallLog) -> int:"
        },
        {
          "line": 199,
          "content": "        \"\"\""
        },
        {
          "line": 210,
          "content": "        \"\"\""
        },
        {
          "line": 226,
          "content": "                ''', ("
        },
        {
          "line": 283,
          "content": "        \"\"\""
        },
        {
          "line": 291,
          "content": "        \"\"\""
        },
        {
          "line": 318,
          "content": "        \"\"\""
        },
        {
          "line": 328,
          "content": "        \"\"\""
        },
        {
          "line": 337,
          "content": "                ''', (execution_id, limit, offset))"
        },
        {
          "line": 339,
          "content": "                return [APICallLog.from_db_row(dict(row)) for row in cursor.fetchall()]"
        },
        {
          "line": 349,
          "content": "            return []"
        },
        {
          "line": 351,
          "content": "    def get_by_report_id("
        },
        {
          "line": 357,
          "content": "        \"\"\""
        },
        {
          "line": 367,
          "content": "        \"\"\""
        },
        {
          "line": 376,
          "content": "                ''', (report_id, limit, offset))"
        },
        {
          "line": 390,
          "content": "        \"\"\""
        },
        {
          "line": 402,
          "content": "        \"\"\""
        },
        {
          "line": 410,
          "content": "                '''"
        },
        {
          "line": 413,
          "content": "                if model:"
        },
        {
          "line": 417,
          "content": "                if success_only:"
        },
        {
          "line": 424,
          "content": "                return [APICallLog.from_db_row(dict(row)) for row in cursor.fetchall()]"
        },
        {
          "line": 426,
          "content": "            return []"
        },
        {
          "line": 428,
          "content": "    def get_statistics("
        },
        {
          "line": 434,
          "content": "        \"\"\""
        },
        {
          "line": 444,
          "content": "        \"\"\""
        },
        {
          "line": 453,
          "content": "                if execution_id:"
        },
        {
          "line": 457,
          "content": "                if start_time:"
        },
        {
          "line": 461,
          "content": "                if end_time:"
        },
        {
          "line": 465,
          "content": "                where_sql = \" AND \".join(where_clauses) if where_clauses else \"1=1\""
        },
        {
          "line": 476,
          "content": "                ''', params)"
        },
        {
          "line": 490,
          "content": "                ''', params)"
        },
        {
          "line": 492,
          "content": "                stats['by_model'] = [dict(row) for row in cursor.fetchall()]"
        },
        {
          "line": 504,
          "content": "                ''', params)"
        },
        {
          "line": 528,
          "content": "        \"\"\""
        },
        {
          "line": 536,
          "content": "        \"\"\""
        },
        {
          "line": 543,
          "content": "                ''', (f'-{days} days',))"
        },
        {
          "line": 547,
          "content": "                if deleted > 0:"
        },
        {
          "line": 557,
          "content": "                return deleted"
        },
        {
          "line": 567,
          "content": "            return 0"
        },
        {
          "line": 569,
          "content": "    def _write_to_file_backup(self, log: APICallLog) -> None:"
        },
        {
          "line": 570,
          "content": "        \"\"\""
        },
        {
          "line": 577,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/models/diagnosis_result.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 58,
          "content": "    \"\"\""
        },
        {
          "line": 112,
          "content": "        \"\"\""
        },
        {
          "line": 117,
          "content": "        \"\"\""
        },
        {
          "line": 157,
          "content": "        \"\"\""
        },
        {
          "line": 162,
          "content": "        \"\"\""
        },
        {
          "line": 175,
          "content": "        \"\"\""
        },
        {
          "line": 183,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/models/report_stub.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "\"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\""
        },
        {
          "line": 29,
          "content": "    \"\"\""
        },
        {
          "line": 39,
          "content": "    \"\"\""
        },
        {
          "line": 69,
          "content": "    \"\"\""
        },
        {
          "line": 108,
          "content": "        \"\"\""
        },
        {
          "line": 113,
          "content": "        \"\"\""
        },
        {
          "line": 146,
          "content": "        \"\"\""
        },
        {
          "line": 151,
          "content": "        \"\"\""
        },
        {
          "line": 170,
          "content": "        \"\"\""
        },
        {
          "line": 175,
          "content": "        \"\"\""
        },
        {
          "line": 195,
          "content": "        \"\"\""
        },
        {
          "line": 203,
          "content": "        \"\"\""
        },
        {
          "line": 226,
          "content": "        \"\"\""
        },
        {
          "line": 236,
          "content": "        \"\"\""
        },
        {
          "line": 310,
          "content": "        \"\"\""
        },
        {
          "line": 318,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/models/api_call_log.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 46,
          "content": "    \"\"\""
        },
        {
          "line": 88,
          "content": "        \"\"\""
        },
        {
          "line": 93,
          "content": "        \"\"\""
        },
        {
          "line": 129,
          "content": "        \"\"\""
        },
        {
          "line": 134,
          "content": "        \"\"\""
        },
        {
          "line": 150,
          "content": "        \"\"\""
        },
        {
          "line": 158,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/models/dead_letter.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 39,
          "content": "    \"\"\""
        },
        {
          "line": 70,
          "content": "        \"\"\"初始化后处理\"\"\""
        },
        {
          "line": 71,
          "content": "        if self.failed_at is None:"
        },
        {
          "line": 74,
          "content": "    def to_dict(self) -> Dict[str, Any]:"
        },
        {
          "line": 75,
          "content": "        \"\"\""
        },
        {
          "line": 80,
          "content": "        \"\"\""
        },
        {
          "line": 81,
          "content": "        return {"
        },
        {
          "line": 93,
          "content": "            'failed_at': self.failed_at.isoformat() if self.failed_at else None,"
        },
        {
          "line": 94,
          "content": "            'last_retry_at': self.last_retry_at.isoformat() if self.last_retry_at else None,"
        },
        {
          "line": 95,
          "content": "            'resolved_at': self.resolved_at.isoformat() if self.resolved_at else None,"
        },
        {
          "line": 101,
          "content": "    def from_db_row(cls, row: Dict[str, Any]) -> 'DeadLetter':"
        },
        {
          "line": 102,
          "content": "        \"\"\""
        },
        {
          "line": 110,
          "content": "        \"\"\""
        },
        {
          "line": 111,
          "content": "        return cls("
        },
        {
          "line": 120,
          "content": "            task_context=json.loads(row['task_context']) if row['task_context'] else {},"
        },
        {
          "line": 123,
          "content": "            failed_at=datetime.fromisoformat(row['failed_at']) if row['failed_at'] else None,"
        },
        {
          "line": 124,
          "content": "            last_retry_at=datetime.fromisoformat(row['last_retry_at']) if row['last_retry_at'] else None,"
        },
        {
          "line": 125,
          "content": "            resolved_at=datetime.fromisoformat(row['resolved_at']) if row['resolved_at'] else None,"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/adapters/models.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "This module defines the standardized request/response models for AI platform interactions."
        },
        {
          "line": 5,
          "content": "All AI adapters must use these models for consistent data exchange."
        },
        {
          "line": 6,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\"AI Provider enumeration\"\"\""
        },
        {
          "line": 19,
          "content": "    # Extensible for future providers"
        },
        {
          "line": 23,
          "content": "class AIRequest:"
        },
        {
          "line": 24,
          "content": "    \"\"\""
        },
        {
          "line": 29,
          "content": "    \"\"\""
        },
        {
          "line": 42,
          "content": "    request_id: Optional[str] = None             # Request ID for tracking"
        },
        {
          "line": 45,
          "content": "    # Context for conversation scenarios"
        },
        {
          "line": 48,
          "content": "    def to_dict(self) -> Dict[str, Any]:"
        },
        {
          "line": 49,
          "content": "        \"\"\"Convert to dictionary (for logging)\"\"\""
        },
        {
          "line": 61,
          "content": "    \"\"\""
        },
        {
          "line": 65,
          "content": "    \"\"\""
        },
        {
          "line": 81,
          "content": "    # Raw response (preserved for debugging and auditing)"
        },
        {
          "line": 94,
          "content": "        \"\"\"Convert to dictionary (for logging)\"\"\""
        },
        {
          "line": 95,
          "content": "        return {"
        },
        {
          "line": 105,
          "content": "            'content_preview': self.content[:100] + '...' if self.content and len(self.content) > 100 else self.content,"
        },
        {
          "line": 109,
          "content": "    def is_success(self) -> bool:"
        },
        {
          "line": 110,
          "content": "        \"\"\"Whether the request was successful\"\"\""
        },
        {
          "line": 115,
          "content": "        \"\"\"Length of response text\"\"\""
        },
        {
          "line": 116,
          "content": "        return len(self.content) if self.content else 0"
        },
        {
          "line": 120,
          "content": "class AIStreamChunk:"
        },
        {
          "line": 121,
          "content": "    \"\"\""
        },
        {
          "line": 125,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/adapters/qwen_adapter.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Adapter for Qwen AI platform (Alibaba Cloud)."
        },
        {
          "line": 11,
          "content": "\"\"\""
        },
        {
          "line": 30,
          "content": "    \"\"\""
        },
        {
          "line": 38,
          "content": "    3. API key management from environment"
        },
        {
          "line": 39,
          "content": "    4. Special handling for Qwen's different token field names"
        },
        {
          "line": 44,
          "content": "        >>> response = await adapter.send(request)"
        },
        {
          "line": 46,
          "content": "    \"\"\""
        },
        {
          "line": 49,
          "content": "        \"\"\""
        },
        {
          "line": 54,
          "content": "        \"\"\""
        },
        {
          "line": 58,
          "content": "        \"\"\""
        },
        {
          "line": 59,
          "content": "        Get Qwen API key from environment variable"
        },
        {
          "line": 66,
          "content": "        \"\"\""
        },
        {
          "line": 73,
          "content": "        \"\"\""
        },
        {
          "line": 78,
          "content": "        \"\"\""
        },
        {
          "line": 82,
          "content": "        \"\"\""
        },
        {
          "line": 87,
          "content": "        \"\"\""
        },
        {
          "line": 95,
          "content": "        \"\"\""
        },
        {
          "line": 119,
          "content": "        \"\"\""
        },
        {
          "line": 142,
          "content": "        \"\"\""
        },
        {
          "line": 166,
          "content": "            response_data: Raw response from Qwen"
        },
        {
          "line": 174,
          "content": "        \"\"\""
        },
        {
          "line": 214,
          "content": "        \"\"\""
        },
        {
          "line": 225,
          "content": "            response_data: Error response from Qwen"
        },
        {
          "line": 230,
          "content": "        \"\"\""
        },
        {
          "line": 248,
          "content": "        \"\"\""
        },
        {
          "line": 249,
          "content": "        Parse GEO (Geographic/Emotional) data from Qwen response"
        },
        {
          "line": 251,
          "content": "        Expects the AI to return structured JSON data with brand analysis."
        },
        {
          "line": 255,
          "content": "            response: Standardized response from Qwen"
        },
        {
          "line": 267,
          "content": "        \"\"\""
        },
        {
          "line": 283,
          "content": "            # Try to parse JSON from response content"
        },
        {
          "line": 286,
          "content": "            # Remove markdown code blocks if present"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/adapters/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "    from wechat_backend.v2.adapters import get_adapter, AIRequest"
        },
        {
          "line": 11,
          "content": "    from wechat_backend.v2.adapters.factory import get_supported_providers"
        },
        {
          "line": 15,
          "content": "    response = await adapter.send(request)"
        },
        {
          "line": 16,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/adapters/factory.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "This module provides the factory for creating AI adapter instances."
        },
        {
          "line": 5,
          "content": "It supports dynamic loading and singleton pattern for efficiency."
        },
        {
          "line": 10,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 26,
          "content": "    Responsible for creating adapter instances based on provider names."
        },
        {
          "line": 31,
          "content": "    2. Singleton pattern for adapter instances"
        },
        {
          "line": 32,
          "content": "    3. Dynamic loading from modules"
        },
        {
          "line": 33,
          "content": "    4. Support for custom adapters"
        },
        {
          "line": 44,
          "content": "    \"\"\""
        },
        {
          "line": 52,
          "content": "        \"\"\"Initialize default adapters (deepseek, doubao, qwen)\"\"\""
        },
        {
          "line": 53,
          "content": "        if cls._initialized:"
        },
        {
          "line": 56,
          "content": "        # Pre-register known adapters for dynamic loading"
        },
        {
          "line": 57,
          "content": "        for provider in ['deepseek', 'doubao', 'qwen']:"
        },
        {
          "line": 63,
          "content": "    def register(cls, provider: str, adapter_class: Type[BaseAIAdapter]):"
        },
        {
          "line": 64,
          "content": "        \"\"\""
        },
        {
          "line": 73,
          "content": "        \"\"\""
        },
        {
          "line": 78,
          "content": "        if provider_key in cls._instances:"
        },
        {
          "line": 91,
          "content": "    def get_adapter(cls, provider: str) -> BaseAIAdapter:"
        },
        {
          "line": 92,
          "content": "        \"\"\""
        },
        {
          "line": 106,
          "content": "        \"\"\""
        },
        {
          "line": 113,
          "content": "        if provider_key in cls._instances:"
        },
        {
          "line": 114,
          "content": "            return cls._instances[provider_key]"
        },
        {
          "line": 118,
          "content": "        if not adapter_class:"
        },
        {
          "line": 123,
          "content": "        if not adapter_class:"
        },
        {
          "line": 142,
          "content": "        return instance"
        },
        {
          "line": 145,
          "content": "    def _try_import_adapter(cls, provider: str):"
        },
        {
          "line": 146,
          "content": "        \"\"\""
        },
        {
          "line": 153,
          "content": "        \"\"\""
        },
        {
          "line": 158,
          "content": "            # Look for adapter class (typically named {Provider}Adapter)"
        },
        {
          "line": 160,
          "content": "            if hasattr(module, class_name):"
        },
        {
          "line": 181,
          "content": "            pass  # Ignore import errors, will throw exception later"
        },
        {
          "line": 184,
          "content": "    def get_supported_providers(cls) -> list[str]:"
        },
        {
          "line": 185,
          "content": "        \"\"\""
        },
        {
          "line": 195,
          "content": "        \"\"\""
        },
        {
          "line": 199,
          "content": "        return list(cls._adapters.keys())"
        },
        {
          "line": 202,
          "content": "    def clear_cache(cls):"
        },
        {
          "line": 203,
          "content": "        \"\"\""
        },
        {
          "line": 207,
          "content": "        \"\"\""
        },
        {
          "line": 218,
          "content": "    def is_supported(cls, provider: str) -> bool:"
        },
        {
          "line": 219,
          "content": "        \"\"\""
        },
        {
          "line": 231,
          "content": "        \"\"\""
        },
        {
          "line": 232,
          "content": "        return provider.lower() in cls.get_supported_providers()"
        },
        {
          "line": 236,
          "content": "def get_adapter(provider: str) -> BaseAIAdapter:"
        },
        {
          "line": 237,
          "content": "    \"\"\""
        },
        {
          "line": 245,
          "content": "    \"\"\""
        },
        {
          "line": 246,
          "content": "    return AIAdapterFactory.get_adapter(provider)"
        },
        {
          "line": 249,
          "content": "def get_supported_providers() -> list[str]:"
        },
        {
          "line": 250,
          "content": "    \"\"\""
        },
        {
          "line": 255,
          "content": "    \"\"\""
        },
        {
          "line": 256,
          "content": "    return AIAdapterFactory.get_supported_providers()"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/adapters/doubao_adapter.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Adapter for Doubao AI platform (ByteDance)."
        },
        {
          "line": 11,
          "content": "\"\"\""
        },
        {
          "line": 33,
          "content": "    \"\"\""
        },
        {
          "line": 42,
          "content": "    3. API key management from environment"
        },
        {
          "line": 47,
          "content": "        >>> response = await adapter.send(request)"
        },
        {
          "line": 49,
          "content": "    \"\"\""
        },
        {
          "line": 52,
          "content": "        \"\"\""
        },
        {
          "line": 57,
          "content": "        \"\"\""
        },
        {
          "line": 61,
          "content": "        \"\"\""
        },
        {
          "line": 62,
          "content": "        Get Doubao API key from environment variable"
        },
        {
          "line": 69,
          "content": "        \"\"\""
        },
        {
          "line": 76,
          "content": "        \"\"\""
        },
        {
          "line": 81,
          "content": "        \"\"\""
        },
        {
          "line": 85,
          "content": "        \"\"\""
        },
        {
          "line": 90,
          "content": "        \"\"\""
        },
        {
          "line": 97,
          "content": "        \"\"\""
        },
        {
          "line": 118,
          "content": "        \"\"\""
        },
        {
          "line": 137,
          "content": "        \"\"\""
        },
        {
          "line": 164,
          "content": "            response_data: Raw response from Doubao"
        },
        {
          "line": 172,
          "content": "        \"\"\""
        },
        {
          "line": 205,
          "content": "        \"\"\""
        },
        {
          "line": 209,
          "content": "            response_data: Error response from Doubao"
        },
        {
          "line": 214,
          "content": "        \"\"\""
        },
        {
          "line": 232,
          "content": "        \"\"\""
        },
        {
          "line": 233,
          "content": "        Parse GEO (Geographic/Emotional) data from Doubao response"
        },
        {
          "line": 235,
          "content": "        Expects the AI to return structured JSON data with brand analysis."
        },
        {
          "line": 239,
          "content": "            response: Standardized response from Doubao"
        },
        {
          "line": 251,
          "content": "        \"\"\""
        },
        {
          "line": 267,
          "content": "            # Try to parse JSON from response content"
        },
        {
          "line": 270,
          "content": "            # Remove markdown code blocks if present"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/adapters/errors.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "This module defines the exception hierarchy for AI adapter error handling."
        },
        {
          "line": 6,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "    \"\"\"Base exception for AI adapter errors\"\"\""
        },
        {
          "line": 14,
          "content": "    def __init__(self, message: str, provider: str, original_error: Optional[Exception] = None):"
        },
        {
          "line": 21,
          "content": "class AIAuthenticationError(AIAdapterError):"
        },
        {
          "line": 22,
          "content": "    \"\"\"Authentication error (invalid API Key)\"\"\""
        },
        {
          "line": 27,
          "content": "    \"\"\"Rate limit error\"\"\""
        },
        {
          "line": 31,
          "content": "class AIQuotaExceededError(AIAdapterError):"
        },
        {
          "line": 32,
          "content": "    \"\"\"Quota exceeded error\"\"\""
        },
        {
          "line": 37,
          "content": "    \"\"\"Timeout error\"\"\""
        },
        {
          "line": 41,
          "content": "class AIConnectionError(AIAdapterError):"
        },
        {
          "line": 42,
          "content": "    \"\"\"Connection error\"\"\""
        },
        {
          "line": 47,
          "content": "    \"\"\"Response format error\"\"\""
        },
        {
          "line": 51,
          "content": "class AIModelNotFoundError(AIAdapterError):"
        },
        {
          "line": 52,
          "content": "    \"\"\"Model not found error\"\"\""
        },
        {
          "line": 57,
          "content": "    \"\"\"Content filtered error\"\"\""
        },
        {
          "line": 61,
          "content": "# Error code mapping (for converting platform-specific errors to internal errors)"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/adapters/deepseek_adapter.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Adapter for DeepSeek AI platform."
        },
        {
          "line": 11,
          "content": "\"\"\""
        },
        {
          "line": 33,
          "content": "    \"\"\""
        },
        {
          "line": 41,
          "content": "    3. API key management from environment"
        },
        {
          "line": 46,
          "content": "        >>> response = await adapter.send(request)"
        },
        {
          "line": 48,
          "content": "    \"\"\""
        },
        {
          "line": 51,
          "content": "        \"\"\""
        },
        {
          "line": 56,
          "content": "        \"\"\""
        },
        {
          "line": 60,
          "content": "        \"\"\""
        },
        {
          "line": 61,
          "content": "        Get DeepSeek API key from environment variable"
        },
        {
          "line": 68,
          "content": "        \"\"\""
        },
        {
          "line": 75,
          "content": "        \"\"\""
        },
        {
          "line": 80,
          "content": "        \"\"\""
        },
        {
          "line": 84,
          "content": "        \"\"\""
        },
        {
          "line": 89,
          "content": "        \"\"\""
        },
        {
          "line": 97,
          "content": "        \"\"\""
        },
        {
          "line": 119,
          "content": "        \"\"\""
        },
        {
          "line": 139,
          "content": "        \"\"\""
        },
        {
          "line": 166,
          "content": "            response_data: Raw response from DeepSeek"
        },
        {
          "line": 174,
          "content": "        \"\"\""
        },
        {
          "line": 212,
          "content": "        \"\"\""
        },
        {
          "line": 226,
          "content": "            response_data: Error response from DeepSeek"
        },
        {
          "line": 231,
          "content": "        \"\"\""
        },
        {
          "line": 253,
          "content": "        \"\"\""
        },
        {
          "line": 254,
          "content": "        Parse GEO (Geographic/Emotional) data from DeepSeek response"
        },
        {
          "line": 256,
          "content": "        Expects the AI to return structured JSON data with brand analysis."
        },
        {
          "line": 260,
          "content": "            response: Standardized response from DeepSeek"
        },
        {
          "line": 272,
          "content": "        \"\"\""
        },
        {
          "line": 288,
          "content": "            # Try to parse JSON from response content"
        },
        {
          "line": 289,
          "content": "            # AI may return markdown code blocks, so we extract JSON"
        },
        {
          "line": 292,
          "content": "            # Remove markdown code blocks if present"
        },
        {
          "line": 315,
          "content": "            # Return content as-is in raw_data for manual processing"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/adapters/base.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "This module defines the abstract base class for all AI platform adapters."
        },
        {
          "line": 5,
          "content": "All concrete adapters must inherit from this class and implement abstract methods."
        },
        {
          "line": 10,
          "content": "\"\"\""
        },
        {
          "line": 40,
          "content": "    \"\"\""
        },
        {
          "line": 43,
          "content": "    All platform-specific adapters must inherit from this class and implement"
        },
        {
          "line": 44,
          "content": "    the abstract methods. This class provides common retry, logging, and error"
        },
        {
          "line": 48,
          "content": "    1. Define standard interface for all AI adapters"
        },
        {
          "line": 52,
          "content": "    5. Manage API key retrieval from environment"
        },
        {
          "line": 55,
          "content": "        >>> class DeepSeekAdapter(BaseAIAdapter):"
        },
        {
          "line": 56,
          "content": "        ...     def _get_api_key(self) -> str:"
        },
        {
          "line": 57,
          "content": "        ...         return os.getenv('DEEPSEEK_API_KEY')"
        },
        {
          "line": 59,
          "content": "        ...     def _build_request_payload(self, request: AIRequest) -> Dict[str, Any]:"
        },
        {
          "line": 60,
          "content": "        ...         return {'model': 'deepseek-chat', 'messages': [...]}"
        },
        {
          "line": 62,
          "content": "        ...     def _parse_response(self, response_data: Dict[str, Any], request: AIRequest) -> AIResponse:"
        },
        {
          "line": 63,
          "content": "        ...         return AIResponse(content=..., model=..., ...)"
        },
        {
          "line": 64,
          "content": "    \"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\""
        },
        {
          "line": 72,
          "content": "        \"\"\""
        },
        {
          "line": 90,
          "content": "        # Get API key from environment variable"
        },
        {
          "line": 104,
          "content": "        \"\"\""
        },
        {
          "line": 105,
          "content": "        Get API key from environment variable"
        },
        {
          "line": 115,
          "content": "        \"\"\""
        },
        {
          "line": 120,
          "content": "        \"\"\""
        },
        {
          "line": 131,
          "content": "        \"\"\""
        },
        {
          "line": 136,
          "content": "        \"\"\""
        },
        {
          "line": 143,
          "content": "            response_data: Raw response from platform"
        },
        {
          "line": 144,
          "content": "            request: Original request (for logging)"
        },
        {
          "line": 151,
          "content": "        \"\"\""
        },
        {
          "line": 156,
          "content": "        \"\"\""
        },
        {
          "line": 163,
          "content": "            response_data: Error response from platform"
        },
        {
          "line": 168,
          "content": "        \"\"\""
        },
        {
          "line": 173,
          "content": "        \"\"\""
        },
        {
          "line": 178,
          "content": "        \"\"\""
        },
        {
          "line": 183,
          "content": "        \"\"\""
        },
        {
          "line": 188,
          "content": "        \"\"\""
        },
        {
          "line": 193,
          "content": "        \"\"\""
        },
        {
          "line": 194,
          "content": "        Parse GEO (Geographic/Emotional) data from response"
        },
        {
          "line": 197,
          "content": "        structured data from the AI response content."
        },
        {
          "line": 215,
          "content": "            the expected response format from their prompts."
        },
        {
          "line": 216,
          "content": "        \"\"\""
        },
        {
          "line": 220,
          "content": "        \"\"\""
        },
        {
          "line": 234,
          "content": "        \"\"\""
        },
        {
          "line": 330,
          "content": "        \"\"\""
        },
        {
          "line": 341,
          "content": "        \"\"\""
        },
        {
          "line": 389,
          "content": "        \"\"\""
        },
        {
          "line": 402,
          "content": "        \"\"\""
        },
        {
          "line": 406,
          "content": "        \"\"\""
        },
        {
          "line": 417,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/api/dead_letter_api.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 30,
          "content": "    \"\"\""
        },
        {
          "line": 50,
          "content": "    \"\"\""
        },
        {
          "line": 117,
          "content": "    \"\"\""
        },
        {
          "line": 125,
          "content": "    \"\"\""
        },
        {
          "line": 136,
          "content": "    \"\"\""
        },
        {
          "line": 148,
          "content": "    \"\"\""
        },
        {
          "line": 179,
          "content": "    \"\"\""
        },
        {
          "line": 191,
          "content": "    \"\"\""
        },
        {
          "line": 222,
          "content": "    \"\"\""
        },
        {
          "line": 235,
          "content": "    \"\"\""
        },
        {
          "line": 261,
          "content": "    \"\"\""
        },
        {
          "line": 281,
          "content": "    \"\"\""
        },
        {
          "line": 298,
          "content": "    \"\"\""
        },
        {
          "line": 309,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/api/report_api.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "\"\"\""
        },
        {
          "line": 31,
          "content": "    \"\"\""
        },
        {
          "line": 48,
          "content": "    \"\"\""
        },
        {
          "line": 152,
          "content": "    \"\"\""
        },
        {
          "line": 165,
          "content": "    \"\"\""
        },
        {
          "line": 223,
          "content": "    \"\"\""
        },
        {
          "line": 240,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/monitoring/alert_config.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "    from wechat_backend.v2.monitoring.alert_config import ALERT_RULES, check_v2_metrics"
        },
        {
          "line": 15,
          "content": "\"\"\""
        },
        {
          "line": 26,
          "content": "    \"\"\"告警级别\"\"\""
        },
        {
          "line": 34,
          "content": "class AlertRule:"
        },
        {
          "line": 35,
          "content": "    \"\"\"告警规则定义\"\"\""
        },
        {
          "line": 153,
          "content": "    \"\"\"监控指标数据点\"\"\""
        },
        {
          "line": 161,
          "content": "class AlertEvent:"
        },
        {
          "line": 162,
          "content": "    \"\"\"告警事件\"\"\""
        },
        {
          "line": 187,
          "content": "    \"\"\"v2 告警管理器\"\"\""
        },
        {
          "line": 189,
          "content": "    def __init__(self):"
        },
        {
          "line": 194,
          "content": "    def _load_alert_history(self) -> List[AlertEvent]:"
        },
        {
          "line": 195,
          "content": "        \"\"\"加载告警历史\"\"\""
        },
        {
          "line": 222,
          "content": "        \"\"\"保存告警历史\"\"\""
        },
        {
          "line": 225,
          "content": "            for alert in self.alert_history[-1000:]:"
        },
        {
          "line": 236,
          "content": "                    'acknowledged_at': alert.acknowledged_at.isoformat() if alert.acknowledged_at else None,"
        },
        {
          "line": 238,
          "content": "                    'resolved_at': alert.resolved_at.isoformat() if alert.resolved_at else None,"
        },
        {
          "line": 247,
          "content": "    def _load_metrics(self) -> List[MetricDataPoint]:"
        },
        {
          "line": 248,
          "content": "        \"\"\"加载监控指标\"\"\""
        },
        {
          "line": 267,
          "content": "        \"\"\"保存监控指标\"\"\""
        },
        {
          "line": 270,
          "content": "            for metric in self.metrics[-10000:]:"
        },
        {
          "line": 284,
          "content": "    def record_metric(self, metric_name: str, value: float, tags: Dict[str, str] = None):"
        },
        {
          "line": 285,
          "content": "        \"\"\""
        },
        {
          "line": 292,
          "content": "        \"\"\""
        },
        {
          "line": 302,
          "content": "        if len(self.metrics) % 100 == 0:"
        },
        {
          "line": 308,
          "content": "    def _check_alerts(self, metric_name: str, value: float, timestamp: datetime):"
        },
        {
          "line": 309,
          "content": "        \"\"\"检查是否触发告警\"\"\""
        },
        {
          "line": 338,
          "content": "        \"\"\"计算最近时间窗口内的违规次数\"\"\""
        },
        {
          "line": 343,
          "content": "        for alert in reversed(self.alert_history):"
        },
        {
          "line": 344,
          "content": "            if alert.alert_time < cutoff:"
        },
        {
          "line": 346,
          "content": "            if alert.rule_name == rule_name:"
        },
        {
          "line": 349,
          "content": "        return count"
        },
        {
          "line": 351,
          "content": "    def _parse_window(self, window: str) -> int:"
        },
        {
          "line": 352,
          "content": "        \"\"\"解析时间窗口字符串为秒数\"\"\""
        },
        {
          "line": 365,
          "content": "        \"\"\"触发告警\"\"\""
        },
        {
          "line": 367,
          "content": "        if rule.name in self.active_alerts:"
        },
        {
          "line": 389,
          "content": "    def _send_notification(self, alert: AlertEvent, rule: AlertRule):"
        },
        {
          "line": 390,
          "content": "        \"\"\"发送告警通知\"\"\""
        },
        {
          "line": 405,
          "content": "        \"\"\"确认告警\"\"\""
        },
        {
          "line": 406,
          "content": "        if alert_name in self.active_alerts:"
        },
        {
          "line": 415,
          "content": "    def resolve_alert(self, alert_name: str):"
        },
        {
          "line": 416,
          "content": "        \"\"\"解决告警\"\"\""
        },
        {
          "line": 426,
          "content": "        \"\"\"获取活跃告警\"\"\""
        },
        {
          "line": 427,
          "content": "        return list(self.active_alerts.values())"
        },
        {
          "line": 429,
          "content": "    def get_alert_summary(self, hours: int = 24) -> Dict[str, Any]:"
        },
        {
          "line": 430,
          "content": "        \"\"\"获取告警统计\"\"\""
        },
        {
          "line": 452,
          "content": "        \"\"\"获取指标统计\"\"\""
        },
        {
          "line": 457,
          "content": "            m.value for m in self.metrics"
        },
        {
          "line": 458,
          "content": "            if m.metric_name == metric_name and m.timestamp > cutoff"
        },
        {
          "line": 461,
          "content": "        if not recent_values:"
        },
        {
          "line": 462,
          "content": "            return {'count': 0, 'avg': 0, 'min': 0, 'max': 0, 'latest': 0}"
        },
        {
          "line": 464,
          "content": "        return {"
        },
        {
          "line": 478,
          "content": "def get_v2_alert_manager() -> V2AlertManager:"
        },
        {
          "line": 479,
          "content": "    \"\"\"获取 v2 告警管理器实例\"\"\""
        },
        {
          "line": 494,
          "content": "    \"\"\""
        },
        {
          "line": 502,
          "content": "    \"\"\""
        },
        {
          "line": 519,
          "content": "    \"\"\""
        },
        {
          "line": 524,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/monitoring/monitoring_frequency.py",
      "lines": [
        {
          "line": 2,
          "content": "\"\"\""
        },
        {
          "line": 11,
          "content": "    from wechat_backend.v2.monitoring.monitoring_frequency import get_monitoring_config"
        },
        {
          "line": 15,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\"监控模式\"\"\""
        },
        {
          "line": 30,
          "content": "class MonitoringConfig:"
        },
        {
          "line": 31,
          "content": "    \"\"\"监控配置\"\"\""
        },
        {
          "line": 66,
          "content": "    \"\"\""
        },
        {
          "line": 74,
          "content": "    \"\"\""
        },
        {
          "line": 87,
          "content": "    \"\"\""
        },
        {
          "line": 97,
          "content": "    \"\"\""
        },
        {
          "line": 128,
          "content": "    \"\"\""
        },
        {
          "line": 136,
          "content": "    \"\"\""
        },
        {
          "line": 160,
          "content": "    \"\"\""
        },
        {
          "line": 165,
          "content": "    \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/config.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Centralized configuration for the cleaning pipeline."
        },
        {
          "line": 5,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Data cleaning pipeline for AI responses."
        },
        {
          "line": 5,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/pipeline.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Responsible for orchestrating and executing multiple cleaning steps."
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 26,
          "content": "    Responsible for orchestrating and executing multiple cleaning steps,"
        },
        {
          "line": 33,
          "content": "    \"\"\""
        },
        {
          "line": 36,
          "content": "        \"\"\""
        },
        {
          "line": 42,
          "content": "        \"\"\""
        },
        {
          "line": 54,
          "content": "        \"\"\"Add cleaning step\"\"\""
        },
        {
          "line": 56,
          "content": "        return self"
        },
        {
          "line": 58,
          "content": "    def add_steps(self, steps: List[CleaningStep]) -> 'CleaningPipeline':"
        },
        {
          "line": 59,
          "content": "        \"\"\"Batch add cleaning steps\"\"\""
        },
        {
          "line": 64,
          "content": "        \"\"\"Insert step at specified position\"\"\""
        },
        {
          "line": 66,
          "content": "        return self"
        },
        {
          "line": 68,
          "content": "    def remove_step(self, step_name: str) -> bool:"
        },
        {
          "line": 69,
          "content": "        \"\"\"Remove step by name\"\"\""
        },
        {
          "line": 86,
          "content": "        \"\"\""
        },
        {
          "line": 104,
          "content": "        \"\"\""
        },
        {
          "line": 142,
          "content": "                # Check if should skip"
        },
        {
          "line": 230,
          "content": "        \"\"\""
        },
        {
          "line": 238,
          "content": "        \"\"\""
        },
        {
          "line": 254,
          "content": "        \"\"\"Build cleaned data from context\"\"\""
        },
        {
          "line": 256,
          "content": "        # Get results from each step"
        },
        {
          "line": 264,
          "content": "        for e in entity_result.get('entities', []):"
        },
        {
          "line": 298,
          "content": "        # Get original text from text extractor result"
        },
        {
          "line": 302,
          "content": "        return CleanedData("
        },
        {
          "line": 319,
          "content": "    def get_step_names(self) -> List[str]:"
        },
        {
          "line": 320,
          "content": "        \"\"\"Get all step names\"\"\""
        },
        {
          "line": 324,
          "content": "        \"\"\"Get step by name\"\"\""
        },
        {
          "line": 325,
          "content": "        for step in self.steps:"
        },
        {
          "line": 326,
          "content": "            if step.name == name:"
        },
        {
          "line": 327,
          "content": "                return step"
        },
        {
          "line": 328,
          "content": "        return None"
        },
        {
          "line": 332,
          "content": "def create_default_pipeline(competitors: List[str] = None) -> CleaningPipeline:"
        },
        {
          "line": 333,
          "content": "    \"\"\"Create default cleaning pipeline\"\"\""
        },
        {
          "line": 361,
          "content": "    \"\"\"Create minimal cleaning pipeline (only essential cleaning)\"\"\""
        },
        {
          "line": 362,
          "content": "    from wechat_backend.v2.cleaning.steps.text_extractor import TextExtractorStep"
        },
        {
          "line": 363,
          "content": "    from wechat_backend.v2.cleaning.steps.validator import ValidatorStep"
        },
        {
          "line": 371,
          "content": "    return pipeline"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/errors.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Custom exception classes for the cleaning pipeline."
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "    \"\"\"Base exception for cleaning pipeline errors\"\"\""
        },
        {
          "line": 11,
          "content": "    def __init__(self, message: str, execution_id: str, step: str = None):"
        },
        {
          "line": 18,
          "content": "class TextExtractionError(CleaningError):"
        },
        {
          "line": 19,
          "content": "    \"\"\"Exception raised when text extraction fails\"\"\""
        },
        {
          "line": 24,
          "content": "    \"\"\"Exception raised when entity recognition fails\"\"\""
        },
        {
          "line": 28,
          "content": "class ValidationError(CleaningError):"
        },
        {
          "line": 29,
          "content": "    \"\"\"Exception raised when validation fails\"\"\""
        },
        {
          "line": 34,
          "content": "    \"\"\"Exception raised when quality scoring fails\"\"\""
        },
        {
          "line": 38,
          "content": "class PipelineConfigurationError(CleaningError):"
        },
        {
          "line": 39,
          "content": "    \"\"\"Exception raised when pipeline configuration is invalid\"\"\""
        },
        {
          "line": 44,
          "content": "    \"\"\"Exception raised when a cleaning step execution fails\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/services/api_call_logger.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 31,
          "content": "    \"\"\""
        },
        {
          "line": 56,
          "content": "        >>> async def call_ai_api(prompt: str) -> Dict:"
        },
        {
          "line": 58,
          "content": "    \"\"\""
        },
        {
          "line": 61,
          "content": "        \"\"\""
        },
        {
          "line": 66,
          "content": "        \"\"\""
        },
        {
          "line": 92,
          "content": "        \"\"\""
        },
        {
          "line": 112,
          "content": "        \"\"\""
        },
        {
          "line": 175,
          "content": "        \"\"\""
        },
        {
          "line": 193,
          "content": "        \"\"\""
        },
        {
          "line": 248,
          "content": "        \"\"\""
        },
        {
          "line": 253,
          "content": "            async def call_ai_api():"
        },
        {
          "line": 268,
          "content": "        \"\"\""
        },
        {
          "line": 305,
          "content": "        \"\"\"记录异步 API 调用\"\"\""
        },
        {
          "line": 316,
          "content": "            result = await func(*args, **kwargs)"
        },
        {
          "line": 323,
          "content": "            response_data = result.get('data') if isinstance(result, dict) else result"
        },
        {
          "line": 324,
          "content": "            status_code = result.get('status_code', 200) if isinstance(result, dict) else 200"
        },
        {
          "line": 325,
          "content": "            request_id = result.get('request_id') if isinstance(result, dict) else None"
        },
        {
          "line": 326,
          "content": "            api_version = result.get('api_version') if isinstance(result, dict) else None"
        },
        {
          "line": 327,
          "content": "            response_headers = result.get('headers') if isinstance(result, dict) else None"
        },
        {
          "line": 345,
          "content": "            return result"
        },
        {
          "line": 369,
          "content": "    def _record_call_sync("
        },
        {
          "line": 383,
          "content": "        \"\"\"记录同步 API 调用\"\"\""
        },
        {
          "line": 445,
          "content": "        \"\"\""
        },
        {
          "line": 455,
          "content": "        \"\"\""
        },
        {
          "line": 462,
          "content": "        \"\"\""
        },
        {
          "line": 470,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/services/websocket_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        },
        {
          "line": 24,
          "content": "    \"\"\""
        },
        {
          "line": 28,
          "content": "    \"\"\""
        },
        {
          "line": 31,
          "content": "        \"\"\"初始化 WebSocket 服务\"\"\""
        },
        {
          "line": 38,
          "content": "    async def register("
        },
        {
          "line": 43,
          "content": "        \"\"\""
        },
        {
          "line": 49,
          "content": "        \"\"\""
        },
        {
          "line": 50,
          "content": "        if execution_id not in self.clients:"
        },
        {
          "line": 63,
          "content": "    async def unregister("
        },
        {
          "line": 68,
          "content": "        \"\"\""
        },
        {
          "line": 74,
          "content": "        \"\"\""
        },
        {
          "line": 75,
          "content": "        if execution_id in self.clients:"
        },
        {
          "line": 79,
          "content": "            if not self.clients[execution_id]:"
        },
        {
          "line": 91,
          "content": "    async def broadcast("
        },
        {
          "line": 96,
          "content": "        \"\"\""
        },
        {
          "line": 102,
          "content": "        \"\"\""
        },
        {
          "line": 103,
          "content": "        if execution_id not in self.clients:"
        },
        {
          "line": 117,
          "content": "        await asyncio.gather("
        },
        {
          "line": 119,
          "content": "              for client in self.clients[execution_id]],"
        },
        {
          "line": 123,
          "content": "    async def _send_to_client("
        },
        {
          "line": 128,
          "content": "        \"\"\""
        },
        {
          "line": 134,
          "content": "        \"\"\""
        },
        {
          "line": 136,
          "content": "            await client.send(message)"
        },
        {
          "line": 147,
          "content": "    async def send_progress("
        },
        {
          "line": 155,
          "content": "        \"\"\""
        },
        {
          "line": 164,
          "content": "        \"\"\""
        },
        {
          "line": 165,
          "content": "        await self.broadcast(execution_id, {"
        },
        {
          "line": 175,
          "content": "    async def send_result("
        },
        {
          "line": 180,
          "content": "        \"\"\""
        },
        {
          "line": 186,
          "content": "        \"\"\""
        },
        {
          "line": 187,
          "content": "        await self.broadcast(execution_id, {"
        },
        {
          "line": 192,
          "content": "    async def send_complete("
        },
        {
          "line": 197,
          "content": "        \"\"\""
        },
        {
          "line": 203,
          "content": "        \"\"\""
        },
        {
          "line": 204,
          "content": "        await self.broadcast(execution_id, {"
        },
        {
          "line": 209,
          "content": "    async def send_error("
        },
        {
          "line": 216,
          "content": "        \"\"\""
        },
        {
          "line": 224,
          "content": "        \"\"\""
        },
        {
          "line": 225,
          "content": "        await self.broadcast(execution_id, {"
        },
        {
          "line": 234,
          "content": "    def get_active_connection_count(self) -> int:"
        },
        {
          "line": 235,
          "content": "        \"\"\""
        },
        {
          "line": 240,
          "content": "        \"\"\""
        },
        {
          "line": 241,
          "content": "        return self.connection_count"
        },
        {
          "line": 243,
          "content": "    def get_execution_subscribers(self, execution_id: str) -> int:"
        },
        {
          "line": 244,
          "content": "        \"\"\""
        },
        {
          "line": 252,
          "content": "        \"\"\""
        },
        {
          "line": 253,
          "content": "        if execution_id not in self.clients:"
        },
        {
          "line": 254,
          "content": "            return 0"
        },
        {
          "line": 255,
          "content": "        return len(self.clients[execution_id])"
        },
        {
          "line": 263,
          "content": "async def websocket_handler("
        },
        {
          "line": 267,
          "content": "    \"\"\""
        },
        {
          "line": 273,
          "content": "    \"\"\""
        },
        {
          "line": 277,
          "content": "    if len(parts) >= 3 and parts[0] == 'ws' and parts[1] == 'diagnosis':"
        },
        {
          "line": 280,
          "content": "        await websocket.close(1008, 'Invalid path')"
        },
        {
          "line": 284,
          "content": "    await websocket_service.register(execution_id, websocket)"
        },
        {
          "line": 288,
          "content": "        async for message in websocket:"
        },
        {
          "line": 292,
          "content": "                if data.get('type') == 'heartbeat':"
        },
        {
          "line": 294,
          "content": "                    await websocket.send(json.dumps({"
        },
        {
          "line": 313,
          "content": "        await websocket_service.unregister(execution_id, websocket)"
        },
        {
          "line": 316,
          "content": "class WebSocketServer:"
        },
        {
          "line": 317,
          "content": "    \"\"\""
        },
        {
          "line": 319,
          "content": "    \"\"\""
        },
        {
          "line": 321,
          "content": "    def __init__(self, host: str = '0.0.0.0', port: int = 8765):"
        },
        {
          "line": 322,
          "content": "        \"\"\""
        },
        {
          "line": 328,
          "content": "        \"\"\""
        },
        {
          "line": 333,
          "content": "    def start(self) -> None:"
        },
        {
          "line": 334,
          "content": "        \"\"\""
        },
        {
          "line": 336,
          "content": "        \"\"\""
        },
        {
          "line": 353,
          "content": "    async def start_async(self) -> None:"
        },
        {
          "line": 354,
          "content": "        \"\"\""
        },
        {
          "line": 356,
          "content": "        \"\"\""
        },
        {
          "line": 363,
          "content": "        await self.server"
        },
        {
          "line": 372,
          "content": "    def stop(self) -> None:"
        },
        {
          "line": 373,
          "content": "        \"\"\""
        },
        {
          "line": 375,
          "content": "        \"\"\""
        },
        {
          "line": 376,
          "content": "        if self.server:"
        },
        {
          "line": 387,
          "content": "def get_websocket_service() -> WebSocketService:"
        },
        {
          "line": 388,
          "content": "    \"\"\""
        },
        {
          "line": 393,
          "content": "    \"\"\""
        },
        {
          "line": 394,
          "content": "    return websocket_service"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/services/report_stub_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 10,
          "content": "\"\"\""
        },
        {
          "line": 22,
          "content": "    \"\"\""
        },
        {
          "line": 35,
          "content": "    \"\"\""
        },
        {
          "line": 42,
          "content": "        \"\"\""
        },
        {
          "line": 48,
          "content": "        \"\"\""
        },
        {
          "line": 64,
          "content": "        \"\"\""
        },
        {
          "line": 79,
          "content": "        \"\"\""
        },
        {
          "line": 126,
          "content": "        \"\"\""
        },
        {
          "line": 138,
          "content": "        \"\"\""
        },
        {
          "line": 171,
          "content": "        \"\"\""
        },
        {
          "line": 181,
          "content": "        \"\"\""
        },
        {
          "line": 220,
          "content": "        \"\"\""
        },
        {
          "line": 231,
          "content": "        \"\"\""
        },
        {
          "line": 279,
          "content": "        \"\"\""
        },
        {
          "line": 292,
          "content": "        \"\"\""
        },
        {
          "line": 315,
          "content": "        \"\"\""
        },
        {
          "line": 324,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/services/diagnosis_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 36,
          "content": "    \"\"\""
        },
        {
          "line": 39,
          "content": "        \"\"\""
        },
        {
          "line": 44,
          "content": "        \"\"\""
        },
        {
          "line": 58,
          "content": "        \"\"\"获取超时管理器实例\"\"\""
        },
        {
          "line": 59,
          "content": "        return self._timeout_manager"
        },
        {
          "line": 61,
          "content": "    def start_diagnosis("
        },
        {
          "line": 67,
          "content": "        \"\"\""
        },
        {
          "line": 86,
          "content": "        \"\"\""
        },
        {
          "line": 87,
          "content": "        if not execution_id:"
        },
        {
          "line": 130,
          "content": "    def complete_diagnosis("
        },
        {
          "line": 135,
          "content": "        \"\"\""
        },
        {
          "line": 144,
          "content": "        \"\"\""
        },
        {
          "line": 178,
          "content": "    def fail_diagnosis("
        },
        {
          "line": 184,
          "content": "        \"\"\""
        },
        {
          "line": 191,
          "content": "        \"\"\""
        },
        {
          "line": 213,
          "content": "        if current_state == DiagnosisState.INITIALIZING:"
        },
        {
          "line": 215,
          "content": "        elif current_state == DiagnosisState.AI_FETCHING:"
        },
        {
          "line": 217,
          "content": "        elif current_state == DiagnosisState.ANALYZING:"
        },
        {
          "line": 246,
          "content": "    def _handle_timeout(self, execution_id: str) -> None:"
        },
        {
          "line": 247,
          "content": "        \"\"\""
        },
        {
          "line": 254,
          "content": "        \"\"\""
        },
        {
          "line": 275,
          "content": "            if current_state.is_terminal:"
        },
        {
          "line": 289,
          "content": "            if current_state == DiagnosisState.AI_FETCHING:"
        },
        {
          "line": 291,
          "content": "            elif current_state == DiagnosisState.ANALYZING:"
        },
        {
          "line": 326,
          "content": "    def get_diagnosis_state(self, execution_id: str) -> Dict[str, Any]:"
        },
        {
          "line": 327,
          "content": "        \"\"\""
        },
        {
          "line": 335,
          "content": "        \"\"\""
        },
        {
          "line": 345,
          "content": "        return state_dict"
        },
        {
          "line": 347,
          "content": "    def cancel_diagnosis(self, execution_id: str) -> bool:"
        },
        {
          "line": 348,
          "content": "        \"\"\""
        },
        {
          "line": 356,
          "content": "        \"\"\""
        },
        {
          "line": 374,
          "content": "        if state_machine.is_terminal_state():"
        },
        {
          "line": 383,
          "content": "            return False"
        },
        {
          "line": 397,
          "content": "        return True"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/services/monitoring.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\"告警级别\"\"\""
        },
        {
          "line": 30,
          "content": "class MetricType(Enum):"
        },
        {
          "line": 31,
          "content": "    \"\"\"指标类型\"\"\""
        },
        {
          "line": 39,
          "content": "    \"\"\"告警规则\"\"\""
        },
        {
          "line": 51,
          "content": "class Alert:"
        },
        {
          "line": 52,
          "content": "    \"\"\"告警\"\"\""
        },
        {
          "line": 62,
          "content": "    \"\"\""
        },
        {
          "line": 66,
          "content": "    \"\"\""
        },
        {
          "line": 69,
          "content": "        \"\"\"初始化指标收集器\"\"\""
        },
        {
          "line": 74,
          "content": "    def increment(self, name: str, value: int = 1, labels: Dict = None) -> None:"
        },
        {
          "line": 75,
          "content": "        \"\"\""
        },
        {
          "line": 82,
          "content": "        \"\"\""
        },
        {
          "line": 85,
          "content": "        if key not in self._metrics:"
        },
        {
          "line": 91,
          "content": "    def set(self, name: str, value: Any, labels: Dict = None) -> None:"
        },
        {
          "line": 92,
          "content": "        \"\"\""
        },
        {
          "line": 99,
          "content": "        \"\"\""
        },
        {
          "line": 104,
          "content": "    def get(self, name: str, labels: Dict = None) -> Optional[Any]:"
        },
        {
          "line": 105,
          "content": "        \"\"\""
        },
        {
          "line": 114,
          "content": "        \"\"\""
        },
        {
          "line": 116,
          "content": "        return self._metrics.get(key)"
        },
        {
          "line": 118,
          "content": "    def get_all(self) -> Dict[str, Any]:"
        },
        {
          "line": 119,
          "content": "        \"\"\""
        },
        {
          "line": 124,
          "content": "        \"\"\""
        },
        {
          "line": 125,
          "content": "        return self._metrics.copy()"
        },
        {
          "line": 127,
          "content": "    def _make_key(self, name: str, labels: Dict = None) -> str:"
        },
        {
          "line": 128,
          "content": "        \"\"\""
        },
        {
          "line": 137,
          "content": "        \"\"\""
        },
        {
          "line": 138,
          "content": "        if not labels:"
        },
        {
          "line": 139,
          "content": "            return name"
        },
        {
          "line": 141,
          "content": "        labels_str = ','.join(f\"{k}={v}\" for k, v in sorted(labels.items()))"
        },
        {
          "line": 142,
          "content": "        return f\"{name}{{{labels_str}}}\""
        },
        {
          "line": 144,
          "content": "    def reset(self, name: str = None, labels: Dict = None) -> None:"
        },
        {
          "line": 145,
          "content": "        \"\"\""
        },
        {
          "line": 151,
          "content": "        \"\"\""
        },
        {
          "line": 152,
          "content": "        if name is None:"
        },
        {
          "line": 157,
          "content": "            if key in self._metrics:"
        },
        {
          "line": 159,
          "content": "            if key in self._timestamps:"
        },
        {
          "line": 163,
          "content": "class AlertManager:"
        },
        {
          "line": 164,
          "content": "    \"\"\""
        },
        {
          "line": 168,
          "content": "    \"\"\""
        },
        {
          "line": 170,
          "content": "    def __init__(self):"
        },
        {
          "line": 171,
          "content": "        \"\"\"初始化告警管理器\"\"\""
        },
        {
          "line": 178,
          "content": "        \"\"\""
        },
        {
          "line": 183,
          "content": "        \"\"\""
        },
        {
          "line": 193,
          "content": "        \"\"\""
        },
        {
          "line": 201,
          "content": "        \"\"\""
        },
        {
          "line": 208,
          "content": "        \"\"\""
        },
        {
          "line": 213,
          "content": "        \"\"\""
        },
        {
          "line": 217,
          "content": "        \"\"\""
        },
        {
          "line": 225,
          "content": "        \"\"\""
        },
        {
          "line": 290,
          "content": "        \"\"\""
        },
        {
          "line": 298,
          "content": "        \"\"\""
        },
        {
          "line": 302,
          "content": "        \"\"\"清空告警\"\"\""
        },
        {
          "line": 356,
          "content": "for rule in DEFAULT_ALERT_RULES:"
        },
        {
          "line": 360,
          "content": "def get_metrics_collector() -> MetricsCollector:"
        },
        {
          "line": 361,
          "content": "    \"\"\"获取指标收集器\"\"\""
        },
        {
          "line": 366,
          "content": "    \"\"\"获取告警管理器\"\"\""
        },
        {
          "line": 367,
          "content": "    return _alert_manager"
        },
        {
          "line": 371,
          "content": "def record_metric(name: str, value: Any, labels: Dict = None) -> None:"
        },
        {
          "line": 372,
          "content": "    \"\"\"记录指标\"\"\""
        },
        {
          "line": 377,
          "content": "    \"\"\"增加指标\"\"\""
        },
        {
          "line": 381,
          "content": "def check_alerts() -> List[Alert]:"
        },
        {
          "line": 382,
          "content": "    \"\"\"检查告警\"\"\""
        },
        {
          "line": 388,
          "content": "\"\"\""
        },
        {
          "line": 389,
          "content": "from wechat_backend.v2.services.monitoring import ("
        },
        {
          "line": 405,
          "content": "def send_notification(alert):"
        },
        {
          "line": 410,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/services/friendly_error_reporter.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        },
        {
          "line": 21,
          "content": "    \"\"\"错误严重程度\"\"\""
        },
        {
          "line": 29,
          "content": "class ErrorDisplayConfig:"
        },
        {
          "line": 30,
          "content": "    \"\"\"错误显示配置\"\"\""
        },
        {
          "line": 202,
          "content": "    \"\"\""
        },
        {
          "line": 206,
          "content": "    \"\"\""
        },
        {
          "line": 209,
          "content": "        \"\"\"初始化错误报告器\"\"\""
        },
        {
          "line": 212,
          "content": "    def get_display_config(self, error_type: str) -> ErrorDisplayConfig:"
        },
        {
          "line": 213,
          "content": "        \"\"\""
        },
        {
          "line": 221,
          "content": "        \"\"\""
        },
        {
          "line": 223,
          "content": "        if error_type in self.error_mapping:"
        },
        {
          "line": 224,
          "content": "            return self.error_mapping[error_type]"
        },
        {
          "line": 228,
          "content": "        for key, config in self.error_mapping.items():"
        },
        {
          "line": 229,
          "content": "            if key in error_type_upper or error_type_upper in key:"
        },
        {
          "line": 230,
          "content": "                return config"
        },
        {
          "line": 233,
          "content": "        return self.error_mapping['UNKNOWN_ERROR']"
        },
        {
          "line": 235,
          "content": "    def format_error_message("
        },
        {
          "line": 241,
          "content": "        \"\"\""
        },
        {
          "line": 251,
          "content": "        \"\"\""
        },
        {
          "line": 254,
          "content": "        return {"
        },
        {
          "line": 270,
          "content": "    def should_auto_retry(self, error_type: str) -> bool:"
        },
        {
          "line": 271,
          "content": "        \"\"\""
        },
        {
          "line": 279,
          "content": "        \"\"\""
        },
        {
          "line": 281,
          "content": "        if 'NETWORK' in error_type.upper():"
        },
        {
          "line": 282,
          "content": "            return True"
        },
        {
          "line": 285,
          "content": "        if 'RATE_LIMIT' in error_type.upper():"
        },
        {
          "line": 286,
          "content": "            return True"
        },
        {
          "line": 289,
          "content": "        return False"
        },
        {
          "line": 291,
          "content": "    def get_retry_delay(self, error_type: str, attempt: int) -> int:"
        },
        {
          "line": 292,
          "content": "        \"\"\""
        },
        {
          "line": 301,
          "content": "        \"\"\""
        },
        {
          "line": 309,
          "content": "        import random"
        },
        {
          "line": 313,
          "content": "        return min(delay, max_delay)"
        },
        {
          "line": 315,
          "content": "    def _get_timestamp(self) -> str:"
        },
        {
          "line": 316,
          "content": "        \"\"\"获取时间戳\"\"\""
        },
        {
          "line": 326,
          "content": "    \"\"\""
        },
        {
          "line": 336,
          "content": "    \"\"\""
        },
        {
          "line": 341,
          "content": "\"\"\""
        },
        {
          "line": 342,
          "content": "from wechat_backend.v2.services.friendly_error_reporter import get_friendly_error"
        },
        {
          "line": 357,
          "content": "        if (res.confirm) {"
        },
        {
          "line": 362,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/services/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/services/dead_letter_queue.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "\"\"\""
        },
        {
          "line": 36,
          "content": "    \"\"\""
        },
        {
          "line": 48,
          "content": "    \"\"\""
        },
        {
          "line": 57,
          "content": "        \"\"\""
        },
        {
          "line": 62,
          "content": "        \"\"\""
        },
        {
          "line": 82,
          "content": "        \"\"\""
        },
        {
          "line": 87,
          "content": "        \"\"\""
        },
        {
          "line": 108,
          "content": "        \"\"\"初始化数据库表\"\"\""
        },
        {
          "line": 144,
          "content": "            ''')"
        },
        {
          "line": 150,
          "content": "            ''')"
        },
        {
          "line": 155,
          "content": "            ''')"
        },
        {
          "line": 160,
          "content": "            ''')"
        },
        {
          "line": 165,
          "content": "            ''')"
        },
        {
          "line": 179,
          "content": "        \"\"\""
        },
        {
          "line": 196,
          "content": "        \"\"\""
        },
        {
          "line": 213,
          "content": "                ''', ("
        },
        {
          "line": 245,
          "content": "                return dead_letter_id"
        },
        {
          "line": 257,
          "content": "            raise DeadLetterQueueError(f\"添加死信失败：{e}\") from e"
        },
        {
          "line": 259,
          "content": "    def get_dead_letter(self, dead_letter_id: int) -> Optional[Dict[str, Any]]:"
        },
        {
          "line": 260,
          "content": "        \"\"\""
        },
        {
          "line": 268,
          "content": "        \"\"\""
        },
        {
          "line": 274,
          "content": "                ''', (dead_letter_id,))"
        },
        {
          "line": 299,
          "content": "        \"\"\""
        },
        {
          "line": 311,
          "content": "        \"\"\""
        },
        {
          "line": 351,
          "content": "        \"\"\""
        },
        {
          "line": 360,
          "content": "        \"\"\""
        },
        {
          "line": 398,
          "content": "        \"\"\""
        },
        {
          "line": 408,
          "content": "        \"\"\""
        },
        {
          "line": 422,
          "content": "                ''', ("
        },
        {
          "line": 432,
          "content": "                if affected:"
        },
        {
          "line": 442,
          "content": "                return affected"
        },
        {
          "line": 453,
          "content": "            return False"
        },
        {
          "line": 455,
          "content": "    def mark_as_ignored("
        },
        {
          "line": 461,
          "content": "        \"\"\""
        },
        {
          "line": 471,
          "content": "        \"\"\""
        },
        {
          "line": 485,
          "content": "                ''', ("
        },
        {
          "line": 523,
          "content": "        \"\"\""
        },
        {
          "line": 534,
          "content": "        \"\"\""
        },
        {
          "line": 547,
          "content": "                ''', ("
        },
        {
          "line": 556,
          "content": "                if affected:"
        },
        {
          "line": 566,
          "content": "                return affected"
        },
        {
          "line": 577,
          "content": "            return False"
        },
        {
          "line": 579,
          "content": "    def get_statistics(self) -> Dict[str, Any]:"
        },
        {
          "line": 580,
          "content": "        \"\"\""
        },
        {
          "line": 585,
          "content": "        \"\"\""
        },
        {
          "line": 595,
          "content": "                ''')"
        },
        {
          "line": 604,
          "content": "                ''')"
        },
        {
          "line": 605,
          "content": "                type_stats = {row['task_type']: row['count'] for row in cursor.fetchall()}"
        },
        {
          "line": 611,
          "content": "                ''')"
        },
        {
          "line": 642,
          "content": "        \"\"\"获取最早的 pending 任务时间\"\"\""
        },
        {
          "line": 651,
          "content": "                ''')"
        },
        {
          "line": 658,
          "content": "        \"\"\""
        },
        {
          "line": 666,
          "content": "        \"\"\""
        },
        {
          "line": 674,
          "content": "                ''', (f'-{days} days',))"
        },
        {
          "line": 678,
          "content": "                if deleted > 0:"
        },
        {
          "line": 688,
          "content": "                return deleted"
        },
        {
          "line": 698,
          "content": "            return 0"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/services/retry_policy.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "\"\"\""
        },
        {
          "line": 39,
          "content": "    \"\"\""
        },
        {
          "line": 46,
          "content": "    \"\"\""
        },
        {
          "line": 58,
          "content": "        \"\"\""
        },
        {
          "line": 65,
          "content": "        \"\"\""
        },
        {
          "line": 75,
          "content": "        \"\"\""
        },
        {
          "line": 80,
          "content": "        \"\"\""
        },
        {
          "line": 99,
          "content": "        \"\"\"获取最后一次尝试的异常\"\"\""
        },
        {
          "line": 100,
          "content": "        if not self.attempts:"
        },
        {
          "line": 101,
          "content": "            return None"
        },
        {
          "line": 104,
          "content": "        if last_attempt.get('error_type'):"
        },
        {
          "line": 106,
          "content": "            return Exception(f\"{last_attempt['error_type']}: {last_attempt['error']}\")"
        },
        {
          "line": 107,
          "content": "        return None"
        },
        {
          "line": 110,
          "content": "class RetryPolicy:"
        },
        {
          "line": 111,
          "content": "    \"\"\""
        },
        {
          "line": 123,
          "content": "    \"\"\""
        },
        {
          "line": 139,
          "content": "    def __init__("
        },
        {
          "line": 148,
          "content": "        \"\"\""
        },
        {
          "line": 161,
          "content": "        \"\"\""
        },
        {
          "line": 162,
          "content": "        if max_retries < 0:"
        },
        {
          "line": 164,
          "content": "        if base_delay <= 0:"
        },
        {
          "line": 166,
          "content": "        if max_delay <= 0:"
        },
        {
          "line": 168,
          "content": "        if max_delay < base_delay:"
        },
        {
          "line": 190,
          "content": "                'retryable_exceptions': [e.__name__ for e in self._retryable_exceptions],"
        },
        {
          "line": 195,
          "content": "    def max_retries(self) -> int:"
        },
        {
          "line": 196,
          "content": "        \"\"\"获取最大重试次数\"\"\""
        },
        {
          "line": 201,
          "content": "        \"\"\"获取基础延迟\"\"\""
        },
        {
          "line": 202,
          "content": "        return self._base_delay"
        },
        {
          "line": 205,
          "content": "    def max_delay(self) -> float:"
        },
        {
          "line": 206,
          "content": "        \"\"\"获取最大延迟\"\"\""
        },
        {
          "line": 210,
          "content": "        \"\"\"获取最后一次重试的上下文\"\"\""
        },
        {
          "line": 211,
          "content": "        return self._current_context"
        },
        {
          "line": 213,
          "content": "    def calculate_delay(self, retry_count: int) -> float:"
        },
        {
          "line": 214,
          "content": "        \"\"\""
        },
        {
          "line": 231,
          "content": "        \"\"\""
        },
        {
          "line": 232,
          "content": "        if self._exponential_backoff:"
        },
        {
          "line": 243,
          "content": "        if self._jitter:"
        },
        {
          "line": 247,
          "content": "        return round(delay, 3)"
        },
        {
          "line": 249,
          "content": "    def should_retry(self, exception: Exception, retry_count: int) -> bool:"
        },
        {
          "line": 250,
          "content": "        \"\"\""
        },
        {
          "line": 259,
          "content": "        \"\"\""
        },
        {
          "line": 261,
          "content": "        if retry_count >= self._max_retries:"
        },
        {
          "line": 262,
          "content": "            return False"
        },
        {
          "line": 265,
          "content": "        for exception_type in self._retryable_exceptions:"
        },
        {
          "line": 266,
          "content": "            if isinstance(exception, exception_type):"
        },
        {
          "line": 267,
          "content": "                return True"
        },
        {
          "line": 269,
          "content": "        return False"
        },
        {
          "line": 271,
          "content": "    async def execute_async("
        },
        {
          "line": 277,
          "content": "        \"\"\""
        },
        {
          "line": 296,
          "content": "        \"\"\""
        },
        {
          "line": 308,
          "content": "        while True:"
        },
        {
          "line": 311,
          "content": "                result = await func(*args, **kwargs)"
        },
        {
          "line": 329,
          "content": "                return result"
        },
        {
          "line": 335,
          "content": "                if not self.should_retry(e, retry_count):"
        },
        {
          "line": 379,
          "content": "                await asyncio.sleep(delay)"
        },
        {
          "line": 382,
          "content": "    def execute_sync("
        },
        {
          "line": 388,
          "content": "        \"\"\""
        },
        {
          "line": 407,
          "content": "        \"\"\""
        },
        {
          "line": 419,
          "content": "        while True:"
        },
        {
          "line": 440,
          "content": "                return result"
        },
        {
          "line": 446,
          "content": "                if not self.should_retry(e, retry_count):"
        },
        {
          "line": 493,
          "content": "    def as_decorator(self) -> Callable:"
        },
        {
          "line": 494,
          "content": "        \"\"\""
        },
        {
          "line": 505,
          "content": "        \"\"\""
        },
        {
          "line": 506,
          "content": "        def decorator(func: Callable) -> Callable:"
        },
        {
          "line": 507,
          "content": "            if asyncio.iscoroutinefunction(func):"
        },
        {
          "line": 509,
          "content": "                async def async_wrapper(*args, **kwargs):"
        },
        {
          "line": 510,
          "content": "                    return await self.execute_async(func, *args, **kwargs)"
        },
        {
          "line": 511,
          "content": "                return async_wrapper"
        },
        {
          "line": 514,
          "content": "                def sync_wrapper(*args, **kwargs):"
        },
        {
          "line": 515,
          "content": "                    return self.execute_sync(func, *args, **kwargs)"
        },
        {
          "line": 516,
          "content": "                return sync_wrapper"
        },
        {
          "line": 518,
          "content": "        return decorator"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/services/performance_optimizer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 27,
          "content": "    \"\"\""
        },
        {
          "line": 30,
          "content": "        \"\"\""
        },
        {
          "line": 35,
          "content": "        \"\"\""
        },
        {
          "line": 48,
          "content": "        \"\"\""
        },
        {
          "line": 57,
          "content": "        \"\"\""
        },
        {
          "line": 89,
          "content": "        \"\"\""
        },
        {
          "line": 94,
          "content": "        \"\"\""
        },
        {
          "line": 107,
          "content": "    \"\"\""
        },
        {
          "line": 111,
          "content": "    \"\"\""
        },
        {
          "line": 114,
          "content": "        \"\"\""
        },
        {
          "line": 120,
          "content": "        \"\"\""
        },
        {
          "line": 127,
          "content": "        \"\"\""
        },
        {
          "line": 132,
          "content": "        \"\"\""
        },
        {
          "line": 153,
          "content": "        \"\"\""
        },
        {
          "line": 158,
          "content": "        \"\"\""
        },
        {
          "line": 169,
          "content": "        \"\"\""
        },
        {
          "line": 178,
          "content": "        \"\"\""
        },
        {
          "line": 186,
          "content": "    \"\"\""
        },
        {
          "line": 190,
          "content": "    \"\"\""
        },
        {
          "line": 193,
          "content": "        \"\"\""
        },
        {
          "line": 199,
          "content": "        \"\"\""
        },
        {
          "line": 209,
          "content": "        \"\"\""
        },
        {
          "line": 217,
          "content": "        \"\"\""
        },
        {
          "line": 236,
          "content": "        \"\"\""
        },
        {
          "line": 242,
          "content": "        \"\"\""
        },
        {
          "line": 257,
          "content": "        \"\"\""
        },
        {
          "line": 265,
          "content": "        \"\"\""
        },
        {
          "line": 269,
          "content": "        \"\"\""
        },
        {
          "line": 277,
          "content": "        \"\"\""
        },
        {
          "line": 286,
          "content": "        \"\"\""
        },
        {
          "line": 294,
          "content": "        \"\"\""
        },
        {
          "line": 301,
          "content": "        \"\"\"清空缓存\"\"\""
        },
        {
          "line": 305,
          "content": "    def get_stats(self) -> Dict[str, Any]:"
        },
        {
          "line": 306,
          "content": "        \"\"\""
        },
        {
          "line": 311,
          "content": "        \"\"\""
        },
        {
          "line": 313,
          "content": "        return {"
        },
        {
          "line": 318,
          "content": "            'hit_rate': round(self._hits / total * 100, 2) if total > 0 else 0.0"
        },
        {
          "line": 327,
          "content": "def get_concurrency_controller(max_concurrent: Optional[int] = None) -> ConcurrencyController:"
        },
        {
          "line": 328,
          "content": "    \"\"\""
        },
        {
          "line": 336,
          "content": "    \"\"\""
        },
        {
          "line": 337,
          "content": "    if max_concurrent is not None:"
        },
        {
          "line": 338,
          "content": "        return ConcurrencyController(max_concurrent=max_concurrent)"
        },
        {
          "line": 339,
          "content": "    return _default_concurrency_controller"
        },
        {
          "line": 342,
          "content": "def get_cache(ttl: Optional[int] = None) -> LRUCache:"
        },
        {
          "line": 343,
          "content": "    \"\"\""
        },
        {
          "line": 351,
          "content": "    \"\"\""
        },
        {
          "line": 352,
          "content": "    if ttl is not None:"
        },
        {
          "line": 353,
          "content": "        return LRUCache(max_size=1000, ttl=ttl)"
        },
        {
          "line": 354,
          "content": "    return _default_cache"
        },
        {
          "line": 358,
          "content": "def cache_result(key_prefix: str = '', ttl: int = 300):"
        },
        {
          "line": 359,
          "content": "    \"\"\""
        },
        {
          "line": 365,
          "content": "    \"\"\""
        },
        {
          "line": 366,
          "content": "    def decorator(func: Callable):"
        },
        {
          "line": 369,
          "content": "        async def wrapper(*args, **kwargs):"
        },
        {
          "line": 375,
          "content": "            if cached_result is not None:"
        },
        {
          "line": 376,
          "content": "                return cached_result"
        },
        {
          "line": 379,
          "content": "            result = await func(*args, **kwargs)"
        },
        {
          "line": 384,
          "content": "            return result"
        },
        {
          "line": 386,
          "content": "        return wrapper"
        },
        {
          "line": 387,
          "content": "    return decorator"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/services/data_persistence_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 25,
          "content": "    \"\"\""
        },
        {
          "line": 36,
          "content": "        >>> result_id = await service.save_ai_response(...)"
        },
        {
          "line": 37,
          "content": "        >>> result_ids = await service.save_batch_responses(...)"
        },
        {
          "line": 38,
          "content": "    \"\"\""
        },
        {
          "line": 45,
          "content": "        \"\"\""
        },
        {
          "line": 51,
          "content": "        \"\"\""
        },
        {
          "line": 73,
          "content": "        \"\"\""
        },
        {
          "line": 97,
          "content": "        \"\"\""
        },
        {
          "line": 178,
          "content": "        \"\"\""
        },
        {
          "line": 197,
          "content": "        \"\"\""
        },
        {
          "line": 278,
          "content": "        \"\"\""
        },
        {
          "line": 288,
          "content": "        \"\"\""
        },
        {
          "line": 297,
          "content": "        \"\"\""
        },
        {
          "line": 307,
          "content": "        \"\"\""
        },
        {
          "line": 318,
          "content": "        \"\"\""
        },
        {
          "line": 330,
          "content": "        \"\"\""
        },
        {
          "line": 336,
          "content": "        \"\"\""
        },
        {
          "line": 344,
          "content": "        \"\"\""
        },
        {
          "line": 348,
          "content": "        \"\"\""
        },
        {
          "line": 358,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/services/timeout_service.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "\"\"\""
        },
        {
          "line": 28,
          "content": "    \"\"\""
        },
        {
          "line": 39,
          "content": "        >>> def on_timeout(execution_id):"
        },
        {
          "line": 43,
          "content": "    \"\"\""
        },
        {
          "line": 50,
          "content": "        \"\"\""
        },
        {
          "line": 58,
          "content": "        \"\"\""
        },
        {
          "line": 78,
          "content": "        \"\"\""
        },
        {
          "line": 93,
          "content": "        \"\"\""
        },
        {
          "line": 116,
          "content": "                \"\"\"超时处理函数\"\"\""
        },
        {
          "line": 157,
          "content": "    def cancel_timer(self, execution_id: str) -> bool:"
        },
        {
          "line": 158,
          "content": "        \"\"\""
        },
        {
          "line": 170,
          "content": "        \"\"\""
        },
        {
          "line": 172,
          "content": "            if execution_id not in self._timers:"
        },
        {
          "line": 180,
          "content": "                return False"
        },
        {
          "line": 194,
          "content": "            return True"
        },
        {
          "line": 196,
          "content": "    def get_remaining_time(self, execution_id: str) -> int:"
        },
        {
          "line": 197,
          "content": "        \"\"\""
        },
        {
          "line": 209,
          "content": "        \"\"\""
        },
        {
          "line": 211,
          "content": "            if execution_id not in self._start_times:"
        },
        {
          "line": 212,
          "content": "                return 0"
        },
        {
          "line": 219,
          "content": "            return remaining"
        },
        {
          "line": 221,
          "content": "    def is_timer_active(self, execution_id: str) -> bool:"
        },
        {
          "line": 222,
          "content": "        \"\"\""
        },
        {
          "line": 234,
          "content": "        \"\"\""
        },
        {
          "line": 236,
          "content": "            return execution_id in self._timers"
        },
        {
          "line": 238,
          "content": "    def _cleanup(self, execution_id: str) -> None:"
        },
        {
          "line": 239,
          "content": "        \"\"\""
        },
        {
          "line": 244,
          "content": "        \"\"\""
        },
        {
          "line": 245,
          "content": "        if execution_id in self._timers:"
        },
        {
          "line": 248,
          "content": "        if execution_id in self._start_times:"
        },
        {
          "line": 251,
          "content": "        if execution_id in self._timeouts:"
        },
        {
          "line": 262,
          "content": "    def get_active_timers_count(self) -> int:"
        },
        {
          "line": 263,
          "content": "        \"\"\""
        },
        {
          "line": 268,
          "content": "        \"\"\""
        },
        {
          "line": 270,
          "content": "            return len(self._timers)"
        },
        {
          "line": 272,
          "content": "    def cancel_all_timers(self) -> int:"
        },
        {
          "line": 273,
          "content": "        \"\"\""
        },
        {
          "line": 278,
          "content": "        \"\"\""
        },
        {
          "line": 281,
          "content": "            for timer in self._timers.values():"
        },
        {
          "line": 293,
          "content": "            return count"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/analytics/keyword_extractor.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 27,
          "content": "    \"\"\""
        },
        {
          "line": 62,
          "content": "        \"\"\""
        },
        {
          "line": 68,
          "content": "        \"\"\""
        },
        {
          "line": 74,
          "content": "        \"\"\""
        },
        {
          "line": 83,
          "content": "        \"\"\""
        },
        {
          "line": 106,
          "content": "        \"\"\""
        },
        {
          "line": 132,
          "content": "        \"\"\""
        },
        {
          "line": 159,
          "content": "        \"\"\""
        },
        {
          "line": 167,
          "content": "        \"\"\""
        },
        {
          "line": 179,
          "content": "        \"\"\""
        },
        {
          "line": 188,
          "content": "        \"\"\""
        },
        {
          "line": 208,
          "content": "        \"\"\""
        },
        {
          "line": 218,
          "content": "        \"\"\""
        },
        {
          "line": 241,
          "content": "        \"\"\""
        },
        {
          "line": 251,
          "content": "        \"\"\""
        },
        {
          "line": 260,
          "content": "        \"\"\""
        },
        {
          "line": 269,
          "content": "        \"\"\""
        },
        {
          "line": 307,
          "content": "        \"\"\""
        },
        {
          "line": 316,
          "content": "        \"\"\""
        },
        {
          "line": 342,
          "content": "        \"\"\""
        },
        {
          "line": 351,
          "content": "        \"\"\""
        },
        {
          "line": 372,
          "content": "        \"\"\"从结果中提取响应文本\"\"\""
        },
        {
          "line": 377,
          "content": "        if 'response_text' in geo_data:"
        },
        {
          "line": 378,
          "content": "            return geo_data['response_text']"
        },
        {
          "line": 381,
          "content": "        if 'content' in geo_data:"
        },
        {
          "line": 382,
          "content": "            return geo_data['content']"
        },
        {
          "line": 386,
          "content": "        if isinstance(response, dict):"
        },
        {
          "line": 387,
          "content": "            return response.get('content', '') or response.get('text', '')"
        },
        {
          "line": 389,
          "content": "        return ''"
        },
        {
          "line": 391,
          "content": "    def _tokenize(self, text: str) -> List[str]:"
        },
        {
          "line": 392,
          "content": "        \"\"\""
        },
        {
          "line": 396,
          "content": "        \"\"\""
        },
        {
          "line": 409,
          "content": "            word for word in all_words"
        },
        {
          "line": 410,
          "content": "            if word.lower() not in self.CHINESE_STOPWORDS"
        },
        {
          "line": 413,
          "content": "        return filtered_words"
        },
        {
          "line": 415,
          "content": "    def _split_sentences(self, text: str) -> List[str]:"
        },
        {
          "line": 416,
          "content": "        \"\"\"分割句子\"\"\""
        },
        {
          "line": 422,
          "content": "        \"\"\""
        },
        {
          "line": 426,
          "content": "        \"\"\""
        },
        {
          "line": 444,
          "content": "        \"\"\"将情感得分转换为标签\"\"\""
        },
        {
          "line": 445,
          "content": "        if sentiment > 0.3:"
        },
        {
          "line": 446,
          "content": "            return 'positive'"
        },
        {
          "line": 447,
          "content": "        elif sentiment < -0.3:"
        },
        {
          "line": 448,
          "content": "            return 'negative'"
        },
        {
          "line": 450,
          "content": "            return 'neutral'"
        },
        {
          "line": 452,
          "content": "    def _sentiment_to_color(self, sentiment: float) -> str:"
        },
        {
          "line": 453,
          "content": "        \"\"\"将情感得分转换为颜色\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/analytics/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/analytics/trend_analyzer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 27,
          "content": "    \"\"\""
        },
        {
          "line": 30,
          "content": "        \"\"\"初始化分析器\"\"\""
        },
        {
          "line": 33,
          "content": "    def _validate_results(self, results: Any, method_name: str) -> None:"
        },
        {
          "line": 34,
          "content": "        \"\"\""
        },
        {
          "line": 43,
          "content": "        \"\"\""
        },
        {
          "line": 44,
          "content": "        if not isinstance(results, list):"
        },
        {
          "line": 52,
          "content": "        for i, result in enumerate(results):"
        },
        {
          "line": 53,
          "content": "            if not isinstance(result, dict):"
        },
        {
          "line": 61,
          "content": "    def compare_with_history("
        },
        {
          "line": 66,
          "content": "        \"\"\""
        },
        {
          "line": 78,
          "content": "        \"\"\""
        },
        {
          "line": 83,
          "content": "        if not current_results:"
        },
        {
          "line": 84,
          "content": "            return {'error': '当前结果为空'}"
        },
        {
          "line": 86,
          "content": "        if not historical_data:"
        },
        {
          "line": 87,
          "content": "            return {'error': '历史数据为空'}"
        },
        {
          "line": 98,
          "content": "        return {"
        },
        {
          "line": 104,
          "content": "    def analyze_competitors("
        },
        {
          "line": 109,
          "content": "        \"\"\""
        },
        {
          "line": 121,
          "content": "        \"\"\""
        },
        {
          "line": 125,
          "content": "        if not results:"
        },
        {
          "line": 126,
          "content": "            return {'error': '结果为空'}"
        },
        {
          "line": 130,
          "content": "        for result in results:"
        },
        {
          "line": 136,
          "content": "        for brand, brand_data in brand_results.items():"
        },
        {
          "line": 145,
          "content": "            for brand, metrics in brand_metrics.items()"
        },
        {
          "line": 146,
          "content": "            if brand != main_brand"
        },
        {
          "line": 155,
          "content": "        return {"
        },
        {
          "line": 164,
          "content": "    def analyze_time_series("
        },
        {
          "line": 169,
          "content": "        \"\"\""
        },
        {
          "line": 179,
          "content": "        \"\"\""
        },
        {
          "line": 180,
          "content": "        if not time_series_data:"
        },
        {
          "line": 181,
          "content": "            return {'error': '时间序列数据为空'}"
        },
        {
          "line": 184,
          "content": "        values = [d.get(metric, d.get('value', 0)) for d in time_series_data]"
        },
        {
          "line": 186,
          "content": "        if not values:"
        },
        {
          "line": 187,
          "content": "            return {'error': '无效数据'}"
        },
        {
          "line": 199,
          "content": "        return {"
        },
        {
          "line": 211,
          "content": "    def predict_trend("
        },
        {
          "line": 216,
          "content": "        \"\"\""
        },
        {
          "line": 225,
          "content": "        \"\"\""
        },
        {
          "line": 226,
          "content": "        if not time_series_data or len(time_series_data) < 2:"
        },
        {
          "line": 227,
          "content": "            return []"
        },
        {
          "line": 230,
          "content": "        values = [d.get('value', 0) for d in time_series_data]"
        },
        {
          "line": 233,
          "content": "        changes = [values[i] - values[i-1] for i in range(1, len(values))]"
        },
        {
          "line": 234,
          "content": "        avg_change = sum(changes) / len(changes) if changes else 0"
        },
        {
          "line": 241,
          "content": "        for i in range(periods):"
        },
        {
          "line": 249,
          "content": "        return predictions"
        },
        {
          "line": 251,
          "content": "    def calculate_brand_velocity("
        },
        {
          "line": 256,
          "content": "        \"\"\""
        },
        {
          "line": 265,
          "content": "        \"\"\""
        },
        {
          "line": 270,
          "content": "        for key in current_metrics:"
        },
        {
          "line": 271,
          "content": "            if key in previous_metrics and previous_metrics[key] != 0:"
        },
        {
          "line": 277,
          "content": "        return velocity"
        },
        {
          "line": 279,
          "content": "    def _calculate_metrics(self, results: List[Dict[str, Any]]) -> Dict[str, float]:"
        },
        {
          "line": 280,
          "content": "        \"\"\"计算综合指标\"\"\""
        },
        {
          "line": 316,
          "content": "        \"\"\"计算多个指标的平均值\"\"\""
        },
        {
          "line": 317,
          "content": "        if not metrics_list:"
        },
        {
          "line": 318,
          "content": "            return {}"
        },
        {
          "line": 324,
          "content": "        for key in numeric_keys:"
        },
        {
          "line": 325,
          "content": "            values = [m.get(key, 0) for m in metrics_list if key in m]"
        },
        {
          "line": 326,
          "content": "            if values:"
        },
        {
          "line": 331,
          "content": "        for metrics in metrics_list:"
        },
        {
          "line": 333,
          "content": "            for brand, rate in mention_rates.items():"
        },
        {
          "line": 338,
          "content": "            for brand, rates in all_mention_rates.items()"
        },
        {
          "line": 341,
          "content": "        return avg"
        },
        {
          "line": 343,
          "content": "    def _calculate_trend("
        },
        {
          "line": 348,
          "content": "        \"\"\"计算趋势方向\"\"\""
        },
        {
          "line": 370,
          "content": "        \"\"\"计算趋势方向\"\"\""
        },
        {
          "line": 371,
          "content": "        if len(values) < 2:"
        },
        {
          "line": 372,
          "content": "            return 'insufficient_data'"
        },
        {
          "line": 379,
          "content": "        numerator = sum((i - x_mean) * (values[i] - y_mean) for i in range(n))"
        },
        {
          "line": 380,
          "content": "        denominator = sum((i - x_mean) ** 2 for i in range(n))"
        },
        {
          "line": 382,
          "content": "        if denominator == 0:"
        },
        {
          "line": 383,
          "content": "            return 'stable'"
        },
        {
          "line": 387,
          "content": "        if slope > 0.01:"
        },
        {
          "line": 388,
          "content": "            return 'upward'"
        },
        {
          "line": 389,
          "content": "        elif slope < -0.01:"
        },
        {
          "line": 390,
          "content": "            return 'downward'"
        },
        {
          "line": 392,
          "content": "            return 'stable'"
        },
        {
          "line": 394,
          "content": "    def _calculate_trend_strength(self, values: List[float]) -> float:"
        },
        {
          "line": 395,
          "content": "        \"\"\"计算趋势强度\"\"\""
        },
        {
          "line": 414,
          "content": "        \"\"\"计算移动平均\"\"\""
        },
        {
          "line": 415,
          "content": "        if len(values) < window:"
        },
        {
          "line": 416,
          "content": "            return values"
        },
        {
          "line": 419,
          "content": "        for i in range(len(values) - window + 1):"
        },
        {
          "line": 424,
          "content": "        return moving_avg"
        },
        {
          "line": 426,
          "content": "    def _calculate_growth_rate(self, values: List[float]) -> float:"
        },
        {
          "line": 427,
          "content": "        \"\"\"计算增长率\"\"\""
        },
        {
          "line": 437,
          "content": "        \"\"\"计算品牌排名\"\"\""
        },
        {
          "line": 440,
          "content": "        for brand, metrics in brand_metrics.items():"
        },
        {
          "line": 451,
          "content": "        for i, item in enumerate(rankings):"
        },
        {
          "line": 454,
          "content": "        return rankings"
        },
        {
          "line": 456,
          "content": "    def _analyze_swot("
        },
        {
          "line": 461,
          "content": "        \"\"\"分析优势和劣势\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/analytics/brand_distribution_analyzer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 12,
          "content": "\"\"\""
        },
        {
          "line": 21,
          "content": "    \"\"\""
        },
        {
          "line": 25,
          "content": "    \"\"\""
        },
        {
          "line": 28,
          "content": "        \"\"\"初始化分析器\"\"\""
        },
        {
          "line": 31,
          "content": "    def _validate_results(self, results: Any, method_name: str) -> None:"
        },
        {
          "line": 32,
          "content": "        \"\"\""
        },
        {
          "line": 41,
          "content": "        \"\"\""
        },
        {
          "line": 42,
          "content": "        if not isinstance(results, list):"
        },
        {
          "line": 50,
          "content": "        for i, result in enumerate(results):"
        },
        {
          "line": 51,
          "content": "            if not isinstance(result, dict):"
        },
        {
          "line": 59,
          "content": "    def analyze(self, results: List[Dict[str, Any]]) -> Dict[str, float]:"
        },
        {
          "line": 60,
          "content": "        \"\"\""
        },
        {
          "line": 81,
          "content": "        \"\"\""
        },
        {
          "line": 85,
          "content": "        if not results:"
        },
        {
          "line": 87,
          "content": "            return {"
        },
        {
          "line": 95,
          "content": "        for result in results:"
        },
        {
          "line": 101,
          "content": "        if total == 0:"
        },
        {
          "line": 103,
          "content": "            return {"
        },
        {
          "line": 110,
          "content": "        for brand, count in brand_counts.items():"
        },
        {
          "line": 120,
          "content": "        return {"
        },
        {
          "line": 126,
          "content": "    def analyze_by_model("
        },
        {
          "line": 130,
          "content": "        \"\"\""
        },
        {
          "line": 145,
          "content": "        \"\"\""
        },
        {
          "line": 146,
          "content": "        if not results:"
        },
        {
          "line": 147,
          "content": "            return {}"
        },
        {
          "line": 152,
          "content": "        for result in results:"
        },
        {
          "line": 159,
          "content": "        for model, brand_counts in model_brand_counts.items():"
        },
        {
          "line": 163,
          "content": "                for brand, count in brand_counts.items()"
        },
        {
          "line": 167,
          "content": "        return distribution"
        },
        {
          "line": 169,
          "content": "    def analyze_competitors("
        },
        {
          "line": 174,
          "content": "        \"\"\""
        },
        {
          "line": 183,
          "content": "        \"\"\""
        },
        {
          "line": 184,
          "content": "        if not results:"
        },
        {
          "line": 185,
          "content": "            return {"
        },
        {
          "line": 201,
          "content": "            for brand, share in distribution.items()"
        },
        {
          "line": 202,
          "content": "            if brand != main_brand"
        },
        {
          "line": 208,
          "content": "            (i + 1 for i, (brand, _) in enumerate(sorted_shares) if brand == main_brand),"
        },
        {
          "line": 218,
          "content": "            'top_competitor': max(competitor_shares.items(), key=lambda x: x[1])[0] if competitor_shares else None"
        },
        {
          "line": 222,
          "content": "        return result"
        },
        {
          "line": 224,
          "content": "    def analyze_mention_trend("
        },
        {
          "line": 229,
          "content": "        \"\"\""
        },
        {
          "line": 238,
          "content": "        \"\"\""
        },
        {
          "line": 239,
          "content": "        if not results:"
        },
        {
          "line": 240,
          "content": "            return {}"
        },
        {
          "line": 244,
          "content": "        for result in results:"
        },
        {
          "line": 250,
          "content": "        return {k: dict(v) for k, v in trend_data.items()}"
        },
        {
          "line": 252,
          "content": "    def get_brand_details("
        },
        {
          "line": 257,
          "content": "        \"\"\""
        },
        {
          "line": 266,
          "content": "        \"\"\""
        },
        {
          "line": 267,
          "content": "        brand_results = [r for r in results if r.get('brand') == brand_name]"
        },
        {
          "line": 269,
          "content": "        if not brand_results:"
        },
        {
          "line": 270,
          "content": "            return {"
        },
        {
          "line": 279,
          "content": "        for r in brand_results:"
        },
        {
          "line": 284,
          "content": "        for r in brand_results:"
        },
        {
          "line": 287,
          "content": "        return {"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/analytics/geo_parser.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 9,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 28,
          "content": "    \"\"\""
        },
        {
          "line": 37,
          "content": "    \"\"\""
        },
        {
          "line": 51,
          "content": "    \"\"\""
        },
        {
          "line": 54,
          "content": "        \"\"\"初始化 GEO 分析器\"\"\""
        },
        {
          "line": 79,
          "content": "    def analyze("
        },
        {
          "line": 85,
          "content": "        \"\"\""
        },
        {
          "line": 95,
          "content": "        \"\"\""
        },
        {
          "line": 96,
          "content": "        if not response_text:"
        },
        {
          "line": 97,
          "content": "            return GEOData("
        },
        {
          "line": 115,
          "content": "        if competitor_brands:"
        },
        {
          "line": 124,
          "content": "        return GEOData("
        },
        {
          "line": 135,
          "content": "    def _check_exposure(self, text: str, brand_name: str) -> bool:"
        },
        {
          "line": 136,
          "content": "        \"\"\""
        },
        {
          "line": 145,
          "content": "        \"\"\""
        },
        {
          "line": 146,
          "content": "        if not text or not brand_name:"
        },
        {
          "line": 147,
          "content": "            return False"
        },
        {
          "line": 150,
          "content": "        return brand_name in text"
        },
        {
          "line": 152,
          "content": "    def _analyze_sentiment(self, text: str) -> str:"
        },
        {
          "line": 153,
          "content": "        \"\"\""
        },
        {
          "line": 161,
          "content": "        \"\"\""
        },
        {
          "line": 162,
          "content": "        if not text:"
        },
        {
          "line": 163,
          "content": "            return 'neutral'"
        },
        {
          "line": 169,
          "content": "            1 for word in self.sentiment_dict['positive']"
        },
        {
          "line": 170,
          "content": "            if word in text_lower"
        },
        {
          "line": 173,
          "content": "            1 for word in self.sentiment_dict['negative']"
        },
        {
          "line": 174,
          "content": "            if word in text_lower"
        },
        {
          "line": 178,
          "content": "        if positive_count > negative_count:"
        },
        {
          "line": 179,
          "content": "            return 'positive'"
        },
        {
          "line": 180,
          "content": "        elif negative_count > positive_count:"
        },
        {
          "line": 181,
          "content": "            return 'negative'"
        },
        {
          "line": 183,
          "content": "            return 'neutral'"
        },
        {
          "line": 185,
          "content": "    def _extract_keywords(self, text: str, top_n: int = 10) -> List[str]:"
        },
        {
          "line": 186,
          "content": "        \"\"\""
        },
        {
          "line": 195,
          "content": "        \"\"\""
        },
        {
          "line": 196,
          "content": "        if not text:"
        },
        {
          "line": 197,
          "content": "            return []"
        },
        {
          "line": 204,
          "content": "            w for w in words"
        },
        {
          "line": 205,
          "content": "            if w not in self.stopwords and len(w) > 1"
        },
        {
          "line": 212,
          "content": "        return [word for word, _ in word_counts.most_common(top_n)]"
        },
        {
          "line": 214,
          "content": "    def _analyze_competitors("
        },
        {
          "line": 219,
          "content": "        \"\"\""
        },
        {
          "line": 228,
          "content": "        \"\"\""
        },
        {
          "line": 229,
          "content": "        return {"
        },
        {
          "line": 231,
          "content": "            for comp in competitors"
        },
        {
          "line": 234,
          "content": "    def _calculate_confidence(self, text: str) -> float:"
        },
        {
          "line": 235,
          "content": "        \"\"\""
        },
        {
          "line": 243,
          "content": "        \"\"\""
        },
        {
          "line": 244,
          "content": "        if not text:"
        },
        {
          "line": 245,
          "content": "            return 0.0"
        },
        {
          "line": 249,
          "content": "        if length > 1000:"
        },
        {
          "line": 250,
          "content": "            return 1.0"
        },
        {
          "line": 251,
          "content": "        elif length > 500:"
        },
        {
          "line": 252,
          "content": "            return 0.8"
        },
        {
          "line": 253,
          "content": "        elif length > 100:"
        },
        {
          "line": 254,
          "content": "            return 0.5"
        },
        {
          "line": 256,
          "content": "            return 0.3"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/analytics/sentiment_analyzer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 13,
          "content": "\"\"\""
        },
        {
          "line": 22,
          "content": "    \"\"\""
        },
        {
          "line": 26,
          "content": "    \"\"\""
        },
        {
          "line": 43,
          "content": "        \"\"\"初始化分析器\"\"\""
        },
        {
          "line": 46,
          "content": "    def _validate_results(self, results: Any, method_name: str) -> None:"
        },
        {
          "line": 47,
          "content": "        \"\"\""
        },
        {
          "line": 56,
          "content": "        \"\"\""
        },
        {
          "line": 57,
          "content": "        if not isinstance(results, list):"
        },
        {
          "line": 65,
          "content": "        for i, result in enumerate(results):"
        },
        {
          "line": 66,
          "content": "            if not isinstance(result, dict):"
        },
        {
          "line": 74,
          "content": "    def analyze(self, results: List[Dict[str, Any]]) -> Dict[str, float]:"
        },
        {
          "line": 75,
          "content": "        \"\"\""
        },
        {
          "line": 97,
          "content": "        \"\"\""
        },
        {
          "line": 101,
          "content": "        if not results:"
        },
        {
          "line": 103,
          "content": "            return {"
        },
        {
          "line": 104,
          "content": "                'data': {label: 0.0 for label in self.SENTIMENT_LABELS},"
        },
        {
          "line": 111,
          "content": "        for result in results:"
        },
        {
          "line": 116,
          "content": "        for label in self.SENTIMENT_LABELS:"
        },
        {
          "line": 117,
          "content": "            if label not in sentiment_counts:"
        },
        {
          "line": 123,
          "content": "        for label in self.SENTIMENT_LABELS:"
        },
        {
          "line": 125,
          "content": "                sentiment_counts[label] / total * 100 if total > 0 else 0,"
        },
        {
          "line": 136,
          "content": "        return {"
        },
        {
          "line": 142,
          "content": "    def analyze_by_brand("
        },
        {
          "line": 146,
          "content": "        \"\"\""
        },
        {
          "line": 161,
          "content": "        \"\"\""
        },
        {
          "line": 162,
          "content": "        if not results:"
        },
        {
          "line": 163,
          "content": "            return {}"
        },
        {
          "line": 168,
          "content": "        for result in results:"
        },
        {
          "line": 175,
          "content": "        for brand, sentiment_counts in brand_sentiment_counts.items():"
        },
        {
          "line": 179,
          "content": "                    sentiment_counts.get(label, 0) / total * 100 if total > 0 else 0,"
        },
        {
          "line": 182,
          "content": "                for label in self.SENTIMENT_LABELS"
        },
        {
          "line": 186,
          "content": "        return distribution"
        },
        {
          "line": 188,
          "content": "    def analyze_by_model("
        },
        {
          "line": 192,
          "content": "        \"\"\""
        },
        {
          "line": 200,
          "content": "        \"\"\""
        },
        {
          "line": 201,
          "content": "        if not results:"
        },
        {
          "line": 202,
          "content": "            return {}"
        },
        {
          "line": 207,
          "content": "        for result in results:"
        },
        {
          "line": 214,
          "content": "        for model, sentiment_counts in model_sentiment_counts.items():"
        },
        {
          "line": 218,
          "content": "                    sentiment_counts.get(label, 0) / total * 100 if total > 0 else 0,"
        },
        {
          "line": 221,
          "content": "                for label in self.SENTIMENT_LABELS"
        },
        {
          "line": 225,
          "content": "        return distribution"
        },
        {
          "line": 227,
          "content": "    def calculate_sentiment_score("
        },
        {
          "line": 231,
          "content": "        \"\"\""
        },
        {
          "line": 244,
          "content": "        \"\"\""
        },
        {
          "line": 245,
          "content": "        if not results:"
        },
        {
          "line": 246,
          "content": "            return {"
        },
        {
          "line": 254,
          "content": "        for result in results:"
        },
        {
          "line": 257,
          "content": "            if isinstance(sentiment, (int, float)):"
        },
        {
          "line": 260,
          "content": "        if not scores:"
        },
        {
          "line": 261,
          "content": "            return {"
        },
        {
          "line": 268,
          "content": "        return {"
        },
        {
          "line": 275,
          "content": "    def get_positive_rate("
        },
        {
          "line": 280,
          "content": "        \"\"\""
        },
        {
          "line": 289,
          "content": "        \"\"\""
        },
        {
          "line": 290,
          "content": "        if not results:"
        },
        {
          "line": 291,
          "content": "            return 0.0"
        },
        {
          "line": 294,
          "content": "        for result in results:"
        },
        {
          "line": 296,
          "content": "            if sentiment > threshold:"
        },
        {
          "line": 299,
          "content": "        return round(positive_count / len(results) * 100, 2)"
        },
        {
          "line": 301,
          "content": "    def get_negative_rate("
        },
        {
          "line": 306,
          "content": "        \"\"\""
        },
        {
          "line": 315,
          "content": "        \"\"\""
        },
        {
          "line": 316,
          "content": "        if not results:"
        },
        {
          "line": 317,
          "content": "            return 0.0"
        },
        {
          "line": 320,
          "content": "        for result in results:"
        },
        {
          "line": 322,
          "content": "            if sentiment < threshold:"
        },
        {
          "line": 325,
          "content": "        return round(negative_count / len(results) * 100, 2)"
        },
        {
          "line": 327,
          "content": "    def compare_sentiment("
        },
        {
          "line": 333,
          "content": "        \"\"\""
        },
        {
          "line": 343,
          "content": "        \"\"\""
        },
        {
          "line": 344,
          "content": "        brand1_results = [r for r in results if r.get('brand') == brand1]"
        },
        {
          "line": 345,
          "content": "        brand2_results = [r for r in results if r.get('brand') == brand2]"
        },
        {
          "line": 353,
          "content": "        return {"
        },
        {
          "line": 367,
          "content": "                'winner': brand1 if brand1_score['avg_score'] > brand2_score['avg_score'] else brand2,"
        },
        {
          "line": 372,
          "content": "    def _extract_sentiment(self, result: Dict[str, Any]) -> str:"
        },
        {
          "line": 373,
          "content": "        \"\"\""
        },
        {
          "line": 381,
          "content": "        \"\"\""
        },
        {
          "line": 385,
          "content": "        if not isinstance(sentiment, (int, float)):"
        },
        {
          "line": 386,
          "content": "            return 'neutral'"
        },
        {
          "line": 389,
          "content": "        if sentiment > self.SENTIMENT_POSITIVE_THRESHOLD:"
        },
        {
          "line": 390,
          "content": "            return 'positive'"
        },
        {
          "line": 391,
          "content": "        elif sentiment < self.SENTIMENT_NEGATIVE_THRESHOLD:"
        },
        {
          "line": 392,
          "content": "            return 'negative'"
        },
        {
          "line": 394,
          "content": "            return 'neutral'"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/models/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Data models for the cleaning pipeline."
        },
        {
          "line": 5,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/models/pipeline_context.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Data structure for passing data and state during pipeline execution."
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "    \"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\""
        },
        {
          "line": 48,
          "content": "        \"\"\"Add step result to intermediate data\"\"\""
        },
        {
          "line": 53,
          "content": "    def add_warning(self, message: str):"
        },
        {
          "line": 54,
          "content": "        \"\"\"Add warning\"\"\""
        },
        {
          "line": 58,
          "content": "        \"\"\"Add error\"\"\""
        },
        {
          "line": 61,
          "content": "    def get_intermediate(self, step_name: str, key: str, default=None):"
        },
        {
          "line": 62,
          "content": "        \"\"\"Get intermediate data\"\"\""
        },
        {
          "line": 67,
          "content": "        \"\"\"Convert to dictionary (for logging)\"\"\""
        },
        {
          "line": 68,
          "content": "        return {"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/models/cleaned_data.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 14,
          "content": "    \"\"\"Entity mention information\"\"\""
        },
        {
          "line": 24,
          "content": "class GeoPreparedData:"
        },
        {
          "line": 25,
          "content": "    \"\"\"GEO analysis prepared data\"\"\""
        },
        {
          "line": 38,
          "content": "    \"\"\"Quality score\"\"\""
        },
        {
          "line": 48,
          "content": "class CleanedData:"
        },
        {
          "line": 49,
          "content": "    \"\"\""
        },
        {
          "line": 54,
          "content": "    \"\"\""
        },
        {
          "line": 87,
          "content": "    def to_dict(self) -> Dict[str, Any]:"
        },
        {
          "line": 88,
          "content": "        \"\"\"Convert to dictionary (for storage)\"\"\""
        },
        {
          "line": 131,
          "content": "        \"\"\""
        },
        {
          "line": 132,
          "content": "        Create cleaned data object from raw response (initialization)"
        },
        {
          "line": 135,
          "content": "        \"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/steps/validator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\""
        },
        {
          "line": 20,
          "content": "    \"\"\""
        },
        {
          "line": 39,
          "content": "        \"\"\"Execute validation\"\"\""
        },
        {
          "line": 43,
          "content": "        if not text:"
        },
        {
          "line": 44,
          "content": "            context.add_warning(\"Empty text for validation\")"
        },
        {
          "line": 45,
          "content": "            return context"
        },
        {
          "line": 51,
          "content": "        for rule in self.config['rules']:"
        },
        {
          "line": 53,
          "content": "            if rule_method:"
        },
        {
          "line": 59,
          "content": "                if not is_valid:"
        },
        {
          "line": 73,
          "content": "        for issue in issues:"
        },
        {
          "line": 76,
          "content": "        return context"
        },
        {
          "line": 78,
          "content": "    def _validate_min_length(self, text: str, context: PipelineContext) -> Tuple[bool, str]:"
        },
        {
          "line": 79,
          "content": "        \"\"\"Validate minimum length\"\"\""
        },
        {
          "line": 86,
          "content": "        \"\"\"Validate maximum length\"\"\""
        },
        {
          "line": 88,
          "content": "        if len(text) > max_len:"
        },
        {
          "line": 89,
          "content": "            return False, f\"Text too long: {len(text)} > {max_len}\""
        },
        {
          "line": 90,
          "content": "        return True, \"OK\""
        },
        {
          "line": 92,
          "content": "    def _validate_no_empty(self, text: str, context: PipelineContext) -> Tuple[bool, str]:"
        },
        {
          "line": 93,
          "content": "        \"\"\"Validate non-empty\"\"\""
        },
        {
          "line": 99,
          "content": "        \"\"\"Validate encoding is valid\"\"\""
        },
        {
          "line": 101,
          "content": "            # Try encode then decode, check if consistent"
        },
        {
          "line": 104,
          "content": "            if decoded != text:"
        },
        {
          "line": 105,
          "content": "                return False, \"Encoding mismatch\""
        },
        {
          "line": 106,
          "content": "            return True, \"OK\""
        },
        {
          "line": 108,
          "content": "            return False, f\"Invalid encoding: {str(e)}\""
        },
        {
          "line": 110,
          "content": "    def _validate_no_invalid_chars(self, text: str, context: PipelineContext) -> Tuple[bool, str]:"
        },
        {
          "line": 111,
          "content": "        \"\"\"Validate no invalid characters\"\"\""
        },
        {
          "line": 124,
          "content": "        \"\"\"Skip if text is empty\"\"\""
        },
        {
          "line": 125,
          "content": "        return not context.response_content"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/steps/geo_preparer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Prepares基础 data for subsequent GEO (Generative Engine Optimization) analysis."
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "    \"\"\""
        },
        {
          "line": 20,
          "content": "    Prepares基础 data for subsequent GEO analysis,"
        },
        {
          "line": 22,
          "content": "    \"\"\""
        },
        {
          "line": 35,
          "content": "        \"\"\"Execute GEO data preparation\"\"\""
        },
        {
          "line": 39,
          "content": "        if not text:"
        },
        {
          "line": 40,
          "content": "            context.add_warning(\"Empty text for GEO preparation\")"
        },
        {
          "line": 41,
          "content": "            return context"
        },
        {
          "line": 43,
          "content": "        # 2. Get brand positions from entity recognition step"
        },
        {
          "line": 50,
          "content": "            sentence_count=self._count_sentences(text) if self.config['split_sentences'] else 1,"
        },
        {
          "line": 54,
          "content": "            language=self._detect_language(text) if self.config['detect_language'] else 'zh',"
        },
        {
          "line": 55,
          "content": "            contains_numbers=self._contains_numbers(text) if self.config['extract_numbers'] else False,"
        },
        {
          "line": 56,
          "content": "            contains_urls=self._contains_urls(text) if self.config['extract_urls'] else False,"
        },
        {
          "line": 60,
          "content": "        for entity in entities:"
        },
        {
          "line": 61,
          "content": "            if entity['entity_type'] == 'brand':"
        },
        {
          "line": 64,
          "content": "            elif entity['entity_type'] == 'competitor':"
        },
        {
          "line": 85,
          "content": "        return context"
        },
        {
          "line": 87,
          "content": "    def _count_sentences(self, text: str) -> int:"
        },
        {
          "line": 88,
          "content": "        \"\"\"Count sentence count\"\"\""
        },
        {
          "line": 99,
          "content": "        \"\"\"Detect language (simplified version)\"\"\""
        },
        {
          "line": 100,
          "content": "        # Check if contains Chinese characters"
        },
        {
          "line": 101,
          "content": "        if re.search(r'[\\u4e00-\\u9fff]', text):"
        },
        {
          "line": 102,
          "content": "            return 'zh'"
        },
        {
          "line": 103,
          "content": "        # Check if mainly English letters"
        },
        {
          "line": 104,
          "content": "        elif re.match(r'^[a-zA-Z\\s,.!?]+$', text[:100]):"
        },
        {
          "line": 105,
          "content": "            return 'en'"
        },
        {
          "line": 107,
          "content": "            return 'unknown'"
        },
        {
          "line": 109,
          "content": "    def _contains_numbers(self, text: str) -> bool:"
        },
        {
          "line": 110,
          "content": "        \"\"\"Whether contains numbers\"\"\""
        },
        {
          "line": 114,
          "content": "        \"\"\"Whether contains URL\"\"\""
        },
        {
          "line": 116,
          "content": "        return bool(re.search(url_pattern, text))"
        },
        {
          "line": 118,
          "content": "    def should_skip(self, context: PipelineContext) -> bool:"
        },
        {
          "line": 119,
          "content": "        \"\"\"Skip if no text\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/steps/quality_scorer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 16,
          "content": "    \"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 40,
          "content": "        \"\"\"Execute quality scoring\"\"\""
        },
        {
          "line": 44,
          "content": "        if not text:"
        },
        {
          "line": 45,
          "content": "            context.add_warning(\"Empty text for quality scoring\")"
        },
        {
          "line": 46,
          "content": "            return context"
        },
        {
          "line": 69,
          "content": "        if length_score < 30:"
        },
        {
          "line": 71,
          "content": "        elif length_score > 95:"
        },
        {
          "line": 74,
          "content": "        if completeness_score < 50:"
        },
        {
          "line": 77,
          "content": "        if relevance_score < 30:"
        },
        {
          "line": 80,
          "content": "        # 6. Get existing issues from validation step"
        },
        {
          "line": 81,
          "content": "        if validation_result:"
        },
        {
          "line": 109,
          "content": "        # 9. Add warnings to context if any"
        },
        {
          "line": 110,
          "content": "        for warning in warnings:"
        },
        {
          "line": 113,
          "content": "        return context"
        },
        {
          "line": 115,
          "content": "    def _calculate_length_score(self, text: str) -> float:"
        },
        {
          "line": 116,
          "content": "        \"\"\"Calculate length score\"\"\""
        },
        {
          "line": 137,
          "content": "        \"\"\"Calculate completeness score\"\"\""
        },
        {
          "line": 140,
          "content": "        # Check if has entities"
        },
        {
          "line": 142,
          "content": "        if entities:"
        },
        {
          "line": 146,
          "content": "        if len(text) > 100:"
        },
        {
          "line": 150,
          "content": "        return min(100, max(0, score))"
        },
        {
          "line": 152,
          "content": "    def _calculate_relevance_score(self, text: str, context: PipelineContext) -> float:"
        },
        {
          "line": 153,
          "content": "        \"\"\"Calculate relevance score (simplified)\"\"\""
        },
        {
          "line": 156,
          "content": "        # Check if contains brand name"
        },
        {
          "line": 160,
          "content": "        # Check if contains keywords from question"
        },
        {
          "line": 169,
          "content": "        \"\"\"Extract keywords from question (simplified)\"\"\""
        },
        {
          "line": 173,
          "content": "        return [w for w in words if len(w) > 1][:5]"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/steps/deduplicator.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 15,
          "content": "    \"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 29,
          "content": "        # Hash store for cross-task deduplication (should use Redis in production)"
        },
        {
          "line": 33,
          "content": "        \"\"\"Execute deduplication detection\"\"\""
        },
        {
          "line": 37,
          "content": "        if not text:"
        },
        {
          "line": 38,
          "content": "            context.add_warning(\"Empty text for deduplication\")"
        },
        {
          "line": 39,
          "content": "            return context"
        },
        {
          "line": 42,
          "content": "        if self.config['method'] == 'exact_hash':"
        },
        {
          "line": 47,
          "content": "        # 3. Check if duplicate"
        },
        {
          "line": 59,
          "content": "        # 5. Add warning if duplicate"
        },
        {
          "line": 60,
          "content": "        if is_duplicate:"
        },
        {
          "line": 63,
          "content": "        return context"
        },
        {
          "line": 65,
          "content": "    def _compute_exact_hash(self, text: str) -> str:"
        },
        {
          "line": 66,
          "content": "        \"\"\"Compute exact hash\"\"\""
        },
        {
          "line": 72,
          "content": "        \"\"\"Compute SimHash (simplified version)\"\"\""
        },
        {
          "line": 78,
          "content": "        for chunk in chunks:"
        },
        {
          "line": 84,
          "content": "        return hashlib.sha256(combined.encode('utf-8')).hexdigest()"
        },
        {
          "line": 86,
          "content": "    def _normalize_text(self, text: str) -> str:"
        },
        {
          "line": 87,
          "content": "        \"\"\"Normalize text (for deduplication preprocessing)\"\"\""
        },
        {
          "line": 98,
          "content": "        \"\"\"Split text into chunks\"\"\""
        },
        {
          "line": 102,
          "content": "        for i in range(0, len(words), chunk_size):"
        },
        {
          "line": 106,
          "content": "        return chunks"
        },
        {
          "line": 108,
          "content": "    def _check_duplicate(self, content_hash: str, context: PipelineContext) -> bool:"
        },
        {
          "line": 109,
          "content": "        \"\"\"Check if duplicate\"\"\""
        },
        {
          "line": 110,
          "content": "        # Check if duplicate in current context"
        },
        {
          "line": 118,
          "content": "        # Store hash for future use"
        },
        {
          "line": 127,
          "content": "        \"\"\"Skip if text is empty\"\"\""
        },
        {
          "line": 128,
          "content": "        return not context.response_content"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/steps/text_extractor.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Extracts plain text from raw AI responses."
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 17,
          "content": "    \"\"\""
        },
        {
          "line": 20,
          "content": "    Extracts pure text from raw responses, handling:"
        },
        {
          "line": 25,
          "content": "    \"\"\""
        },
        {
          "line": 38,
          "content": "        \"\"\"Execute text extraction\"\"\""
        },
        {
          "line": 41,
          "content": "            # 1. Get raw text (from context.response_content)"
        },
        {
          "line": 44,
          "content": "            if not raw_text:"
        },
        {
          "line": 51,
          "content": "                return context"
        },
        {
          "line": 58,
          "content": "            if self.config['strip_html']:"
        },
        {
          "line": 61,
          "content": "            if self.config['unescape_html']:"
        },
        {
          "line": 64,
          "content": "            if self.config['normalize_whitespace']:"
        },
        {
          "line": 68,
          "content": "            if len(cleaned_text) > self.config['max_length']:"
        },
        {
          "line": 73,
          "content": "            if len(cleaned_text) < self.config['min_length']:"
        },
        {
          "line": 90,
          "content": "            return context"
        },
        {
          "line": 100,
          "content": "    def _strip_html(self, text: str) -> str:"
        },
        {
          "line": 101,
          "content": "        \"\"\"Remove HTML tags\"\"\""
        },
        {
          "line": 107,
          "content": "        \"\"\"Unescape HTML entities\"\"\""
        },
        {
          "line": 108,
          "content": "        return html.unescape(text)"
        },
        {
          "line": 110,
          "content": "    def _normalize_whitespace(self, text: str) -> str:"
        },
        {
          "line": 111,
          "content": "        \"\"\"Normalize whitespace\"\"\""
        },
        {
          "line": 119,
          "content": "        \"\"\"Validate input\"\"\""
        },
        {
          "line": 120,
          "content": "        if not context.response_content:"
        },
        {
          "line": 122,
          "content": "            return False"
        },
        {
          "line": 123,
          "content": "        return True"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/steps/__init__.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Individual cleaning steps for the pipeline."
        },
        {
          "line": 5,
          "content": "\"\"\""
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/steps/entity_recognizer.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 18,
          "content": "    \"\"\""
        },
        {
          "line": 23,
          "content": "    \"\"\""
        },
        {
          "line": 35,
          "content": "        \"\"\"Execute entity recognition\"\"\""
        },
        {
          "line": 40,
          "content": "            if not text:"
        },
        {
          "line": 41,
          "content": "                context.add_warning(\"Empty text for entity recognition\")"
        },
        {
          "line": 42,
          "content": "                return context"
        },
        {
          "line": 48,
          "content": "            # Competitors (need to get from config or context)"
        },
        {
          "line": 49,
          "content": "            # Simplified here, actual implementation may query from report table"
        },
        {
          "line": 60,
          "content": "            for competitor in competitors:"
        },
        {
          "line": 69,
          "content": "            if len(entities) > self.config['max_entities']:"
        },
        {
          "line": 84,
          "content": "                    for e in entities"
        },
        {
          "line": 87,
          "content": "                'brand_mentions': sum(1 for e in entities if e.entity_type == 'brand'),"
        },
        {
          "line": 88,
          "content": "                'competitor_mentions': sum(1 for e in entities if e.entity_type == 'competitor'),"
        },
        {
          "line": 93,
          "content": "            return context"
        },
        {
          "line": 103,
          "content": "    def _find_entity(self, text: str, entity_name: str, entity_type: str) -> List[EntityMention]:"
        },
        {
          "line": 104,
          "content": "        \"\"\"Find entity in text\"\"\""
        },
        {
          "line": 140,
          "content": "        \"\"\"Get competitor list\"\"\""
        },
        {
          "line": 141,
          "content": "        # Get from context config"
        },
        {
          "line": 142,
          "content": "        # Actual implementation may query from database"
        },
        {
          "line": 143,
          "content": "        # Here simplified to read from config"
        },
        {
          "line": 144,
          "content": "        return self.config.get('competitors', [])"
        },
        {
          "line": 146,
          "content": "    def _deduplicate_entities(self, entities: List[EntityMention]) -> List[EntityMention]:"
        },
        {
          "line": 147,
          "content": "        \"\"\"Deduplicate (same position same entity only kept once)\"\"\""
        },
        {
          "line": 160,
          "content": "        \"\"\"Skip if no competitor configuration\"\"\""
        },
        {
          "line": 161,
          "content": "        return len(self._get_competitors(context)) == 0 and not context.brand"
        }
      ]
    },
    {
      "file": "/Users/sgl/PycharmProjects/PythonProject/backend_python/wechat_backend/v2/cleaning/steps/base.py",
      "lines": [
        {
          "line": 1,
          "content": "\"\"\""
        },
        {
          "line": 4,
          "content": "Abstract base class for all cleaning steps."
        },
        {
          "line": 5,
          "content": "\"\"\""
        },
        {
          "line": 19,
          "content": "    \"\"\""
        },
        {
          "line": 22,
          "content": "    All specific cleaning steps must inherit from this class"
        },
        {
          "line": 28,
          "content": "    \"\"\""
        },
        {
          "line": 31,
          "content": "        \"\"\""
        },
        {
          "line": 35,
          "content": "            name: Step name (for logging and tracing)"
        },
        {
          "line": 37,
          "content": "        \"\"\""
        },
        {
          "line": 43,
          "content": "        \"\"\""
        },
        {
          "line": 54,
          "content": "        \"\"\""
        },
        {
          "line": 58,
          "content": "        \"\"\""
        },
        {
          "line": 62,
          "content": "        \"\"\""
        },
        {
          "line": 66,
          "content": "        \"\"\""
        },
        {
          "line": 67,
          "content": "        Determine if this step should be skipped"
        },
        {
          "line": 70,
          "content": "        \"\"\""
        },
        {
          "line": 74,
          "content": "        \"\"\""
        },
        {
          "line": 75,
          "content": "        Get this step's result from context"
        },
        {
          "line": 77,
          "content": "        Used for data passing between steps"
        },
        {
          "line": 78,
          "content": "        \"\"\""
        },
        {
          "line": 82,
          "content": "        \"\"\""
        },
        {
          "line": 84,
          "content": "        \"\"\""
        },
        {
          "line": 88,
          "content": "        \"\"\"Record step start (structured logging)\"\"\""
        },
        {
          "line": 98,
          "content": "    def log_step_complete(self, context: PipelineContext, duration_ms: float):"
        },
        {
          "line": 99,
          "content": "        \"\"\"Record step completion\"\"\""
        },
        {
          "line": 112,
          "content": "        \"\"\"Record step error\"\"\""
        }
      ]
    }
  ],
  "total_stats": {
    "debug_files_found": 2,
    "commented_code_lines": 9886,
    "duplicate_functions": 0,
    "unused_imports": 0
  }
}