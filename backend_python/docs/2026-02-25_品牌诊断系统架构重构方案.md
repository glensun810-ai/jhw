# 品牌诊断系统架构重构方案

**文档编号**: ARCH-20260225-001  
**版本**: 2.0  
**制定日期**: 2026-02-25  
**首席架构师**: AI Architect  
**审核状态**: 待实施  

---

## 目录

1. [执行摘要](#执行摘要)
2. [当前架构深度诊断](#当前架构深度诊断)
3. [目标架构设计](#目标架构设计)
4. [数据流全景图](#数据流全景图)
5. [存储架构重构](#存储架构重构)
6. [容错与降级策略](#容错与降级策略)
7. [实施路线图](#实施路线图)

---

## 执行摘要

### 核心问题

当前品牌诊断系统存在**3大致命缺陷**，导致 62.5% 的诊断任务无法生成完整报告：

1. **数据持久化断裂** - 关键中间结果未存储，任务失败后无法恢复
2. **部分失败处理缺失** - 单个数据源失败导致整个报告生成中断
3. **历史报告一致性无保障** - 未采用快照存储，历史报告可能随时间变化

### 重构目标

| 目标 | 当前状态 | 目标状态 | 衡量指标 |
|------|---------|---------|---------|
| 报告生成成功率 | 37.5% | ≥99% | 用户看到报告的概率 |
| 部分失败支持 | ❌ | ✅ | 单模块失败不影响整体 |
| 历史报告一致性 | ❌ | ✅ | 快照存储，永久一致 |
| 数据持久化完整率 | 0% | 100% | 关键数据全部落库 |

### 核心技术选型

- **存储格式**: JSON 快照（完美支持结构化数据、版本控制）
- **数据库**: SQLite（当前）→ PostgreSQL JSONB（推荐升级）
- **容错策略**: Try-Catch 包裹每个外部调用 + 优雅降级
- **数据一致性**: 写时快照（Write-Time Snapshot）

---

## 当前架构深度诊断

### 2.1 完整数据流分析

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     当前品牌诊断数据流（存在缺陷）                       │
└─────────────────────────────────────────────────────────────────────────┘

[1] 用户点击"生成诊断" (小程序前端)
    │ 输入：brandList, selectedModels, customQuestions
    │ 输出：execution_id
    ▼
[2] POST /api/perform-brand-test (diagnosis_views.py:91)
    │ ✅ 请求接收正常
    │ ✅ 参数验证通过
    ▼
[3] 创建 execution_store 内存记录 (diagnosis_views.py:272)
    │ ⚠️ 仅在内存中，服务重启后丢失
    ▼
[4] 调用 execute_nxm_test() (nxm_execution_engine.py:54)
    │ ✅ NxM 执行引擎初始化
    ▼
[5] 创建 NxMScheduler (nxm_scheduler.py:38)
    │ ✅ 调度器初始化
    │ ✅ 超时计时器启动
    ▼
[6] 遍历品牌 × 问题 × 模型 (nxm_execution_engine.py:120)
    │ ✅ 任务拆解正确
    ▼
[7] 调用 AI 适配器.send_prompt() (nxm_execution_engine.py:174)
    │ ❌ 高频失败点：'DoubaoPriorityAdapter' object has no attribute 'generate_response'
    │ ❌ 失败后无降级处理
    ▼
[8] 解析 GEO 响应 (nxm_result_aggregator.py:54)
    │ ⚠️ 解析失败时返回错误，但未阻断流程
    ▼
[9] 结果添加到 execution_store (nxm_scheduler.py:92)
    │ ⚠️ 仅在内存中，未持久化
    ▼
[10] 更新进度 (nxm_scheduler.py:68)
    │ ⚠️ 仅在内存中，前端轮询可能获取不到
    ▼
[11] 执行完成 (nxm_scheduler.py:98)
    │ ⚠️ 未写入 diagnosis_reports 表
    │ ⚠️ 未写入 brand_test_results 表
    │ ⚠️ 未写入 deep_intelligence_results 表
    ▼
[12] 返回 execution_id 给前端
    │ ✅ 返回成功
    ▼
[13] 前端轮询 /test/status/{execution_id}
    │ ❌ task_statuses 表为空，返回"not_found"
    ▼
[14] 前端查询 /api/diagnosis/report/{execution_id}
    │ ❌ 无报告数据，无法展示
```

### 2.2 脆弱点标记

| 环节 | 脆弱点 | 影响 | 当前状态 |
|------|--------|------|---------|
| [3] execution_store | 纯内存存储 | 服务重启数据丢失 | ❌ |
| [7] AI 适配器调用 | 方法不存在 | 100% 任务失败 | ❌ |
| [9] 结果存储 | 未持久化 | 进度追踪失效 | ❌ |
| [10] 进度更新 | 未持久化 | 前端显示空白 | ❌ |
| [11] 完成处理 | 未写数据库 | 报告无法查询 | ❌ |

### 2.3 根本原因分析（5 Why 法）

**问题**: 62.5% 的诊断任务无法生成报告

1. **Why 1**: 为什么任务无法完成？
   - 因为 AI 适配器调用失败后，后续流程全部中断

2. **Why 2**: 为什么 AI 调用失败？
   - 因为 `DoubaoPriorityAdapter` 缺少 `generate_response` 方法

3. **Why 3**: 为什么方法缺失会导致整个流程中断？
   - 因为没有 try-catch 包裹，异常直接抛出

4. **Why 4**: 为什么没有 try-catch？
   - 因为设计时假设所有外部调用都会成功

5. **Why 5**: 为什么没有持久化中间结果？
   - 因为架构设计时未考虑"部分失败"场景

**根本原因**: **架构设计缺陷** - 缺乏容错机制和持久化策略

---

## 目标架构设计

### 3.1 架构原则

1. **结果产出绝对优先** - 任何错误都不能阻止返回报告
2. **优雅降级** - 部分失败时返回可用结果
3. **错误透明化** - 明确标注失败原因和解决建议
4. **用户第一** - 用户体验优先于技术完美性
5. **数据持久化** - 所有关键数据必须落库

### 3.2 新架构全景图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      品牌诊断系统新架构（目标状态）                      │
└─────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────┐
│                            前端层 (小程序)                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │
│  │  生成诊断   │  │  进度轮询   │  │  报告展示   │  │  历史报告   │  │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘  │
└───────────────────────────────────────────────────────────────────────┘
         │                    │                    │                    │
         ▼                    ▼                    ▼                    ▼
┌───────────────────────────────────────────────────────────────────────┐
│                            API 网关层                                  │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │  /api/perform-brand-test  │  /test/status  │  /api/diagnosis   │  │
│  │  /api/diagnosis/history   │  /report/pdf   │                   │  │
│  └─────────────────────────────────────────────────────────────────┘  │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │  认证鉴权  │  限流熔断  │  输入验证  │  日志审计                │  │
│  └─────────────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────────────┘
         │
         ▼
┌───────────────────────────────────────────────────────────────────────┐
│                          业务服务层                                    │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │                    DiagnosisService                             │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │  │
│  │  │  启动诊断    │  │  查询进度    │  │  获取报告     │          │  │
│  │  └──────────────┘  └──────────────┘  └──────────────┘          │  │
│  └─────────────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────────────┘
         │
         ▼
┌───────────────────────────────────────────────────────────────────────┐
│                          执行引擎层                                    │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │                  NxMExecutionEngine                             │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │  │
│  │  │  任务调度    │  │  容错执行    │  │  结果聚合    │          │  │
│  │  │  (Scheduler) │  │  (Executor)  │  │ (Aggregator) │          │  │
│  │  └──────────────┘  └──────────────┘  └──────────────┘          │  │
│  └─────────────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────────────┘
         │
         ▼
┌───────────────────────────────────────────────────────────────────────┐
│                          数据适配层                                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────┐  │
│  │ AI 适配器    │  │ 舆情 API     │  │ 搜索 API     │  │ 其他 API  │  │
│  │ (Adapter)    │  │ (Weibo)      │  │ (Baidu)      │  │          │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  └──────────┘  │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │              统一接口：fetch_data(brand_name)                   │  │
│  │              返回：{status, data, error_message}                │  │
│  └─────────────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────────────┘
         │
         ▼
┌───────────────────────────────────────────────────────────────────────┐
│                          持久化层                                      │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │                    SQLite/PostgreSQL                            │  │
│  │  ┌──────────────────┐  ┌──────────────────┐                    │  │
│  │  │ diagnosis_reports│  │ report_snapshots │                    │  │
│  │  │ (报告元数据)     │  │ (报告内容快照)   │                    │  │
│  │  └──────────────────┘  └──────────────────┘                    │  │
│  │  ┌──────────────────┐  ┌──────────────────┐                    │  │
│  │  │ task_statuses    │  │ dim_results      │                    │  │
│  │  │ (任务进度)       │  │ (维度结果)       │                    │  │
│  │  └──────────────────┘  └──────────────────┘                    │  │
│  └─────────────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────────────┘
```

### 3.3 核心组件职责

| 组件 | 职责 | 关键方法 |
|------|------|---------|
| **DiagnosisService** | 业务编排 | `start_diagnosis()`, `get_status()`, `get_result()` |
| **NxMExecutionEngine** | 任务执行 | `execute_nxm_test()` |
| **NxMScheduler** | 任务调度 | `initialize_execution()`, `update_progress()` |
| **FaultTolerantExecutor** | 容错执行 | `execute_with_fallback()` |
| **ResultAggregator** | 结果聚合 | `aggregate_results()`, `verify_completion()` |
| **ReportSnapshotRepository** | 快照存储 | `save_snapshot()`, `get_snapshot()` |

---

## 数据流全景图

### 4.1 正常流程数据流

```
用户请求
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ 1. API 接收 (diagnosis_views.py)                             │
│    - 验证参数                                                │
│    - 生成 execution_id                                       │
│    - 创建 diagnosis_reports 记录 (status=processing)          │
└─────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. 启动异步任务 (Thread/Async)                              │
│    - 不阻塞 API 响应                                         │
│    - 立即返回 execution_id                                  │
└─────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. NxM 执行引擎 (nxm_execution_engine.py)                    │
│    - 拆解任务：品牌 × 问题 × 模型                             │
│    - 创建 task_statuses 记录 (progress=0)                   │
└─────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. 容错执行器 (fault_tolerant_executor.py)                  │
│    - 遍历每个子任务                                          │
│    - try-catch 包裹每个外部调用                              │
│    - 成功：记录结果                                          │
│    - 失败：记录错误，继续下一个                              │
└─────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. 实时持久化                                                │
│    - 每个维度结果 → dim_results 表                            │
│    - 进度更新 → task_statuses 表                              │
└─────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. 结果聚合 (result_aggregator.py)                           │
│    - 计算总体评分                                            │
│    - 生成报告结构                                            │
│    - 标记失败维度                                            │
└─────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ 7. 快照存储 (report_snapshot_repository.py)                 │
│    - 完整报告 → report_snapshots 表 (JSON)                   │
│    - 更新 diagnosis_reports (status=completed)              │
└─────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ 8. 前端轮询                                                  │
│    - GET /test/status/{execution_id} → 返回进度              │
│    - GET /api/diagnosis/report/{execution_id} → 返回报告    │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 部分失败流程

```
某个 AI API 调用失败
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ try-catch 捕获异常                                           │
│    - 记录详细错误日志                                        │
│    - 生成用户友好错误信息                                    │
│    - 标记该维度 status='failed'                             │
│    - errorMessage="AI 平台响应超时，请稍后重试"               │
└─────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ 继续执行下一个任务                                           │
│    - 不影响其他维度                                          │
│    - 不中断整体流程                                          │
└─────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ 聚合结果                                                     │
│    - 成功维度：正常展示数据                                  │
│    - 失败维度：显示错误提示                                  │
│    - 总体评分：仅计算成功维度                                │
└─────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│ 生成报告                                                     │
│    - 报告状态：completed_with_warnings                       │
│    - 前端展示：成功模块正常，失败模块显示提醒框              │
└─────────────────────────────────────────────────────────────┘
```

---

## 存储架构重构

### 5.1 核心 Schema 设计

#### 5.1.1 diagnosis_reports (报告元数据表)

```sql
CREATE TABLE diagnosis_reports (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    execution_id TEXT UNIQUE NOT NULL,
    user_id TEXT NOT NULL,
    brand_name TEXT NOT NULL,
    competitor_brands TEXT NOT NULL,  -- JSON 数组
    selected_models TEXT NOT NULL,    -- JSON 数组
    custom_questions TEXT NOT NULL,   -- JSON 数组
    
    -- 状态追踪
    status TEXT NOT NULL DEFAULT 'processing',  -- processing, completed, completed_with_warnings, failed
    progress INTEGER NOT NULL DEFAULT 0,
    stage TEXT NOT NULL DEFAULT 'init',
    is_completed BOOLEAN NOT NULL DEFAULT 0,
    
    -- 时间戳
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    completed_at TEXT,
    
    -- 版本控制
    report_version TEXT DEFAULT 'v1.0',
    
    -- 索引
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);
```

#### 5.1.2 report_snapshots (报告内容快照表) - **核心表**

```sql
CREATE TABLE report_snapshots (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    execution_id TEXT UNIQUE NOT NULL,
    report_data TEXT NOT NULL,  -- JSON 格式完整报告
    report_hash TEXT NOT NULL,  -- SHA256 哈希，用于一致性验证
    
    -- 元数据
    size_kb INTEGER NOT NULL,
    storage_timestamp TEXT NOT NULL,
    
    -- 索引
    INDEX idx_execution_id (execution_id),
    FOREIGN KEY (execution_id) REFERENCES diagnosis_reports(execution_id)
);
```

**report_data JSON 结构**:
```json
{
  "reportId": "rep_20260225_123456_abc",
  "userId": "user_12345",
  "brandName": "华为",
  "generateTime": "2026-02-25T10:30:00Z",
  "reportVersion": "v1.0",
  "requestParams": {
    "industry": "科技",
    "competitorCount": 3
  },
  "reportData": {
    "overallScore": 85,
    "overallStatus": "completed_with_warnings",
    "dimensions": [
      {
        "name": "社交媒体影响力",
        "score": 90,
        "source": "weibo_api",
        "data": {
          "mentionCount": 12500,
          "sentiment": "positive",
          "topPosts": [...]
        },
        "status": "success",
        "errorMessage": null
      },
      {
        "name": "新闻舆情",
        "score": null,
        "source": "news_api",
        "data": null,
        "status": "failed",
        "errorMessage": "【提醒】新闻 API 配额已用尽，请联系客服充值或明日再试。"
      }
    ],
    "rawResponses": {
      "weibo_api": { ... }
    }
  },
  "storageMeta": {
    "sizeKB": 15,
    "checksum": "sha256:abc123..."
  }
}
```

#### 5.1.3 task_statuses (任务进度表)

```sql
CREATE TABLE task_statuses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id TEXT UNIQUE NOT NULL,  -- execution_id
    progress INTEGER NOT NULL DEFAULT 0,
    stage TEXT NOT NULL,  -- init, ai_fetching, intelligence_analyzing, completed, failed
    status_text TEXT,
    completed_count INTEGER DEFAULT 0,
    total_count INTEGER DEFAULT 0,
    is_completed BOOLEAN DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_task_id (task_id)
);
```

#### 5.1.4 dimension_results (维度结果表)

```sql
CREATE TABLE dimension_results (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    execution_id TEXT NOT NULL,
    dimension_name TEXT NOT NULL,
    dimension_type TEXT NOT NULL,  -- social_media, news, ai_summary, etc.
    source TEXT NOT NULL,
    
    -- 结果数据
    status TEXT NOT NULL,  -- success, failed
    score REAL,
    data TEXT,  -- JSON 格式详细数据
    error_message TEXT,
    
    -- 元数据
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_execution_id (execution_id),
    FOREIGN KEY (execution_id) REFERENCES diagnosis_reports(execution_id)
);
```

### 5.2 存储策略对比

| 策略 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **JSON 快照** | 结构灵活、易扩展、版本友好 | 查询性能略低 | ✅ 推荐用于报告内容 |
| **关系型表** | 查询高效、支持复杂 SQL | 结构变更困难 | ✅ 推荐用于元数据 |
| **对象存储** | 成本低、无限扩展 | 需要额外服务 | 未来数据量大时 |
| **纯内存** | 速度最快 | 服务重启丢失 | ❌ 不推荐用于关键数据 |

### 5.3 数据一致性保障

#### 5.3.1 写时快照（Write-Time Snapshot）

```python
def save_report_snapshot(execution_id: str, report_data: Dict[str, Any]):
    """保存报告快照"""
    # 1. 序列化报告数据
    report_json = json.dumps(report_data, ensure_ascii=False)
    
    # 2. 计算哈希（用于一致性验证）
    report_hash = hashlib.sha256(report_json.encode('utf-8')).hexdigest()
    
    # 3. 计算大小
    size_kb = len(report_json) // 1024
    
    # 4. 保存到数据库
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO report_snapshots (execution_id, report_data, report_hash, size_kb, storage_timestamp)
            VALUES (?, ?, ?, ?, ?)
        ''', (execution_id, report_json, report_hash, size_kb, datetime.now().isoformat()))
    
    # 5. 更新 diagnosis_reports 状态
    update_diagnosis_status(execution_id, 'completed')
```

#### 5.3.2 一致性验证

```python
def verify_snapshot_consistency(execution_id: str) -> bool:
    """验证快照一致性"""
    # 1. 获取存储的快照
    snapshot = get_snapshot(execution_id)
    
    # 2. 重新计算哈希
    current_hash = hashlib.sha256(snapshot['report_data'].encode('utf-8')).hexdigest()
    
    # 3. 对比哈希
    return current_hash == snapshot['report_hash']
```

---

## 容错与降级策略

### 6.1 部分失败（Partial Failure）策略

```python
async def generate_diagnosis_report(user_id: str, brand_name: str) -> Dict[str, Any]:
    """生成诊断报告（带部分失败支持）"""
    
    # 1. 初始化空的报告数据结构
    final_report_data = {
        "brandName": brand_name,
        "generateTime": datetime.utcnow(),
        "dimensions": [],
        "overallStatus": "success"
    }
    
    # 2. 定义所有需要获取数据的子任务
    tasks = [
        {"name": "社交媒体分析", "func": fetch_social_media_data, "source": "weibo"},
        {"name": "新闻舆情分析", "func": fetch_news_data, "source": "baidu_news"},
        {"name": "AI 总结", "func": call_ai_summary, "source": "openai"},
    ]
    
    # 3. 并发或串行执行所有任务，但使用 try-except 包裹每一个
    for task in tasks:
        dimension_result = {
            "name": task["name"],
            "source": task["source"],
            "data": None,
            "status": "failed",  # 默认失败
            "errorMessage": None,
            "score": None
        }
        
        try:
            # 设置超时时间，防止外部调用卡死整个进程
            raw_data = await asyncio.wait_for(task["func"](brand_name), timeout=10.0)
            
            # 尝试解析和清洗数据
            processed_data = parse_data(raw_data, task["name"])
            
            # 如果成功，更新状态
            dimension_result["status"] = "success"
            dimension_result["data"] = processed_data
            # 可以计算该维度的评分
            dimension_result["score"] = calculate_score(processed_data)
            
        except asyncio.TimeoutError:
            dimension_result["errorMessage"] = f"【{task['name']}】数据源响应超时，请稍后重试。"
            
        except AIQuotaExhaustedError as e:
            dimension_result["errorMessage"] = f"【{task['name']}】AI 平台配额用尽，此部分结果暂缺。请提醒管理员充值。"
            
        except InvalidAPIKeyError as e:
            dimension_result["errorMessage"] = f"【{task['name']}】API 密钥配置错误，请联系技术支持。"
            
        except Exception as e:
            # 捕获所有其他异常
            dimension_result["errorMessage"] = f"【{task['name']}】数据获取或处理时发生未知错误，已跳过。"
            
            # 记录详细错误日志到文件/监控系统，但不影响主流程
            log_error(f"Task {task['name']} failed: {e}", exc_info=True)
        
        # 4. 将每个维度的结果（无论成功或失败）都追加到最终报告中
        final_report_data["dimensions"].append(dimension_result)
        
        # 5. 实时持久化维度结果
        save_dimension_result(execution_id, dimension_result)
    
    # 6. 更新整体状态
    failed_count = sum(1 for d in final_report_data["dimensions"] if d["status"] == "failed")
    if failed_count == 0:
        final_report_data["overallStatus"] = "success"
    elif failed_count < len(final_report_data["dimensions"]):
        final_report_data["overallStatus"] = "completed_with_warnings"
    else:
        final_report_data["overallStatus"] = "all_failed"
    
    # 7. 计算总体评分（仅对成功的维度取平均）
    successful_scores = [
        d["score"] for d in final_report_data["dimensions"] 
        if d["status"] == "success" and d.get("score") is not None
    ]
    if successful_scores:
        final_report_data["overallScore"] = sum(successful_scores) / len(successful_scores)
    else:
        final_report_data["overallScore"] = None  # 全盘失败
    
    # 8. 将完整的 final_report_data 对象存入数据库（快照）
    report_id = await save_report_to_db(user_id, final_report_data)
    
    # 9. 返回报告 ID 给前端
    return {"reportId": report_id, "status": final_report_data["overallStatus"]}
```

### 6.2 错误分类与用户友好提示

| 错误类型 | 技术原因 | 用户友好提示 | 重试建议 |
|---------|---------|-------------|---------|
| TimeoutError | API 响应超时 | "数据源响应超时，请稍后重试" | ✅ 可重试 |
| AIQuotaExhaustedError | 配额用尽 | "AI 平台配额已用尽，请联系客服充值" | ❌ 重试无效 |
| InvalidAPIKeyError | API Key 错误 | "API 密钥配置错误，请联系技术支持" | ❌ 重试无效 |
| NetworkError | 网络中断 | "网络连接中断，请检查网络后重试" | ✅ 可重试 |
| ParseError | 数据格式异常 | "数据解析失败，技术团队已收到通知" | ⚠️ 谨慎重试 |
| UnknownError | 未知错误 | "发生未知错误，已记录并跳过" | ⚠️ 谨慎重试 |

### 6.3 降级策略矩阵

| 故障场景 | 降级策略 | 用户体验 |
|---------|---------|---------|
| 单个 AI 平台失败 | 使用备用平台 | 无感知 |
| 所有 AI 平台失败 | 使用缓存数据/默认模板 | 提示"数据为历史缓存" |
| 数据库不可写 | 降级到文件存储 | 提示"报告保存延迟" |
| 前端渲染失败 | 显示纯文本版本 | 提示"简化版报告" |

---

## 实施路线图

### 7.1 阶段划分

| 阶段 | 时间 | 目标 | 交付物 |
|------|------|------|--------|
| **Phase 1** | 第 1 周 | 问题诊断与架构设计 | 架构文档、Schema 设计 |
| **Phase 2** | 第 2-3 周 | 核心代码重构 | 容错执行器、快照存储 |
| **Phase 3** | 第 4 周 | 前端适配与测试 | 前端组件、测试报告 |
| **Phase 4** | 第 5 周 | 灰度发布与监控 | 监控告警、运维手册 |

### 7.2 Phase 2 详细任务分解

#### Task 2.1: 实现容错执行器

**文件**: `wechat_backend/fault_tolerant_executor.py`

```python
class FaultTolerantExecutor:
    """容错执行器"""
    
    def __init__(self, timeout_seconds: int = 10):
        self.timeout = timeout_seconds
    
    async def execute_with_fallback(self, task_func: Callable, *args, **kwargs) -> Dict[str, Any]:
        """带降级的执行"""
        result = {
            "status": "failed",
            "data": None,
            "error_message": None,
            "error_type": None
        }
        
        try:
            data = await asyncio.wait_for(task_func(*args, **kwargs), timeout=self.timeout)
            result["status"] = "success"
            result["data"] = data
        except asyncio.TimeoutError:
            result["error_message"] = "数据源响应超时"
            result["error_type"] = "timeout"
        except Exception as e:
            result["error_message"] = self._get_user_friendly_error(e)
            result["error_type"] = self._get_error_type(e)
        
        return result
```

#### Task 2.2: 实现快照存储仓库

**文件**: `wechat_backend/repositories/report_snapshot_repository.py`

```python
class ReportSnapshotRepository:
    """报告快照存储仓库"""
    
    def save_snapshot(self, execution_id: str, report_data: Dict[str, Any]) -> str:
        """保存快照"""
        # 实现见 5.3.1
        pass
    
    def get_snapshot(self, execution_id: str) -> Optional[Dict[str, Any]]:
        """获取快照"""
        pass
    
    def verify_consistency(self, execution_id: str) -> bool:
        """验证一致性"""
        pass
```

#### Task 2.3: 重构 NxM 执行引擎

**文件**: `wechat_backend/nxm_execution_engine.py`

**修改点**:
1. 引入 `FaultTolerantExecutor`
2. 每个 AI 调用用 try-catch 包裹
3. 实时持久化到 `dimension_results` 表
4. 完成后保存到 `report_snapshots` 表

### 7.3 验收标准

| 验收项 | 标准 | 验证方法 |
|--------|------|---------|
| 报告生成成功率 | ≥99% | 100 次测试，失败≤1 次 |
| 部分失败支持 | 单模块失败不影响整体 | 模拟 API 失败，报告仍生成 |
| 历史报告一致性 | 100% 一致 | 生成后 7 天对比，哈希相同 |
| 数据持久化完整率 | 100% | 服务重启后数据不丢失 |
| 前端展示正常率 | 100% | 所有场景下前端不白屏 |

---

## 附录

### 附录 A: 关键文件清单

| 文件 | 路径 | 状态 |
|------|------|------|
| 容错执行器 | `wechat_backend/fault_tolerant_executor.py` | 待创建 |
| 快照仓库 | `wechat_backend/repositories/report_snapshot_repository.py` | 待创建 |
| 维度结果表 | `wechat_backend/repositories/dimension_result_repository.py` | 待创建 |
| 诊断服务 | `wechat_backend/services/diagnosis_service.py` | 需重构 |
| 执行引擎 | `wechat_backend/nxm_execution_engine.py` | 需重构 |

### 附录 B: 数据库迁移脚本

```sql
-- 创建 report_snapshots 表
CREATE TABLE IF NOT EXISTS report_snapshots (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    execution_id TEXT UNIQUE NOT NULL,
    report_data TEXT NOT NULL,
    report_hash TEXT NOT NULL,
    size_kb INTEGER NOT NULL,
    storage_timestamp TEXT NOT NULL
);

-- 创建 dimension_results 表
CREATE TABLE IF NOT EXISTS dimension_results (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    execution_id TEXT NOT NULL,
    dimension_name TEXT NOT NULL,
    dimension_type TEXT NOT NULL,
    source TEXT NOT NULL,
    status TEXT NOT NULL,
    score REAL,
    data TEXT,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_snapshot_execution_id ON report_snapshots(execution_id);
CREATE INDEX IF NOT EXISTS idx_dimension_execution_id ON dimension_results(execution_id);
```

---

**文档状态**: 待审核  
**下次更新**: 实施完成后  
**负责人**: 首席架构师
