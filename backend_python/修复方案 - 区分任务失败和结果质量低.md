# 后端修复方案：区分任务失败和结果质量低

## 问题描述

当前后端将 `quality_level='failed'`（结果质量低）与 `stage='failed'`（任务执行失败）混淆，导致：
- AI 调用成功返回结果
- 但质量评分为 0（因为 AI 没有提及用户品牌）
- 后端错误地将任务状态标记为 `failed`
- 前端显示"诊断失败"，虽然有结果数据

## 修复目标

1. **区分概念**：
   - `quality_level='failed'`：结果质量低（正常现象）
   - `stage='failed'`：任务执行失败（异常情况）

2. **修复逻辑**：
   - 质量评分低不应该影响任务状态
   - 只有真正的错误（超时、异常、API 失败）才标记为 `stage='failed'`

## 修复文件

### 1. `wechat_backend/nxm_result_aggregator.py`

**当前代码**（第 228-231 行）：
```python
# 确定质量等级
if score >= 80:
    quality_level = 'high'
elif score >= 60:
    quality_level = 'medium'
elif score >= 30:
    quality_level = 'low'
else:
    quality_level = 'failed'  # ❌ 问题：使用 'failed' 容易混淆
```

**修复方案**：
```python
# 确定质量等级
if score >= 80:
    quality_level = 'high'
elif score >= 60:
    quality_level = 'medium'
elif score >= 30:
    quality_level = 'low'
else:
    quality_level = 'very_low'  # ✅ 改为 'very_low'，避免与任务状态混淆
```

### 2. `wechat_backend/nxm_scheduler.py`

**当前代码**（第 113-127 行）：
```python
def fail_execution(self, error: str):
    """失败执行"""
    if not error or not error.strip():
        error = "执行失败，原因未知"

    with self._lock:
        if self.execution_id in self.execution_store:
            store = self.execution_store[self.execution_id]
            store['status'] = 'failed'
            store['stage'] = 'failed'
            store['error'] = error
            store['end_time'] = datetime.now().isoformat()
```

**问题**：这个方法只在真正的错误时调用，但需要确保不会因为质量评分低而调用。

**检查点**：
- 确保 `fail_execution` 只在以下情况调用：
  - AI API 调用失败（网络错误、认证错误）
  - 超时
  - 数据验证失败
  - 系统异常

### 3. `wechat_backend/nxm_execution_engine.py`

**检查点**（第 433 行）：
```python
# 验证响应数据
verification = validate_ai_response(response, geo_data)
if not verification['valid']:
    scheduler.fail_execution(verification['message'])  # ← 这里可能在质量评分低时调用
```

**修复方案**：
```python
# 验证响应数据
verification = validate_ai_response(response, geo_data)
if not verification['valid']:
    # 区分"数据无效"和"质量低"
    if verification['is_quality_issue']:
        # 质量低不标记为失败，继续处理
        api_logger.warning(f"[NxM] 结果质量低：{verification['message']}")
    else:
        # 真正的数据错误才标记为失败
        scheduler.fail_execution(verification['message'])
```

## 前端适配

### `services/brandTestService.js`

**添加质量评分处理**：

```javascript
// 在 parseTaskStatus 之后，添加质量评分检查
const hasLowQualityResults = parsedStatus.detailed_results?.some(
  r => r.quality_level === 'failed' || r.quality_level === 'very_low'
);

if (hasLowQualityResults) {
  console.warn('[品牌诊断] 检测到低质量结果，但仍可展示');
  // 继续调用 onComplete，让前端展示数据
}
```

## 测试验证

### 测试场景 1：AI 返回低质量结果

**输入**：
- 品牌：趣车良品
- 问题："深圳新能源汽车改装门店推荐"
- 模型：doubao

**预期结果**：
- `stage = 'completed'`
- `progress = 100`
- `quality_level = 'very_low'`（或 'failed'）
- `quality_score = 0`
- 前端显示结果，带有质量提示

**当前结果**：
- `stage = 'failed'` ❌
- 前端显示"诊断失败" ❌

### 测试场景 2：AI 调用超时

**输入**：
- 品牌：趣车良品
- 问题："深圳新能源汽车改装门店推荐"
- 模型：不存在的模型

**预期结果**：
- `stage = 'failed'`
- `error = 'AI 调用超时'`
- 前端显示错误提示

## 实施步骤

1. **修复后端质量等级命名**（5 分钟）
   - 修改 `nxm_result_aggregator.py`
   - 将 `'failed'` 改为 `'very_low'`

2. **检查后端失败逻辑**（15 分钟）
   - 审查 `nxm_execution_engine.py`
   - 确保质量低不调用 `fail_execution`

3. **添加后端日志**（10 分钟）
   - 记录质量评分和任务状态的决策过程

4. **前端适配**（10 分钟）
   - 处理 `quality_level='very_low'`
   - 显示质量提示

5. **测试验证**（15 分钟）
   - 运行测试场景 1 和 2

## 预期效果

修复后：
- 1 个问题的诊断在 **15-21 秒**内完成
- 即使质量评分低，也能看到结果
- 只有真正的错误才显示"诊断失败"
- 轮询次数减少到 **15-25 次**
