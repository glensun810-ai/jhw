# 品牌诊断报告数据流与存储架构审计报告

**审计日期**: 2026-02-25  
**审计负责人**: 麦肯锡顶级系统架构师、数据存储专家、性能专家  
**优先级**: P0 - 最高优先级  

---

## 执行摘要

### 核心发现

**当前品牌诊断报告系统存在严重的架构问题，导致历史数据无法完整保存和查询。**

### 问题严重程度

| 问题 | 严重性 | 影响 |
|------|--------|------|
| 数据存储分散 | 🔴 严重 | 历史数据无法完整查询 |
| 数据源不一致 | 🔴 严重 | 同一报告多次查询结果不同 |
| 缺少版本控制 | 🔴 严重 | 无法追溯历史快照 |
| 存储格式不统一 | 🟠 高 | 解析失败风险高 |
| 查询性能无优化 | 🟠 高 | 历史查询缓慢 |

---

## 第一部分：当前数据流全面审计

### 1.1 数据生成流程

```
┌─────────────────────────────────────────────────────────────┐
│  用户输入                                                    │
│  - 品牌名称                                                  │
│  - 竞品列表                                                  │
│  - 自定义问题                                                │
│  - AI 模型选择                                                │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  前端：pages/index/index.js                                  │
│  - 调用 startBrandTestApi()                                  │
│  - 发送 POST /api/perform-brand-test                         │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  后端：diagnosis_views.py                                    │
│  - perform_brand_test()                                      │
│  - 创建 execution_id                                         │
│  - 初始化 execution_store[execution_id]                      │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  NxM 执行引擎：nxm_execution_engine.py                        │
│  - execute_nxm_test()                                        │
│  - 遍历 品牌 × 问题 × 模型                                     │
│  - 调用 AI API                                                │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  AI 响应处理                                                  │
│  - 解析 geo_data                                             │
│  - 计算 quality_score                                        │
│  - 构建 result 对象                                           │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  数据存储（当前）                                            │
│  1. execution_store[execution_id]['results'].append()       │
│  2. save_diagnosis_result_to_db() ← 新增                    │
│  3. execution_store[execution_id] = {...}                   │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 数据读取流程

```
┌─────────────────────────────────────────────────────────────┐
│  用户查看历史报告                                            │
│  - 点击首页 → 历史记录                                       │
│  - 选择某个诊断报告                                          │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  前端：pages/results/results.js                              │
│  - onLoad(options)                                           │
│  - 读取 executionId, brandName                               │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  数据加载策略（当前）                                        │
│  1. wx.getStorageSync('last_diagnostic_results')            │
│  2. loadDiagnosisResult(executionId)                        │
│  3. loadLastDiagnosis()                                     │
│  4. GET /test/status/{executionId}                          │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  后端：diagnosis_views.py                                    │
│  - get_task_status_api()                                     │
│  - 优先从 execution_store 读取（内存）                        │
│  - 降级从数据库读取                                          │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  返回数据                                                    │
│  - detailed_results                                          │
│  - competitive_analysis                                      │
│  - brand_scores                                              │
│  - semantic_drift_data                                       │
│  - recommendation_data                                       │
│  - ...                                                       │
└─────────────────────────────────────────────────────────────┘
```

### 1.3 数据存储位置审计

| 数据类型 | 当前存储位置 | 存储格式 | 问题 |
|---------|-------------|---------|------|
| 执行状态 | execution_store (内存) | Dict | 服务器重启丢失 |
| 诊断结果 | diagnosis_results (SQLite) | JSON | 主数据源✅ |
| 备份结果 | diagnosis_results_backup | JSON | 冗余存储 |
| 前端缓存 | wx.Storage | JSON | 设备依赖 |
| 审计日志 | audit_logs/*.json | JSON | 分散存储 |
| 高级分析 | execution_store | Dict | 未持久化 |

### 1.4 数据解析逻辑审计

#### 1.4.1 前端解析

**文件**: `pages/results/results.js`

```javascript
// 当前逻辑
onLoad: function(options) {
    // 1. 从 Storage 加载
    const cachedResults = wx.getStorageSync('last_diagnostic_results');
    
    // 2. 从统一 Storage 加载
    const storageData = loadDiagnosisResult(executionId);
    
    // 3. 从 API 加载
    const res = await get(`/test/status/${executionId}`);
    
    // 问题：多个数据源，数据可能不一致
}
```

**问题**:
- ❌ 多个数据源无优先级
- ❌ 无数据版本控制
- ❌ 无完整性校验

#### 1.4.2 后端解析

**文件**: `wechat_backend/views/diagnosis_views.py`

```python
# 当前逻辑（修复后）
@wechat_bp.route('/test/status/<task_id>', methods=['GET'])
def get_task_status_api(task_id):
    # 1. 优先从数据库读取
    db_result = get_diagnosis_result_by_execution_id(task_id)
    
    # 2. 降级从缓存读取
    if task_id in execution_store:
        ...
    
    # 问题：execution_store 数据可能与数据库不一致
}
```

**问题**:
- ⚠️ 缓存与数据库可能不一致
- ⚠️ 无数据快照机制
- ⚠️ 历史数据可能被覆盖

---

## 第二部分：历史数据完整性需求

### 2.1 用户需求

**用户故事**:
> 作为用户，我希望在 6 个月后点击历史记录，能看到当时诊断的完整报告，一字不差。

**核心需求**:
1. **完整性** - 所有结果字段都要保存
2. **一致性** - 多次查询结果相同
3. **可追溯** - 知道何时诊断、用了什么配置
4. **不可变** - 历史数据不能被修改
5. **可查询** - 能快速找到特定报告

### 2.2 数据完整性要求

| 数据类别 | 字段 | 必须保存 | 原因 |
|---------|------|---------|------|
| 诊断配置 | brand_name | ✅ | 知道诊断的品牌 |
| 诊断配置 | competitor_brands | ✅ | 知道对比的竞品 |
| 诊断配置 | selected_models | ✅ | 知道用了哪些 AI |
| 诊断配置 | custom_questions | ✅ | 知道问了什么问题 |
| 诊断配置 | execution_id | ✅ | 唯一标识 |
| 诊断配置 | created_at | ✅ | 诊断时间 |
| 诊断配置 | user_id | ✅ | 哪个用户 |
| AI 响应 | brand | ✅ | 哪个品牌的结果 |
| AI 响应 | question | ✅ | 哪个问题 |
| AI 响应 | model | ✅ | 哪个 AI 模型 |
| AI 响应 | response.content | ✅ | AI 原始回答 |
| AI 响应 | response.latency | ✅ | 响应时间 |
| AI 响应 | geo_data | ✅ | GEO 分析结果 |
| AI 响应 | quality_score | ✅ | 质量评分 |
| 高级分析 | competitive_analysis | ✅ | 竞争分析 |
| 高级分析 | brand_scores | ✅ | 品牌评分 |
| 高级分析 | semantic_drift_data | ✅ | 语义偏移 |
| 高级分析 | recommendation_data | ✅ | 优化建议 |
| 高级分析 | source_purity_data | ✅ | 信源纯净度 |
| 高级分析 | source_intelligence_map | ✅ | 信源情报 |
| 系统信息 | server_version | ✅ | 后端版本 |
| 系统信息 | data_schema_version | ✅ | 数据结构版本 |

---

## 第三部分：当前架构问题

### 3.1 核心问题

**问题 1: 数据存储分散**
```
execution_store (内存) ← 当前主要数据源
    ↓
diagnosis_results (数据库) ← 降级方案
    ↓
wx.Storage (前端) ← 客户端缓存
```

**影响**: 
- 服务器重启后 execution_store 清空
- 前端刷新后 wx.Storage 可能过期
- 数据库成为唯一可靠数据源，但当前是降级方案

**问题 2: 无数据快照**
```
# 当前逻辑
execution_store[execution_id]['results'] = [...]  # 可变
execution_store[execution_id]['stage'] = '...'    # 可变
```

**影响**:
- 历史数据可能被覆盖
- 无法追溯诊断时的状态
- 无法回滚到历史版本

**问题 3: 存储格式不统一**
```python
# 有的地方存 JSON 字符串
results_json = json.dumps(results)

# 有的地方存 Python 对象
execution_store[execution_id]['results'] = results

# 有的地方存压缩数据
gzip.decompress(summary_raw)
```

**影响**:
- 解析逻辑复杂
- 容易解析失败
- 维护成本高

**问题 4: 查询性能无优化**
```sql
-- 当前查询
SELECT * FROM diagnosis_results WHERE execution_id = ?

-- 问题：
-- 1. 无索引优化
-- 2. 大 JSON 字段每次都加载
-- 3. 无分页机制
```

**影响**:
- 历史报告多时查询缓慢
- 大报告加载超时
- 用户体验差

---

## 第四部分：顶级架构设计

### 4.1 设计原则

1. **单一事实源** - 数据库是唯一可靠数据源
2. **不可变存储** - 历史数据一旦保存不可修改
3. **版本控制** - 每次变更都有版本号
4. **分层存储** - 热数据缓存，冷数据归档
5. **完整性校验** - 每条数据都有校验和

### 4.2 存储架构

```
┌─────────────────────────────────────────────────────────────┐
│  应用层                                                      │
│  - 诊断执行                                                  │
│  - 报告查询                                                  │
│  - 历史记录                                                  │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  缓存层 (Redis/Memory)                                       │
│  - 热数据缓存（最近 7 天）                                     │
│  - TTL: 7 天                                                  │
│  - 缓存失效后从数据库加载                                    │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  数据库层 (SQLite/PostgreSQL)                                │
│  - diagnosis_reports (主表)                                  │
│  - diagnosis_results (结果明细)                              │
│  - diagnosis_snapshots (历史快照)                            │
│  - diagnosis_metadata (元数据)                               │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  归档层 (文件系统/对象存储)                                   │
│  - /data/archives/YYYY/MM/DD/{execution_id}.json.gz         │
│  - 定期压缩（30 天前数据）                                    │
│  - 可上传到 S3/OSS                                           │
└─────────────────────────────────────────────────────────────┘
```

### 4.3 数据库表设计

#### 4.3.1 主表：diagnosis_reports

```sql
CREATE TABLE diagnosis_reports (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    execution_id TEXT UNIQUE NOT NULL,
    user_id TEXT NOT NULL,
    
    -- 诊断配置（不可变）
    brand_name TEXT NOT NULL,
    competitor_brands TEXT NOT NULL,  -- JSON 数组
    selected_models TEXT NOT NULL,    -- JSON 数组
    custom_questions TEXT NOT NULL,   -- JSON 数组
    
    -- 状态
    status TEXT NOT NULL DEFAULT 'processing',
    progress INTEGER NOT NULL DEFAULT 0,
    stage TEXT NOT NULL DEFAULT 'init',
    is_completed BOOLEAN NOT NULL DEFAULT 0,
    
    -- 时间戳（不可变）
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    completed_at TEXT,
    
    -- 版本控制
    data_schema_version TEXT NOT NULL DEFAULT '1.0',
    server_version TEXT NOT NULL,
    
    -- 完整性校验
    checksum TEXT NOT NULL,
    
    -- 索引优化
    INDEX idx_user_id (user_id),
    INDEX idx_created_at (created_at),
    INDEX idx_brand_name (brand_name),
    INDEX idx_status (status)
);
```

#### 4.3.2 结果明细表：diagnosis_results

```sql
CREATE TABLE diagnosis_results (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    report_id INTEGER NOT NULL,
    execution_id TEXT NOT NULL,
    
    -- 结果内容（不可变）
    brand TEXT NOT NULL,
    question TEXT NOT NULL,
    model TEXT NOT NULL,
    response_content TEXT NOT NULL,  -- AI 原始回答
    response_latency REAL,           -- 响应时间（秒）
    
    -- GEO 分析
    geo_data TEXT NOT NULL,          -- JSON 对象
    
    -- 质量评分
    quality_score REAL NOT NULL,
    quality_level TEXT NOT NULL,
    quality_details TEXT NOT NULL,   -- JSON 对象
    
    -- 状态
    status TEXT NOT NULL DEFAULT 'success',
    error_message TEXT,
    
    -- 时间戳
    created_at TEXT NOT NULL,
    
    -- 外键
    FOREIGN KEY (report_id) REFERENCES diagnosis_reports(id),
    
    -- 索引
    INDEX idx_execution_id (execution_id),
    INDEX idx_report_id (report_id),
    INDEX idx_brand (brand),
    INDEX idx_model (model)
);
```

#### 4.3.3 高级分析表：diagnosis_analysis

```sql
CREATE TABLE diagnosis_analysis (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    report_id INTEGER NOT NULL,
    execution_id TEXT NOT NULL,
    
    -- 分析类型
    analysis_type TEXT NOT NULL,  -- competitive_analysis, brand_scores, etc.
    
    -- 分析数据（不可变）
    analysis_data TEXT NOT NULL,  -- JSON 对象
    
    -- 版本控制
    analysis_version TEXT NOT NULL DEFAULT '1.0',
    
    -- 时间戳
    created_at TEXT NOT NULL,
    
    -- 外键
    FOREIGN KEY (report_id) REFERENCES diagnosis_reports(id),
    
    -- 索引
    INDEX idx_execution_id (execution_id),
    INDEX idx_report_id (report_id),
    INDEX idx_analysis_type (analysis_type)
);
```

#### 4.3.4 历史快照表：diagnosis_snapshots

```sql
CREATE TABLE diagnosis_snapshots (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    report_id INTEGER NOT NULL,
    execution_id TEXT NOT NULL,
    
    -- 快照内容（完整副本）
    snapshot_data TEXT NOT NULL,  -- 完整 JSON 快照
    
    -- 快照元数据
    snapshot_reason TEXT NOT NULL,  -- 'completed', 'updated', 'archived'
    snapshot_version TEXT NOT NULL,
    
    -- 时间戳
    created_at TEXT NOT NULL,
    
    -- 外键
    FOREIGN KEY (report_id) REFERENCES diagnosis_reports(id),
    
    -- 索引
    INDEX idx_execution_id (execution_id),
    INDEX idx_created_at (created_at)
);
```

### 4.4 文件存储设计

#### 4.4.1 目录结构

```
/data/
├── diagnosis/
│   ├── reports/              # 当前报告（30 天内）
│   │   ├── 2026/
│   │   │   ├── 02/
│   │   │   │   ├── 25/
│   │   │   │   │   ├── {execution_id_1}.json
│   │   │   │   │   └── {execution_id_2}.json
│   │   │   │   └── 26/
│   │   │   └── 03/
│   │   └── archives/         # 归档报告（30 天前）
│   │       ├── 2026-01.tar.gz
│   │       └── 2025-12.tar.gz
│   └── backups/              # 数据库备份
│       ├── daily/
│       ├── weekly/
│       └── monthly/
└── audit/
    └── logs/
```

#### 4.4.2 文件格式

```json
{
  "meta": {
    "execution_id": "uuid-xxx",
    "data_schema_version": "1.0",
    "server_version": "2.0.0",
    "created_at": "2026-02-25T01:00:00Z",
    "checksum": "sha256:xxx"
  },
  "config": {
    "brand_name": "趣车良品",
    "competitor_brands": ["承美车居"],
    "selected_models": ["doubao", "qwen"],
    "custom_questions": ["问题 1", "问题 2"]
  },
  "results": [
    {
      "brand": "趣车良品",
      "question": "问题 1",
      "model": "doubao",
      "response": {
        "content": "...",
        "latency": 12.5
      },
      "geo_data": {...},
      "quality_score": 85,
      "quality_level": "high"
    }
  ],
  "analysis": {
    "competitive_analysis": {...},
    "brand_scores": {...},
    "semantic_drift_data": {...},
    "recommendation_data": {...}
  }
}
```

### 4.5 数据流优化

#### 4.5.1 诊断执行流程（优化后）

```
1. 创建诊断报告记录
   INSERT INTO diagnosis_reports (execution_id, config, created_at, ...)
   
2. 对每个 AI 调用
   a. 调用 AI API
   b. 解析响应
   c. 保存到 diagnosis_results
      INSERT INTO diagnosis_results (report_id, execution_id, brand, question, model, ...)
   d. 更新进度
      UPDATE diagnosis_reports SET progress = ?, updated_at = ? WHERE execution_id = ?

3. 生成高级分析
   a. 计算 competitive_analysis
   b. 保存到 diagnosis_analysis
      INSERT INTO diagnosis_analysis (report_id, execution_id, analysis_type, analysis_data, ...)
   
4. 完成诊断
   a. 更新状态
      UPDATE diagnosis_reports SET status = 'completed', is_completed = 1, completed_at = ?
   b. 创建快照
      INSERT INTO diagnosis_snapshots (report_id, execution_id, snapshot_data, snapshot_reason, ...)
   c. 写入文件存储
      write_to_file_archive(execution_id, full_report_data)
```

#### 4.5.2 历史查询流程（优化后）

```
1. 用户点击历史记录
   GET /api/diagnosis/history?user_id=xxx&page=1&limit=20

2. 查询报告列表
   SELECT id, execution_id, brand_name, created_at, status 
   FROM diagnosis_reports 
   WHERE user_id = ? 
   ORDER BY created_at DESC 
   LIMIT ? OFFSET ?

3. 用户选择某个报告
   GET /api/diagnosis/report/{execution_id}

4. 从数据库加载完整报告
   a. 加载主表
      SELECT * FROM diagnosis_reports WHERE execution_id = ?
   b. 加载结果明细
      SELECT * FROM diagnosis_results WHERE execution_id = ?
   c. 加载高级分析
      SELECT * FROM diagnosis_analysis WHERE execution_id = ?
   d. 验证完整性
      verify_checksum(report_data)
   
5. 返回完整报告
   {
     "report": {...},
     "results": [...],
     "analysis": {...},
     "checksum": "xxx",
     "is_complete": true
   }
```

---

## 第五部分：实施计划

### 阶段 1: 数据库迁移（1 天）

- [ ] 创建新表结构
- [ ] 迁移现有数据
- [ ] 验证数据完整性

### 阶段 2: 存储层实现（2 天）

- [ ] 实现 Repository 模式
- [ ] 实现文件归档
- [ ] 实现快照机制

### 阶段 3: API 优化（1 天）

- [ ] 优化查询接口
- [ ] 添加分页支持
- [ ] 添加完整性校验

### 阶段 4: 前端适配（1 天）

- [ ] 更新数据加载逻辑
- [ ] 添加加载状态
- [ ] 添加错误处理

### 阶段 5: 测试验证（1 天）

- [ ] 数据完整性测试
- [ ] 性能测试
- [ ] 历史查询测试

---

## 第六部分：性能与空间规划

### 6.1 性能指标

| 操作 | 目标 | 当前 | 优化后 |
|------|------|------|--------|
| 创建报告 | < 1 秒 | TBD | < 500ms |
| 查询历史列表 | < 200ms | TBD | < 100ms |
| 加载完整报告 | < 2 秒 | TBD | < 1 秒 |
| 归档压缩 | < 10 秒 | N/A | < 5 秒 |

### 6.2 空间规划

| 数据类型 | 单条大小 | 日增量 | 月增量 | 年增量 |
|---------|---------|--------|--------|--------|
| 诊断报告 | 50KB | 5MB | 150MB | 1.8GB |
| 结果明细 | 10KB × N | 10MB | 300MB | 3.6GB |
| 高级分析 | 30KB | 3MB | 90MB | 1GB |
| 文件归档 | 20KB | 2MB | 60MB | 720MB |
| **总计** | **110KB** | **20MB** | **600MB** | **7.2GB** |

### 6.3 存储策略

| 数据年龄 | 存储位置 | 压缩 | 访问速度 |
|---------|---------|------|---------|
| 0-7 天 | 数据库 + 缓存 | 无 | 毫秒级 |
| 7-30 天 | 数据库 | 无 | 毫秒级 |
| 30-365 天 | 文件归档 | GZIP | 秒级 |
| > 365 天 | 对象存储 | GZIP | 秒级 |

---

## 第七部分：验收标准

### 数据完整性

- [ ] 历史报告 100% 可查询
- [ ] 多次查询结果一致
- [ ] 校验和验证通过

### 性能指标

- [ ] 查询响应时间 < 200ms
- [ ] 报告加载时间 < 2 秒
- [ ] 归档压缩时间 < 10 秒

### 用户体验

- [ ] 历史记录列表加载流畅
- [ ] 报告内容完整展示
- [ ] 错误处理友好

---

**审计完成时间**: 2026-02-25 02:00:00  
**实施负责人**: 首席后端工程师  
**验收人**: CTO、产品经理
