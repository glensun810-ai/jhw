"""
物理排位解析引擎 - 从AI回复中提取品牌排名、篇幅和拦截者信息
"""
import re
from typing import Dict, List, Tuple, Optional
from collections import OrderedDict


class RankAnalyzer:
    """
    物理排位解析引擎
    从AI原始回复文本中提取品牌排名、篇幅统计和拦截者信息
    输出符合exposure_analysis结构的数据
    """
    
    def __init__(self):
        # 常见的品牌前缀/后缀，用于更精确的品牌匹配
        self.brand_prefixes = ['"', '"', '“', '”', '《', '》', '(', ')', '（', '）', ' ', ',', '，', '、', ':', '：', ';', '；']
        self.brand_suffixes = ['"', '"', '“', '”', '《', '》', '(', ')', '（', '）', ' ', ',', '，', '、', ':', '：', ';', '；', '.', '。', '!', '！', '?', '？']
    
    def analyze(self, ai_response: str, brand_list: List[str]) -> Dict:
        """
        分析AI回复，提取露出与排位信息
        
        Args:
            ai_response: AI原始回复文本
            brand_list: 监控的品牌列表
            
        Returns:
            符合exposure_analysis结构的字典
        """
        # 1. 识别品牌排名列表
        ranking_list = self._extract_ranking_list(ai_response, brand_list)
        
        # 2. 统计各品牌详情
        brand_details = self._extract_brand_details(ai_response, brand_list)
        
        # 3. 识别未列出的竞争对手
        unlisted_competitors = self._identify_unlisted_competitors(ai_response, brand_list)
        
        return {
            'ranking_list': ranking_list,
            'brand_details': brand_details,
            'unlisted_competitors': unlisted_competitors
        }
    
    def _extract_ranking_list(self, ai_response: str, brand_list: List[str]) -> List[str]:
        """
        提取品牌在AI回复中的物理出现顺序
        
        Args:
            ai_response: AI回复文本
            brand_list: 监控品牌列表
            
        Returns:
            按首次出现顺序排列的品牌列表
        """
        # 创建一个字典来存储每个品牌第一次出现的位置
        brand_positions = {}
        
        # 对品牌列表进行排序，优先匹配较长的品牌名称，避免短名称误匹配
        sorted_brands = sorted(brand_list, key=len, reverse=True)
        
        for brand in sorted_brands:
            # 查找品牌在文本中的位置
            position = self._find_brand_position(ai_response, brand)
            if position != -1 and brand not in brand_positions:
                brand_positions[brand] = position
        
        # 按位置排序，返回品牌列表
        sorted_brands_by_pos = sorted(brand_positions.keys(), key=lambda x: brand_positions[x])
        return sorted_brands_by_pos
    
    def _find_brand_position(self, text: str, brand: str) -> int:
        """
        在文本中查找品牌的确切位置，考虑边界条件

        Args:
            text: 要搜索的文本
            brand: 要查找的品牌名称

        Returns:
            品牌在文本中的位置，如果未找到则返回-1
        """
        # 转换为小写进行比较，但保留原文本位置
        text_lower = text.lower()
        brand_lower = brand.lower()

        # 查找品牌名称的所有可能位置
        pos = 0
        while pos < len(text_lower):
            pos = text_lower.find(brand_lower, pos)
            if pos == -1:
                break

            # 检查品牌名称前后是否为边界字符（避免部分匹配）
            start_ok = pos == 0 or text[pos - 1].lower() in [c.lower() for c in self.brand_prefixes]
            end_ok = pos + len(brand_lower) == len(text_lower) or (pos + len(brand_lower) < len(text) and text[pos + len(brand_lower)].lower() in [c.lower() for c in self.brand_suffixes)

            if start_ok and end_ok:
                return pos  # 找到确切匹配的位置

            pos += 1

        return -1  # 未找到匹配
    
    def _extract_brand_details(self, ai_response: str, brand_list: List[str]) -> Dict:
        """
        提取各品牌的详细信息（排名、字数、篇幅占比、情感分数）
        
        Args:
            ai_response: AI回复文本
            brand_list: 监控品牌列表
            
        Returns:
            包含各品牌详情的字典
        """
        brand_details = {}
        ranking_list = self._extract_ranking_list(ai_response, brand_list)
        total_length = len(ai_response)
        
        for idx, brand in enumerate(ranking_list):
            # 计算品牌描述的字符长度
            word_count = self._calculate_brand_word_count(ai_response, brand)
            
            # 计算篇幅占比
            sov_share = round(word_count / total_length, 4) if total_length > 0 else 0.0
            
            # 获取排名（从1开始）
            rank = idx + 1
            
            # 情感分数暂时设为默认值，实际应用中可以从AI判断模块获取
            sentiment_score = 50  # 默认中性分数
            
            brand_details[brand] = {
                'rank': rank,
                'word_count': word_count,
                'sov_share': sov_share,
                'sentiment_score': sentiment_score
            }
        
        # 为没有在回复中出现的品牌也添加记录
        for brand in brand_list:
            if brand not in brand_details:
                brand_details[brand] = {
                    'rank': -1,  # 表示未出现
                    'word_count': 0,
                    'sov_share': 0.0,
                    'sentiment_score': 50
                }
        
        return brand_details
    
    def _calculate_brand_word_count(self, ai_response: str, brand: str) -> int:
        """
        计算AI回复中特定品牌的描述字符长度
        
        Args:
            ai_response: AI回复文本
            brand: 品牌名称
            
        Returns:
            该品牌相关描述的字符长度
        """
        # 找到品牌在文本中的所有出现位置
        positions = self._find_all_brand_positions(ai_response, brand)
        
        if not positions:
            return 0
        
        # 计算每个出现位置周围的上下文长度
        total_count = 0
        processed_ranges = []  # 已处理的范围，避免重复计算
        
        for pos in positions:
            # 定义上下文范围（向前和向后搜索句子边界）
            start_idx = self._find_sentence_start(ai_response, pos)
            end_idx = self._find_sentence_end(ai_response, pos + len(brand))
            
            # 检查是否与已处理的范围重叠
            overlap = False
            for start, end in processed_ranges:
                if not (end_idx <= start or start_idx >= end):
                    overlap = True
                    # 如果有重叠，只计算未重叠的部分
                    actual_start = max(start_idx, end)
                    actual_end = min(end_idx, start)
                    if actual_start < actual_end:
                        total_count += actual_end - actual_start
                    break
            
            if not overlap:
                total_count += end_idx - start_idx
                processed_ranges.append((start_idx, end_idx))
        
        return total_count
    
    def _find_all_brand_positions(self, text: str, brand: str) -> List[int]:
        """
        查找品牌在文本中的所有出现位置
        
        Args:
            text: 要搜索的文本
            brand: 要查找的品牌名称
            
        Returns:
            品牌出现位置的列表
        """
        positions = []
        text_lower = text.lower()
        brand_lower = brand.lower()
        
        pos = 0
        while pos < len(text_lower):
            pos = text_lower.find(brand_lower, pos)
            if pos == -1:
                break
                
            # 检查品牌名称前后是否为边界字符
            start_ok = pos == 0 or text[pos - 1].lower() in [c.lower() for c in self.brand_prefixes]
            end_ok = pos + len(brand_lower) == len(text_lower) or text[pos + len(brand_lower)].lower() in [c.lower() for c in self.brand_suffixes]
            
            if start_ok and end_ok:
                positions.append(pos)
            
            pos += 1
            
        return positions
    
    def _find_sentence_start(self, text: str, pos: int) -> int:
        """
        从指定位置向前查找句子开始位置
        
        Args:
            text: 文本
            pos: 起始位置
            
        Returns:
            句子开始位置
        """
        # 向前查找句号、感叹号、问号等标点符号
        for i in range(pos, -1, -1):
            if i < len(text) and text[i] in ['.', '。', '!', '！', '?', '？', ';', '；', '\n', '\r']:
                return i + 1
        return 0
    
    def _find_sentence_end(self, text: str, pos: int) -> int:
        """
        从指定位置向后查找句子结束位置
        
        Args:
            text: 文本
            pos: 起始位置
            
        Returns:
            句子结束位置
        """
        # 向后查找句号、感叹号、问号等标点符号
        for i in range(pos, len(text)):
            if text[i] in ['.', '。', '!', '！', '?', '？', ';', '；', '\n', '\r']:
                return i
        return len(text)
    
    def _identify_unlisted_competitors(self, ai_response: str, brand_list: List[str]) -> List[str]:
        """
        识别AI回复中出现但不在监控列表中的潜在竞争对手
        
        Args:
            ai_response: AI回复文本
            brand_list: 监控品牌列表
            
        Returns:
            未列出的竞争对手列表
        """
        # 首先将已知品牌从文本中移除，避免重复识别
        processed_text = ai_response
        for brand in sorted(brand_list, key=len, reverse=True):
            # 使用正则表达式替换，忽略大小写
            processed_text = re.sub(re.escape(brand), '', processed_text, flags=re.IGNORECASE)
        
        # 定义可能表示品牌的常见模式
        # 这里使用一些常见的品牌特征词作为示例，实际应用中可能需要更复杂的NLP处理
        potential_competitor_patterns = [
            r'(?<!\w)([A-Z][a-z]+(?:[A-Z][a-z]*)*)(?!\w)',  # 驼峰式命名
            r'(?<!\w)([A-Z]{2,})(?!\w)',  # 全大写字母缩写
            r'(?<!\w)([A-Z][a-z]+(?:\s+[A-Z][a-z]*)+)(?!\w)',  # 多词品牌名
        ]
        
        unlisted_competitors = set()
        
        # 搜索潜在的竞争者
        for pattern in potential_competitor_patterns:
            matches = re.findall(pattern, processed_text)
            for match in matches:
                # 清理匹配结果
                clean_match = match.strip()
                if len(clean_match) > 1 and clean_match not in brand_list:  # 避免单字符匹配
                    unlisted_competitors.add(clean_match)
        
        # 另一种方法：查找在描述产品质量、特点时提到的其他品牌
        # 例如："相比之下，XXX做得更好"，"不像YYY那样..."
        contrast_pattern = r'(?:相比|相对|不同于|不像|除了)\s*([A-Za-z\u4e00-\u9fa5]+)'
        contrast_matches = re.findall(contrast_pattern, processed_text)
        for match in contrast_matches:
            clean_match = match.strip()
            if len(clean_match) > 1 and clean_match not in brand_list and clean_match not in unlisted_competitors:
                unlisted_competitors.add(clean_match)
        
        return list(unlisted_competitors)


# 示例使用
if __name__ == "__main__":
    analyzer = RankAnalyzer()
    
    # 示例AI回复
    sample_response = """
    在智能锁领域，德施曼一直表现不错，其指纹识别技术较为先进。
    小米的智能锁性价比很高，适合大众消费者。
    凯迪仕也有一定的市场份额，特别是在工程渠道。
    相比之下，鹿客在用户体验方面做得更好。
    """
    
    # 监控品牌列表
    brands = ["德施曼", "小米", "凯迪仕"]
    
    # 执行分析
    result = analyzer.analyze(sample_response, brands)
    
    print("排名列表:", result['ranking_list'])
    print("品牌详情:", result['brand_details'])
    print("未列出的竞争对手:", result['unlisted_competitors'])