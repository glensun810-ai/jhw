import time
import json
import re
from abc import ABC, abstractmethod
from dataclasses import dataclass, asdict
from enum import Enum
from typing import Optional, Dict, Any, List
from wechat_backend.logging_config import api_logger
from wechat_backend.optimization.request_frequency_optimizer import optimize_request_frequency, RequestPriority
from wechat_backend.ai_adapters.geo_parser import parse_geo_json_enhanced

# Flask context handling for async logging
# 2026-03-01 修复：添加 Flask 应用上下文支持，解决异步调用中的日志上下文丢失问题
try:
    from flask import current_app
    _FLASK_AVAILABLE = True
except ImportError:
    _FLASK_AVAILABLE = False
    current_app = None

# 保持向后兼容
parse_geo_json = parse_geo_json_enhanced

# ==================== GEO 分析提示词模板（P1-4 增强版） ====================
# GEO Analysis Prompt Template with self-audit instructions
# P1-4 修复：增强 JSON 格式要求，添加自检指令和验证规则
# 2026-03-01 修复：强化纯 JSON 输出指令，明确禁止 Markdown 代码块
GEO_PROMPT_TEMPLATE = """
用户品牌：{brand_name}
竞争对手：{competitors}

请回答以下用户问题：
{question}

---
重要要求：

1. 请以专业顾问的身份客观回答。

2. **关键要求**：在回答结束后，必须另起一行，以严格的 JSON 格式输出以下字段：
{{
  "geo_analysis": {{
    "brand_mentioned": boolean,
    "rank": number,
    "sentiment": number,
    "cited_sources": [
      {{"url": "string", "site_name": "string", "attitude": "positive/negative/neutral"}}
    ],
    "interception": "string"
  }}
}}

3. **字段详细说明**：
   - brand_mentioned: 品牌是否被提到 (true/false) - **必须明确回答，不能省略**
   - rank: 品牌在推荐列表中的排名（**必须为 1-10 的数字**，若未提到则为 -1）- **必须明确排名**
   - sentiment: 对品牌的情感评分（**必须为 -1.0 到 1.0 的数字**，positive=0.5~1.0, neutral=-0.1~0.1, negative=-1.0~-0.5）- **必须明确情感，不能为 0.0**
   - cited_sources: 提到的或暗示的信源/网址列表 - **必须提供至少 2 个真实信源**
   - interception: 如果推荐了竞品而没推荐我，写下竞品名（如果没有则留空字符串""）

4. **JSON 格式要求（非常重要，违反会导致解析失败）**：
   - ⚠️ **必须输出纯 JSON，不要包含在 Markdown 代码块中**
   - ⚠️ **不要使用 ```json 或 ``` 包裹 JSON 内容**
   - ⚠️ **不要有任何额外说明文字在 JSON 之后**
   - 必须是合法的可解析 JSON（使用双引号，不是单引号）
   - 所有字段都必须存在，不能省略

5. **信源要求**（cited_sources 字段）：
   - 必须包含至少 2 个信源
   - 可以从以下常见科技媒体中选择：
     * 知乎 (zhihu.com)
     * 小红书 (xiaohongshu.com)
     * 中关村在线 (zol.com.cn)
     * 太平洋电脑网 (pconline.com.cn)
     * 什么值得买 (smzdm.com)
     * 品牌官网
   - 如果回答中未明确提及具体 URL，请根据内容推断可能来源的信源网站

6. **自检指令**（在输出 JSON 前请自我检查）：
   - ✓ brand_mentioned 是否为布尔值（true/false）？
   - ✓ rank 是否为 1-10 或 -1 的数字？
   - ✓ sentiment 是否为 -1.0 到 1.0 之间的数字（且不为 0.0）？
   - ✓ cited_sources 是否包含至少 2 个信源？
   - ✓ JSON 格式是否合法（可以用 JSON.parse 解析）？
   - ✓ **是否没有使用 Markdown 代码块包裹？**

7. **输出示例（请严格按照此格式，不要添加 ```json 标记）**：

[这里是您的详细回答内容...]

{{"geo_analysis": {{"brand_mentioned": true, "rank": 2, "sentiment": 0.7, "cited_sources": [{{"url": "https://www.zhihu.com/question/xxx", "site_name": "知乎", "attitude": "positive"}}, {{"url": "https://www.xiaohongshu.com/discovery/item/xxx", "site_name": "小红书", "attitude": "neutral"}}], "interception": ""}}}}
"""

# ==================== P0 修复：客观问题提示词模板 ====================
# 用于获取 AI 的客观推荐回答（不带品牌倾向）
OBJECTIVE_QUESTION_TEMPLATE = """
请回答以下用户问题：
{question}

---
重要要求：
1. 请以专业顾问的身份客观回答。
2. 请列出您推荐的 TOP3 品牌/门店，并说明理由。
3. 在回答结束后，必须另起一行，以严格的 JSON 格式输出以下字段（不要包含在 Markdown 代码块中）：
{{
  "top3_brands": [
    {{"name": "品牌 1", "rank": 1, "reason": "推荐理由 1"}},
    {{"name": "品牌 2", "rank": 2, "reason": "推荐理由 2"}},
    {{"name": "品牌 3", "rank": 3, "reason": "推荐理由 3"}}
  ],
  "total_brands_mentioned": 5
}}
"""

# ==================== P0 修复：客观问题提示词模板（P1-4 增强版） ====================
# 用于获取 AI 的客观推荐回答（不带品牌倾向）
# P1-4 修复：增强 JSON 格式要求，添加自检指令，提高结构化输出率
# 2026-03-01 修复：强化纯 JSON 输出指令，明确禁止 Markdown 代码块
OBJECTIVE_QUESTION_TEMPLATE = """
请回答以下用户问题：
{question}

---
重要要求：

1. 请以专业顾问的身份客观回答。

2. 请列出您推荐的 TOP3 品牌/门店，并说明理由。

3. **关键要求**：在回答结束后，必须另起一行，以严格的 JSON 格式输出以下字段：
{{
  "top3_brands": [
    {{"name": "品牌 1", "rank": 1, "reason": "推荐理由 1"}},
    {{"name": "品牌 2", "rank": 2, "reason": "推荐理由 2"}},
    {{"name": "品牌 3", "rank": 3, "reason": "推荐理由 3"}}
  ],
  "total_brands_mentioned": 5
}}

4. **JSON 格式要求（非常重要，违反会导致解析失败）**：
   - ⚠️ **必须输出纯 JSON，不要包含在 Markdown 代码块中**
   - ⚠️ **不要使用 ```json 或 ``` 包裹 JSON 内容**
   - ⚠️ **不要有任何额外说明文字在 JSON 之后**
   - 必须是合法的可解析 JSON（使用双引号，不是单引号）
   - rank 字段必须是 1、2、3 这样的数字
   - name 和 reason 字段必须是非空字符串

5. **自检指令**（在输出 JSON 前请自我检查）：
   - ✓ 是否推荐了恰好 3 个品牌？
   - ✓ 每个品牌是否都有 name、rank、reason 三个字段？
   - ✓ rank 是否按 1、2、3 顺序排列？
   - ✓ JSON 格式是否合法（可以用 JSON.parse 解析）？
   - ✓ **是否没有使用 Markdown 代码块包裹？**

6. **输出示例（请严格按照此格式，不要添加 ```json 标记）**：

好的，基于我的了解，以下是我为您推荐的品牌：

[这里是您的详细推荐内容...]

{{"top3_brands": [{{"name": "品牌 A", "rank": 1, "reason": "理由 A"}}, {{"name": "品牌 B", "rank": 2, "reason": "理由 B"}}, {{"name": "品牌 C", "rank": 3, "reason": "理由 C"}}], "total_brands_mentioned": 3}}
"""

# 品牌分析提示词（用于分析 AI 回答中的品牌提及情况）
# P0 修复：用于后置分析 AI 回答中的品牌提及
# P1-4 增强：添加 JSON 格式要求和自检指令
BRAND_ANALYSIS_TEMPLATE = """
以下是 AI 对问题"{question}"的回答：
{ai_response}

用户关注的品牌：{user_brand}

请分析该品牌在回答中的表现：
1. 是否被提及（brand_mentioned: true/false）
2. 排名是多少（rank: 1-10，未提及为 -1）
3. 情感倾向（sentiment: -1.0 到 1.0）
4. 是否被推荐为 TOP3（is_top3: true/false）
5. 提及的上下文（mention_context）

**关键要求**：请以严格的 JSON 格式输出，不要包含任何额外文字：
{{
  "brand_analysis": {{
    "brand_mentioned": boolean,
    "rank": number,
    "sentiment": number,
    "is_top3": boolean,
    "mention_context": "string"
  }}
}}

**JSON 格式要求**：
- 必须是合法的可解析 JSON（使用双引号）
- 不要包含在 Markdown 代码块中
- brand_mentioned 和 is_top3 必须是 true/false 布尔值
- rank 必须是数字（1-10 或 -1）
- sentiment 必须是 -1.0 到 1.0 之间的数字
- mention_context 必须是字符串（如果未提及则为空字符串""）

**自检指令**：
- ✓ brand_mentioned 是否为布尔值？
- ✓ rank 是否为数字？
- ✓ sentiment 是否在 -1.0 到 1.0 范围内？
- ✓ JSON 格式是否合法？

**输出示例**：
{{"brand_analysis": {{"brand_mentioned": true, "rank": 2, "sentiment": 0.8, "is_top3": true, "mention_context": "品牌 X 在推荐中排名第二，表现优秀"}}}}
"""

# P2 修复：批量品牌提取提示词（一次性提取所有提及的品牌）
# 严禁在 for 循环中针对每个品牌单独调用 LLM！必须使用此模板进行批量提取！
# 2026-03-01 修复：强化纯 JSON 输出指令，明确禁止 Markdown 代码块
BATCH_BRAND_EXTRACTION_TEMPLATE = """
以下是 AI 对用户问题的回答：
=== 回答开始 ===
{ai_response}
=== 回答结束 ===

**任务**：从上述回答中**一次性批量提取**所有被提及的品牌，并分析每个品牌的表现。

**关键指令（必须严格遵守）**：
1. **只调用一次 LLM**：阅读整篇回答，一次性提取所有品牌，严禁逐品牌分析
2. **完整提取**：识别回答中出现的所有品牌名称（包括中文名、英文名、简称）
3. **批量输出**：以 JSON 数组形式返回所有品牌，每个品牌包含以下字段：

**字段定义**：
| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| brand_name | 字符串 | 品牌名称 | "华为" |
| rank | 数字 | 推荐排名（1-10），未明确则为 -1 | 1 或 -1 |
| sentiment | 数字 | 情感倾向（-1.0 到 1.0） | 0.8 |
| is_top3 | 布尔值 | 是否进入 TOP3 | true |
| mention_context | 字符串 | 提及上下文摘要（≤50 字） | "华为 Mate 系列表现优异" |

**输出格式（非常重要，违反会导致解析失败）**：
- ⚠️ **必须输出纯 JSON，不要包含在 Markdown 代码块中**
- ⚠️ **不要使用 ```json 或 ``` 包裹 JSON 内容**
- ⚠️ **不要有任何额外说明文字，只输出 JSON**
{{
  "brands": [
    {{"brand_name": "品牌名", "rank": 数字， "sentiment": 数字， "is_top3": true/false, "mention_context": "上下文"}}
  ]
}}

**情感分数参考标准**：
- 强烈推荐/高度好评：0.8 ~ 1.0
- 正面推荐/好评：0.5 ~ 0.7
- 中性评价：-0.1 ~ 0.1
- 负面评价/不推荐：-1.0 ~ -0.5

**输出要求（违反会导致解析失败）**：
- ⚠️ **必须输出纯 JSON，不要 ```json 代码块标记**
- ⚠️ **不要包含任何解释性文字，只输出 JSON**
- ✓ 使用双引号，确保 JSON 合法
- ✓ brands 数组不能为空（若回答中无品牌，返回空数组 []）
- ✓ 字段类型必须正确：rank/is_top3 不是字符串

**自检清单（输出前检查）**：
- [ ] 是否提取了回答中所有提及的品牌？
- [ ] JSON 是否可以直接被 json.loads() 解析？
- [ ] 每个品牌的 rank 是否为数字（非字符串）？
- [ ] 每个品牌的 is_top3 是否为布尔值（非字符串）？
- [ ] sentiment 是否在 -1.0 到 1.0 范围内？
- [ ] **是否没有使用 Markdown 代码块包裹？**

**正确输出示例**：
{{"brands": [{{"brand_name": "华为", "rank": 1, "sentiment": 0.9, "is_top3": true, "mention_context": "华为 Mate 系列表现优异，强烈推荐"}}, {{"brand_name": "小米", "rank": 2, "sentiment": 0.7, "is_top3": true, "mention_context": "小米性价比高，适合预算有限用户"}}, {{"brand_name": "苹果", "rank": 3, "sentiment": 0.8, "is_top3": true, "mention_context": "苹果生态完善，但价格较高"}}]}}

**错误输出示例（禁止）**：
- × ```json{{...}}``` （不要代码块标记）
- × "这里是分析结果：{{...}}" （不要额外文字）
- × {{"brands": [{{"rank": "1"}}]}} （字段类型错误）
"""

class AIPlatformType(Enum):
    """支持的AI平台枚举"""
    DEEPSEEK = "deepseek"
    DEEPSEEKR1 = "deepseekr1"  # New DeepSeek R1 platform type
    CHATGPT = "chatgpt"
    CLAUDE = "claude"
    GEMINI = "gemini"
    QWEN = "qwen"
    WENXIN = "wenxin"
    DOUBAO = "doubao"
    KIMI = "kimi"
    YUANBAO = "yuanbao"
    SPARK = "spark"
    ZHIPU = "zhipu"
    OPENAI = "openai"
    ANTHROPIC = "anthropic"
    GOOGLE = "google"


class PlatformRegion(Enum):
    """AI 平台区域分类"""
    DOMESTIC = "domestic"  # 国内平台
    OVERSEAS = "overseas"  # 海外平台


# AI 平台区域分类映射
PLATFORM_REGION_MAP = {
    # 国内平台
    "deepseek": PlatformRegion.DOMESTIC,
    "deepseekr1": PlatformRegion.DOMESTIC,
    "qwen": PlatformRegion.DOMESTIC,
    "wenxin": PlatformRegion.DOMESTIC,
    "doubao": PlatformRegion.DOMESTIC,
    "kimi": PlatformRegion.DOMESTIC,
    "yuanbao": PlatformRegion.DOMESTIC,
    "spark": PlatformRegion.DOMESTIC,
    "zhipu": PlatformRegion.DOMESTIC,
    # 海外平台
    "chatgpt": PlatformRegion.OVERSEAS,
    "claude": PlatformRegion.OVERSEAS,
    "gemini": PlatformRegion.OVERSEAS,
    "openai": PlatformRegion.OVERSEAS,
    "anthropic": PlatformRegion.OVERSEAS,
    "google": PlatformRegion.OVERSEAS,
}


def get_platform_region(platform_name: str) -> Optional[PlatformRegion]:
    """
    获取 AI 平台所属区域
    
    Args:
        platform_name: 平台名称
        
    Returns:
        PlatformRegion: 平台区域，未知平台返回 None
    """
    return PLATFORM_REGION_MAP.get(platform_name.lower())


def validate_model_region_consistency(selected_models: List[str]) -> tuple[bool, Optional[str]]:
    """
    验证所选模型是否来自同一区域（国内或海外）
    
    Args:
        selected_models: 所选模型名称列表
        
    Returns:
        (is_valid, error_message): 验证结果和错误信息
    """
    if not selected_models:
        return True, None
    
    regions_found = {}
    
    for model_name in selected_models:
        region = get_platform_region(model_name)
        if region is None:
            # 未知区域的平台，跳过检查（兼容性考虑）
            continue
        
        region_key = region.value
        if region_key not in regions_found:
            regions_found[region_key] = []
        regions_found[region_key].append(model_name)
    
    # 检查是否同时存在国内和海外平台
    if PlatformRegion.DOMESTIC.value in regions_found and PlatformRegion.OVERSEAS.value in regions_found:
        domestic_models = regions_found[PlatformRegion.DOMESTIC.value]
        overseas_models = regions_found[PlatformRegion.OVERSEAS.value]
        
        error_msg = (
            f"不能同时选择国内和海外 AI 平台。"
            f"国内平台：{', '.join(domestic_models)}；"
            f"海外平台：{', '.join(overseas_models)}。"
            f"由于网络连接问题，请只选择国内平台或只选择海外平台。"
        )
        return False, error_msg
    
    return True, None


class AIErrorType(Enum):
    """标准化的AI错误类型枚举"""
    INVALID_API_KEY = "无效的API Key"
    INSUFFICIENT_QUOTA = "配额不足"
    CONTENT_SAFETY = "内容安全审查不通过"
    RATE_LIMIT_EXCEEDED = "请求频率超限"
    SERVER_ERROR = "平台服务器错误"
    SERVICE_UNAVAILABLE = "服务不可用（熔断中）"
    UNKNOWN_ERROR = "未知错误"

@dataclass
class AIResponse:
    """标准化的AI响应数据结构"""
    success: bool
    content: Optional[str] = None
    error_message: Optional[str] = None
    error_type: Optional[AIErrorType] = None # 新增错误类型字段
    model: Optional[str] = None
    platform: Optional[str] = None
    tokens_used: int = 0
    latency: float = 0.0
    metadata: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        """将响应对象转换为字典"""
        data = asdict(self)
        if self.error_type:
            data['error_type'] = self.error_type.value
        return data

