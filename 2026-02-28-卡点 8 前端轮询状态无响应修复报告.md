# 卡点 8 修复报告：前端轮询状态无响应（P0）

## 问题描述

**现象**: 用户反馈"启动诊断后，后台完成了，前端还是卡着的"
**日志**: 日志中没有 GET /test/status 的轮询记录

## 根本原因分析

经过代码审查，发现问题的根本原因是 **executionId 传递链路断裂**：

### 问题链路

```
report-v2.js (页面)
    ↓
    setData({ executionId })  // 仅设置页面 data
    ↓
diagnosisService.startPolling()
    ↓
    检查 this.currentTask  // ❌ 为 null！
    ↓
    抛出错误 "No active diagnosis task"
    ↓
错误被 catch 但用户无感知  // ❌ UI 卡住
```

### 具体原因

1. **report-v2.js** 在 `initPage()` 中通过 `setData({ executionId })` 设置 executionId
2. **report-v2.js** 调用 `startPolling()` 时，没有将 executionId 传递给 `diagnosisService`
3. **diagnosisService.js** 的 `startPolling()` 方法检查 `this.currentTask`，发现为 null
4. **diagnosisService** 抛出错误，但错误在 try-catch 中被静默处理
5. **用户界面** 卡住，没有错误提示，轮询从未启动

## 修复方案

### 修复 1: diagnosisService.js - 支持直接传入 executionId

**文件**: `miniprogram/services/diagnosisService.js`

```javascript
/**
 * 开始轮询诊断状态
 * @param {Object} callbacks - 回调函数
 * @param {string} executionId - 可选的执行 ID，如果提供则直接使用
 * @returns {string} 执行 ID
 */
startPolling(callbacks, executionId) {
  // P0 修复：支持直接传入 executionId 参数
  let task;
  
  if (executionId) {
    // 如果提供了 executionId，直接使用
    task = { executionId };
    console.log('[DiagnosisService] Starting polling with provided executionId:', executionId);
  } else if (this.currentTask || this.pendingTask) {
    // 使用 pendingTask 或 currentTask
    task = this.pendingTask || this.currentTask;
    executionId = task.executionId;
    console.log('[DiagnosisService] Starting polling for task:', executionId);
  } else {
    const error = new Error('No active diagnosis task');
    error.code = 'TASK_NOT_FOUND';
    throw error;
  }
  // ... 后续代码
}
```

### 修复 2: report-v2.js - 传递 executionId 给 diagnosisService

**文件**: `miniprogram/pages/report-v2/report-v2.js`

```javascript
async startPolling() {
  console.log('[ReportPageV2] Starting polling (fallback)...');

  // P0 修复：添加执行 ID 验证
  if (!this.data.executionId) {
    console.error('[ReportPageV2] 无法启动轮询：缺少 executionId');
    this.handleError(new Error('缺少 executionId，无法轮询'));
    return;
  }

  this.setData({
    isPolling: true,
    connectionMode: 'polling'
  });

  try {
    console.log('[ReportPageV2] 调用 diagnosisService.startPolling, executionId:', this.data.executionId);

    // P0 修复：直接传递 executionId 给 diagnosisService
    diagnosisService.startPolling({
      onStatus: this.handleStatusUpdate.bind(this),
      onComplete: this.handleComplete.bind(this),
      onError: this.handlePollingError.bind(this),
      onTimeout: this.handleTimeout.bind(this)
    }, this.data.executionId);  // ← 关键修复：传入 executionId

    console.log('[ReportPageV2] Polling started successfully');
  } catch (error) {
    console.error('[ReportPageV2] Failed to start polling:', error);
    this.handleError(error);
  }
}
```

### 修复 3: pollingManager.js - 增强调试日志

**文件**: `miniprogram/services/pollingManager.js`

添加了详细的日志输出，确保可以追踪轮询请求的完整生命周期：

1. **HTTP 轮询请求日志**: 记录请求 URL、executionId、时间戳
2. **HTTP 轮询响应日志**: 记录响应状态码、返回数据
3. **云函数轮询日志**: 记录请求和响应的完整信息
4. **错误日志**: 记录详细的错误信息和时间戳

## 修复后的执行流程

```
report-v2.js (页面)
    ↓
    initPage(options)
    ↓
    setData({ executionId: options.executionId })
    ↓
    startListening()
    ↓
    WebSocket 失败 → 降级到 startPolling()
    ↓
    startPolling()
    ↓
    diagnosisService.startPolling(callbacks, this.data.executionId)  ← 传入 executionId
    ↓
    pollingManager.startPolling(executionId, callbacks)
    ↓
    _poll(executionId) → _pollViaHttp() 或 _pollViaCloudFunction()
    ↓
    GET /test/status/{executionId}  ← 请求到达后端 ✅
    ↓
    状态更新回调 → UI 更新 ✅
```

## 验证方法

### 1. 本地开发环境验证

```bash
# 启动后端服务
python backend_python/app.py

# 在微信开发者工具中打开小程序
# 1. 启动诊断任务
# 2. 打开调试控制台
# 3. 观察日志输出
```

### 2. 预期日志输出

```
[ReportPageV2] Starting polling (fallback)...
[ReportPageV2] 调用 diagnosisService.startPolling, executionId: exec_12345
[DiagnosisService] Starting polling with provided executionId: exec_12345
[PollingManager] 开始轮询任务：{ executionId: 'exec_12345', ... }
[PollingManager] 通过云函数轮询：{ executionId: 'exec_12345', ... }
[PollingManager] 云函数轮询成功：{ executionId: 'exec_12345', status: 'processing', ... }
[ReportPageV2] 状态更新：{ progress: 10, stage: 'ai_fetching', ... }
```

### 3. 网络请求验证

在微信开发者工具的 Network 面板中应该看到：

```
GET /test/status/exec_12345
Status: 200 OK
Response: {
  "task_id": "exec_12345",
  "progress": 10,
  "stage": "ai_fetching",
  "status": "processing",
  "should_stop_polling": false,
  ...
}
```

## 修复清单

- [x] 修复 diagnosisService.js 支持直接传入 executionId
- [x] 修复 report-v2.js 传递 executionId 给 diagnosisService
- [x] 添加 pollingManager 的 HTTP 轮询详细日志
- [x] 添加 pollingManager 的云函数轮询详细日志
- [x] 确保错误能够正确传播到 UI 层

## 相关文件

| 文件 | 修改内容 |
|------|----------|
| `miniprogram/services/diagnosisService.js` | 支持直接传入 executionId 参数 |
| `miniprogram/pages/report-v2/report-v2.js` | 传递 executionId 给 diagnosisService |
| `miniprogram/services/pollingManager.js` | 增强调试日志 |

## 回归测试建议

1. **WebSocket 模式**: 验证 WebSocket 连接正常时不使用轮询
2. **轮询降级模式**: 验证 WebSocket 失败后正确降级到轮询
3. **直接轮询模式**: 验证直接传入 executionId 时轮询正常启动
4. **错误处理**: 验证 executionId 缺失时显示正确的错误提示
5. **网络请求**: 验证 GET /test/status 请求能够到达后端

## 总结

这是一个典型的 **参数传递丢失** 问题。页面层通过 `setData()` 设置了 executionId，但没有将其传递给服务层，导致服务层无法找到任务信息。修复方案是通过参数直接传递 executionId，而不是依赖服务层内部状态。

**修复优先级**: P0
**影响范围**: 所有使用轮询模式的诊断任务
**向后兼容**: 是（保留了原有的 currentTask/pendingTask 机制）
