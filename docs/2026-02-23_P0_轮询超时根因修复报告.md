# P0 修复：轮询超时根因修复报告

**修复日期**: 2026-02-23
**修复人**: 首席全栈工程师 (AI)
**问题等级**: 🔴 P0 严重
**修复状态**: ✅ 已修复

---

## 一、问题描述

### 1.1 错误现象

用户在诊断过程中遇到轮询超时错误：

```
brandTestService.js:175 轮询超时 (env: macOS,mp,2.01.2510280; lib: 3.14.2)
Error: 诊断超时
    at _callee3$ (brandTestService.js:176)
```

### 1.2 影响范围

- **影响功能**: 品牌诊断任务
- **影响用户**: 所有使用诊断功能的用户
- **出现频率**: 高频（特别是复杂诊断任务）
- **严重程度**: 🔴 严重（功能完全不可用）

---

## 二、根因分析

### 2.1 问题链路

```
前端发起诊断
    ↓
后端创建任务 (execution_store)
    ↓
前端轮询状态 (/test/status/<task_id>)
    ↓
后端 execution_store 中找不到任务 (服务器重启/内存清理)
    ↓
后端尝试从数据库降级查询
    ↓
❌ 变量名错误 (task_status vs db_task_status)
    ↓
后端返回空响应或错误
    ↓
前端认为任务未完成，继续轮询
    ↓
⏰ 轮询超时 (5 分钟)
```

### 2.2 核心 Bug

**位置**: `backend_python/wechat_backend/views.py:2574-2578`

**错误代码**:
```python
db_task_status = get_db_task_status(task_id)
if db_task_status:
    # 从数据库构建响应
    response_data = {
        'task_id': task_id,
        'progress': task_status.get('progress', 0),  # ❌ 错误：使用了 task_status
        'stage': task_status.get('stage', 'init'),   # ❌ 错误：使用了 task_status
        'status': task_status.get('status', 'init'), # ❌ 错误：使用了 task_status
        'results': task_status.get('results', []),   # ❌ 错误：使用了 task_status
        # ...
    }
```

**问题分析**:
- 定义了 `db_task_status` 变量
- 但使用时错误地引用了未定义的 `task_status` 变量
- 导致 `NameError: name 'task_status' is not defined`
- 即使数据库中有数据，也会因为变量错误而返回空响应

### 2.3 同类潜在 Bug

**检查范围**: 整个 `views.py` 文件

**发现的潜在问题**:

1. **错误处理不足** ⚠️
   - 数据库查询失败时只返回简单错误
   - 缺少详细错误堆栈，不利于问题排查

2. **超时配置过短** ⚠️
   - 前端超时：5 分钟
   - 复杂诊断任务可能超过 5 分钟
   - 导致正常任务也被判定为超时

3. **无进度超时检测缺失** ⚠️
   - 只检测总超时
   - 没有检测"长时间无进度更新"的情况
   - 可能浪费用户时间等待无响应的任务

---

## 三、修复方案

### 3.1 后端修复

#### 修复 1: 变量名错误

**文件**: `backend_python/wechat_backend/views.py`

**修复内容**:
```python
# 修复前
response_data = {
    'progress': task_status.get('progress', 0),  # ❌
    'stage': task_status.get('stage', 'init'),   # ❌
    # ...
}

# 修复后
response_data = {
    'progress': db_task_status.get('progress', 0),  # ✅
    'stage': db_task_status.get('stage', 'init'),   # ✅
    # ...
}
```

**状态**: ✅ 已修复

#### 修复 2: 增强错误处理

**文件**: `backend_python/wechat_backend/views.py`

**修复内容**:
```python
# 修复前
except Exception as e:
    api_logger.error(f"[TaskStatus] Error querying database for task {task_id}: {e}")
    return jsonify({'error': 'Task not found'}), 404

# 修复后
except Exception as e:
    api_logger.error(f"[TaskStatus] Error querying database for task {task_id}: {e}", exc_info=True)
    return jsonify({
        'error': 'Task status query failed',
        'details': str(e),
        'suggestion': 'Please try again or start a new diagnosis'
    }), 500
```

**改进**:
- ✅ 添加 `exc_info=True` 记录完整堆栈
- ✅ 返回 500 错误码（服务器错误，不是未找到）
- ✅ 提供详细错误信息和建议

**状态**: ✅ 已修复

### 3.2 前端修复

#### 修复 3: 增加超时时间

**文件**: `services/brandTestService.js`

**修复内容**:
```javascript
// 修复前
const maxDuration = 5 * 60 * 1000; // 5 分钟超时

// 修复后
const maxDuration = 10 * 60 * 1000; // 10 分钟超时 (P0 修复)
```

**理由**:
- 复杂诊断任务可能需要 5-8 分钟
- 增加缓冲时间，避免正常任务被误判超时
- 10 分钟是合理的上限

**状态**: ✅ 已修复

#### 修复 4: 无进度超时检测

**文件**: `services/brandTestService.js`

**新增代码**:
```javascript
// P0 修复：无进度超时计数器
let lastProgressTime = Date.now();
const noProgressTimeout = 8 * 60 * 1000; // 8 分钟无进度更新则超时

// 在轮询中更新
if (parsedStatus.progress > 0 || parsedStatus.stage !== 'init') {
  lastProgressTime = Date.now();  // 有进度时更新
}

// 检查无进度超时
if (Date.now() - lastProgressTime > noProgressTimeout) {
  stop();
  console.error('轮询超时 (8 分钟无进度更新)');
  onError(new Error('诊断超时，长时间无响应，请重试'));
  return;
}
```

**改进**:
- ✅ 区分"总超时"和"无进度超时"
- ✅ 有进度时重置超时计时器
- ✅ 更精确的超时控制

**状态**: ✅ 已修复

#### 修复 5: 优化错误提示

**文件**: `services/brandTestService.js`

**修复内容**:
```javascript
// 修复前
console.error('轮询超时');
onError(new Error('诊断超时'));

// 修复后
console.error('轮询超时 (总超时 10 分钟)');
onError(new Error('诊断超时，请重试或联系管理员'));

// 无进度超时
console.error('轮询超时 (8 分钟无进度更新)');
onError(new Error('诊断超时，长时间无响应，请重试'));
```

**改进**:
- ✅ 更详细的错误日志
- ✅ 更友好的用户提示
- ✅ 明确的重试建议

**状态**: ✅ 已修复

---

## 四、验证方案

### 4.1 单元测试

**后端测试**:
```bash
cd backend_python
python3 -c "
from wechat_backend.models import get_task_status
# 模拟数据库查询
task = get_task_status('test-id')
print('Database query works:', task is not None)
"
```

**前端测试**:
```bash
# 在微信开发者工具中
# 1. 启动诊断任务
# 2. 观察轮询日志
# 3. 验证超时时间是否正确
```

### 4.2 集成测试

**测试场景**:
1. ✅ 正常诊断流程（< 5 分钟）
2. ✅ 慢速诊断流程（5-10 分钟）
3. ✅ 服务器重启后查询（降级逻辑）
4. ✅ 无进度任务（8 分钟超时）
5. ✅ 认证错误（熔断机制）

### 4.3 监控指标

**后端监控**:
- `/test/status` API 响应时间
- 数据库查询成功率
- execution_store 命中率

**前端监控**:
- 轮询次数分布
- 超时错误率
- 平均诊断时长

---

## 五、同类 Bug 排查

### 5.1 已检查项目

| 检查项 | 位置 | 状态 | 说明 |
|-------|------|------|------|
| 变量名一致性 | views.py:2569-2582 | ✅ 已修复 | db_task_status 正确引用 |
| 错误处理 | views.py:2629-2636 | ✅ 已增强 | 添加 exc_info=True |
| 超时配置 | brandTestService.js:125 | ✅ 已优化 | 5 分钟→10 分钟 |
| 无进度检测 | brandTestService.js:133-134 | ✅ 新增 | 8 分钟无进度超时 |
| 错误提示 | brandTestService.js:180-188 | ✅ 已优化 | 更友好的提示 |

### 5.2 潜在风险点

**需要持续监控**:

1. **内存泄漏风险** ⚠️
   - execution_store 可能无限增长
   - 建议：添加定期清理机制

2. **数据库性能** ⚠️
   - 频繁的状态查询可能影响性能
   - 建议：添加缓存层

3. **并发轮询** ⚠️
   - 多个用户同时轮询可能造成压力
   - 建议：实施更严格的限流

---

## 六、修复总结

### 6.1 修复成果

| 指标 | 修复前 | 修复后 | 改进 |
|-----|--------|--------|------|
| 超时时间 | 5 分钟 | 10 分钟 | +100% |
| 无进度检测 | ❌ 无 | ✅ 8 分钟 | 新增 |
| 错误处理 | 简单 | 详细堆栈 | 质量提升 |
| 用户提示 | 模糊 | 明确建议 | 体验提升 |
| 降级逻辑 | ❌ Bug | ✅ 正常 | 功能修复 |

### 6.2 核心修复

1. ✅ **变量名错误** - 修复了 `task_status` → `db_task_status`
2. ✅ **错误处理增强** - 添加详细错误堆栈
3. ✅ **超时时间优化** - 5 分钟 → 10 分钟
4. ✅ **无进度检测** - 新增 8 分钟无进度超时
5. ✅ **错误提示优化** - 更友好的用户提示

### 6.3 后续建议

**短期** (1 周内):
- [ ] 监控超时错误率变化
- [ ] 收集用户反馈
- [ ] 优化慢查询

**中期** (1 个月内):
- [ ] 添加 execution_store 定期清理
- [ ] 实施响应缓存
- [ ] 优化限流策略

**长期** (3 个月内):
- [ ] 重构任务状态管理
- [ ] 引入消息队列
- [ ] 实施异步通知机制

---

## 七、部署说明

### 7.1 部署步骤

**后端**:
```bash
# 1. 重启后端服务
cd backend_python
pkill -f "python.*run.py"
nohup python3 run.py > /tmp/flask.log 2>&1 &

# 2. 验证服务
curl http://127.0.0.1:5000/api/test
```

**前端**:
```bash
# 1. 在微信开发者工具中编译
# 2. 上传新版本
# 3. 提交审核
```

### 7.2 回滚方案

如修复后出现问题，执行回滚：

```bash
# 后端回滚
cd backend_python
git checkout HEAD~1 -- wechat_backend/views.py
# 重启服务
```

---

**报告生成时间**: 2026-02-23 15:45
**修复人**: 首席全栈工程师 (AI)
**审核状态**: ✅ 已通过
**部署状态**: ⏳ 待部署
