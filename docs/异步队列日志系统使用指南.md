# 异步队列日志系统使用指南

**版本**: 1.0.0  
**实施日期**: 2026 年 2 月 19 日  
**状态**: P0 已完成 - 异步队列日志写入

---

## 快速开始

### 1. 初始化日志系统

在应用启动时初始化日志系统（推荐在 `main.py` 或 `run.py` 中）：

```python
from backend_python.logging import init_logging, shutdown_logging
import atexit

# 应用启动时初始化
logger_factory = init_logging(
    log_level='INFO',           # 日志级别
    log_dir='logs',             # 日志目录
    queue_size=10000,           # 队列大小
    max_bytes=10*1024*1024,     # 单个日志文件最大 10MB
    backup_count=7,             # 保留 7 个备份
)

# 注册关闭处理
atexit.register(shutdown_logging)
```

### 2. 使用日志器

```python
from backend_python.logging import get_logger

# 获取日志器
logger = get_logger('wechat_backend.api')

# 记录日志
logger.info('API 请求成功', endpoint='/api/ai/chat', user_id='user_001')
logger.error('处理失败', error=str(e), exc_info=True)
```

### 3. 链路追踪

```python
from backend_python.logging import get_logger, LoggingContext

logger = get_logger('wechat_backend.api')

# 方式 1: 手动设置上下文
logger.set_trace_context(trace_id='abc-123-xyz')
logger.info('开始处理请求')

# 方式 2: 使用上下文管理器 (推荐)
with LoggingContext(trace_id='abc-123', span_id='def-456'):
    logger.info('在上下文中记录日志')
# 退出 with 块后自动恢复原上下文
```

---

## 架构说明

### 异步队列日志架构

```
应用代码 -> UnifiedLogger -> QueueHandler -> Queue -> QueueListener -> Handlers -> Files/Console
```

**核心组件:**

| 组件 | 职责 |
|------|------|
| `UnifiedLogger` | 日志器门面，提供便捷的日志记录接口 |
| `QueueHandler` | 将日志记录放入队列 (非阻塞) |
| `Queue` | 日志队列 (容量 10000 条) |
| `QueueListener` | 后台线程监听器，消费队列中的日志 |
| `Handlers` | 日志处理器 (Console + File + AI 专用 + Error 专用) |

### 日志文件布局

```
logs/
├── app.log              # 应用日志 (轮转：app.log.1, app.log.2, ...)
├── ai_responses.log     # AI 响应专用日志
├── errors.log           # 错误日志 (仅 ERROR 及以上级别)
```

### 日志格式 (JSON)

```json
{
  "timestamp": "2026-02-19T10:30:00.123456+00:00",
  "level": "INFO",
  "logger": "wechat_backend.api",
  "message": "API 请求成功",
  "module": "api_handler",
  "function": "handle_request",
  "line": 42,
  "thread": "MainThread",
  "process": 12345,
  "trace_id": "abc-123-xyz",
  "span_id": "def-456",
  "endpoint": "/api/ai/chat",
  "user_id": "user_001"
}
```

---

## 配置选项

### 环境变量配置

| 变量名 | 默认值 | 说明 |
|--------|-------|------|
| `LOG_LEVEL` | `INFO` | 根日志级别 |
| `LOG_DIR` | `logs` | 日志目录 |
| `LOG_CONSOLE_LEVEL` | `INFO` | 控制台日志级别 |
| `LOG_FILE_LEVEL` | `DEBUG` | 文件日志级别 |
| `LOG_QUEUE_SIZE` | `10000` | 队列大小 |
| `USE_UNIFIED_LOGGING` | `true` | 是否使用新日志系统 |
| `LOG_ENABLE_AI_HANDLER` | `true` | 是否启用 AI 专用处理器 |

### 初始化参数

```python
init_logging(
    log_level='INFO',              # 根日志级别
    log_dir='logs',                # 日志目录
    queue_size=10000,              # 队列大小 (条)
    max_bytes=10*1024*1024,        # 文件最大大小 (字节)
    backup_count=7,                # 备份文件数量
    console_level='INFO',          # 控制台日志级别
    file_level='DEBUG',            # 文件日志级别
    enable_ai_handler=True,        # 是否启用 AI 专用处理器
    ai_max_bytes=100*1024*1024,    # AI 日志文件最大大小
    ai_backup_count=30,            # AI 日志备份数量
)
```

---

## 迁移指南

### 从旧日志系统迁移

#### 方式 1: 自动兼容 (推荐)

现有代码无需修改，兼容性包装器会自动使用新日志系统：

```python
# 旧代码保持不变
from .logging_config import app_logger, api_logger

app_logger.info('Hello, World!')
```

#### 方式 2: 显式迁移 (推荐新代码使用)

```python
# 新代码使用统一接口
from backend_python.logging import get_logger

logger = get_logger('wechat_backend.api')
logger.info('Hello, World!')
```

### 迁移检查清单

- [ ] 确认应用启动时调用了 `init_logging()`
- [ ] 确认应用关闭时调用了 `shutdown_logging()`
- [ ] 检查日志文件是否正常生成
- [ ] 验证日志格式为 JSON
- [ ] 确认性能指标符合预期 (延迟 <10ms)

---

## API 参考

### UnifiedLoggerFactory

```python
from backend_python.logging import UnifiedLoggerFactory

factory = UnifiedLoggerFactory()
factory.initialize(log_level='INFO', log_dir='logs')
logger = factory.get_logger('wechat_backend.api')
factory.shutdown()
```

### UnifiedLogger

```python
logger = get_logger('wechat_backend.api')

# 基本日志方法
logger.debug('调试信息')
logger.info('普通信息', extra_field='value')
logger.warning('警告信息')
logger.error('错误信息', exc_info=True)
logger.critical('严重错误')
logger.exception('异常信息')  # 自动包含堆栈

# 链路追踪
logger.set_trace_context(trace_id='abc-123')
context = logger.get_trace_context()
logger.clear_trace_context()
```

### LoggingContext

```python
from backend_python.logging import LoggingContext

# 使用上下文管理器
with LoggingContext(trace_id='abc-123', span_id='def-456'):
    logger.info('在上下文中')
```

### 便捷函数

```python
from backend_python.logging import (
    get_logger,              # 获取日志器
    init_logging,            # 初始化日志系统
    shutdown_logging,        # 关闭日志系统
    load_config,             # 加载 YAML 配置
    init_logging_from_config # 从配置初始化
)
```

---

## 最佳实践

### 1. 日志级别使用

| 级别 | 使用场景 |
|------|---------|
| `DEBUG` | 调试信息，开发环境使用 |
| `INFO` | 正常业务日志，如请求处理、状态变更 |
| `WARNING` | 警告信息，不影响业务但需要注意 |
| `ERROR` | 错误信息，影响业务但可恢复 |
| `CRITICAL` | 严重错误，系统不可用 |

### 2. 结构化日志

```python
# 推荐：使用关键字参数传递结构化数据
logger.info(
    'API 请求处理',
    endpoint='/api/ai/chat',
    method='POST',
    user_id='user_001',
    latency_ms=234,
    status_code=200
)

# 不推荐：将数据拼接到消息中
logger.info(f'API 请求处理 endpoint=/api/ai/chat method=POST ...')
```

### 3. 异常处理

```python
# 推荐：使用 exception() 或 error(exc_info=True)
try:
    process_data()
except Exception as e:
    logger.exception('处理失败', data_id='123')

# 不推荐：手动格式化异常
try:
    process_data()
except Exception as e:
    logger.error(f'处理失败：{e}')  # 丢失堆栈信息
```

### 4. 链路追踪

```python
# 在请求入口处设置 trace_id
@app.before_request
def before_request():
    trace_id = request.headers.get('X-Trace-ID')
    logger = get_logger('wechat_backend.api')
    logger.set_trace_context(trace_id=trace_id)

# 在请求出口处清除上下文
@app.teardown_request
def teardown_request(exc):
    logger = get_logger('wechat_backend.api')
    logger.clear_trace_context()
```

### 5. 性能考虑

```python
# 避免在低日志级别下执行昂贵操作
# 不推荐
logger.debug(f"Expensive operation result: {expensive_function()}")

# 推荐
if logger.logger.isEnabledFor(logging.DEBUG):
    logger.debug(f"Expensive operation result: {expensive_function()}")
```

---

## 故障排查

### 问题 1: 日志未生成

**检查项:**
1. 确认调用了 `init_logging()`
2. 检查日志目录权限
3. 确认日志级别设置正确

### 问题 2: 日志延迟高

**检查项:**
1. 检查队列是否已满 (`queue_size` 设置)
2. 检查磁盘 IO 性能
3. 确认 `QueueListener` 正常运行

### 问题 3: 日志丢失

**检查项:**
1. 确认应用关闭时调用了 `shutdown_logging()`
2. 检查队列大小是否足够
3. 查看是否有异常导致监听器停止

---

## 性能指标

| 指标 | 目标值 | 测量方法 |
|------|-------|---------|
| 日志吞吐量 | >10000 条/秒 | 压测 |
| 主线程延迟 | <1ms (P99) | 性能分析 |
| 队列容量 | 10000 条 | 配置 |
| 磁盘占用 | ~10MB/天 | 监控 |

---

## 后续规划

### P1 功能 (下一阶段)

- [ ] 结构化日志 + 链路追踪增强
- [ ] 日志采样策略
- [ ] 指标采集集成 (Prometheus)
- [ ] 日志生命周期管理 (轮转 + 压缩 + 清理)

### P2 功能 (未来规划)

- [ ] Sentry 错误追踪集成
- [ ] ELK/Loki 日志聚合配置
- [ ] 告警规则实现
- [ ] Grafana 可视化仪表板

---

## 附录

### A. 完整示例

```python
# main.py
from flask import Flask
from backend_python.logging import init_logging, shutdown_logging, get_logger, LoggingContext
import atexit

# 初始化日志系统
logger_factory = init_logging(
    log_level='INFO',
    log_dir='logs',
    queue_size=10000,
)

# 注册关闭处理
atexit.register(shutdown_logging)

# 创建 Flask 应用
app = Flask(__name__)
logger = get_logger('wechat_backend.api')

@app.before_request
def before_request():
    # 设置链路追踪
    from flask import request
    trace_id = request.headers.get('X-Trace-ID')
    logger.set_trace_context(trace_id=trace_id)

@app.route('/api/ai/chat', methods=['POST'])
def chat():
    with LoggingContext():  # 自动管理上下文
        logger.info('收到聊天请求')
        try:
            # 处理逻辑
            response = process_chat()
            logger.info('处理成功', latency_ms=234)
            return response
        except Exception as e:
            logger.exception('处理失败')
            return {'error': str(e)}, 500

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```

### B. 相关文件

| 文件 | 说明 |
|------|------|
| `backend_python/logging/unified_logger.py` | 核心日志工厂和日志器 |
| `backend_python/logging/config_loader.py` | YAML 配置加载器 |
| `backend_python/config/logging.yaml` | 日志配置文件 |
| `backend_python/wechat_backend/logging_config.py` | 兼容性包装器 |
| `docs/日志技术架构诊断与优化报告.md` | 完整技术报告 |
