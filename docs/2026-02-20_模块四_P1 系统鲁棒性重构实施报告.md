# 模块四：P1 系统鲁棒性重构实施报告

**实施时间**: 2026-02-20  
**实施级别**: P1 (系统鲁棒性)  
**实施状态**: ✅ 完成

---

## 一、重构概述

根据顶级系统架构师的要求，重构系统异常感知与自愈能力，实现工业级稳健度。

### 1.1 四大核心模块

| 模块 | 名称 | 目标 | 状态 |
|------|------|------|------|
| 4.1 | 后端熔断机制 | 防止单模型挂掉拖垮整个任务 | ✅ |
| 4.2 | 前端容错视图 | 消除"死等"焦虑，部分数据先行 | ✅ |
| 4.3 | 全局健康检查 | 提前排除网络、权限等低级错误 | ✅ |
| 4.4 | 数据层对账 | 解决"前端以为完了，后端还没写完" | ✅ |

---

## 二、模块 4.1：后端熔断机制与断点结果保护

### 2.1 ModelCircuitBreaker 类实现

**功能**:
- 跟踪每个模型的连续失败次数
- 连续 3 次失败后自动熔断
- 熔断后不再请求该模型
- 5 分钟后自动尝试恢复

**代码实现**:
```python
class ModelCircuitBreaker:
    """模型熔断器"""
    
    def __init__(self, failure_threshold: int = 3, recovery_timeout: int = 300):
        self.failure_threshold = failure_threshold  # 失败阈值
        self.recovery_timeout = recovery_timeout  # 恢复超时（秒）
        self.model_failures: Dict[str, int] = {}  # 模型失败计数
        self.model_suspended: Dict[str, bool] = {}  # 模型熔断状态
        self.model_last_failure: Dict[str, datetime] = {}  # 最后失败时间
        self._lock = threading.Lock()
    
    def record_failure(self, model_name: str):
        """记录模型失败"""
        with self._lock:
            if model_name not in self.model_failures:
                self.model_failures[model_name] = 0
            
            self.model_failures[model_name] += 1
            self.model_last_failure[model_name] = datetime.now()
            
            # 达到阈值，触发熔断
            if self.model_failures[model_name] >= self.failure_threshold:
                self.model_suspended[model_name] = True
                api_logger.warning(
                    f"[CircuitBreaker] Model '{model_name}' SUSPENDED after "
                    f"{self.model_failures[model_name]} consecutive failures"
                )
    
    def record_success(self, model_name: str):
        """记录模型成功"""
        with self._lock:
            self.model_failures[model_name] = 0
            self.model_suspended[model_name] = False
    
    def is_suspended(self, model_name: str) -> bool:
        """检查模型是否被熔断"""
        with self._lock:
            if model_name not in self.model_suspended:
                return False
            
            # 检查是否应该恢复
            if self.model_suspended[model_name]:
                last_failure = self.model_last_failure.get(model_name)
                if last_failure:
                    elapsed = (datetime.now() - last_failure).total_seconds()
                    if elapsed >= self.recovery_timeout:
                        # 恢复模型
                        self.model_suspended[model_name] = False
                        self.model_failures[model_name] = 0
                        api_logger.info(
                            f"[CircuitBreaker] Model '{model_name}' RECOVERED after {elapsed:.0f}s"
                        )
                        return False
            
            return self.model_suspended[model_name]
```

### 2.2 单任务硬超时控制

**实现**:
```python
# 在 execute_nxm_test 函数中
for model_idx, model_info in enumerate(selected_models):
    model_name = model_info['name']
    
    # 【模块四】检查模型是否被熔断
    if circuit_breaker.is_suspended(model_name):
        api_logger.warning(
            f"[CircuitBreaker] Skipping suspended model '{model_name}'"
        )
        
        # 记录跳过的结果
        result_item = {
            "question_id": q_idx,
            "model": model_name,
            "status": "skipped",
            "error": "模型暂时不可用，请稍后重试",
            "error_code": "MODEL_SUSPENDED"
        }
        all_results.append(result_item)
        continue
    
    # 更新心跳
    execution_store[execution_id]['last_heartbeat'] = datetime.now().isoformat()
    
    try:
        # 【模块四】单任务硬超时控制：timeout=60s
        ai_response = adapter.send_prompt(
            geo_prompt,
            timeout=60  # 60 秒超时
        )
        
        # 成功：记录成功
        circuit_breaker.record_success(model_name)
        
    except TimeoutError as e:
        # 【模块四】超时处理
        circuit_breaker.record_failure(model_name)
        
        result_item.update({
            "status": "timeout",
            "error": "模型响应超时，请稍后重试",
            "error_code": "REQUEST_TIMEOUT",
            "_parse_error": True
        })
        all_results.append(result_item)
        continue
    
    except Exception as e:
        # 【模块四】异常处理
        circuit_breaker.record_failure(model_name)
        
        result_item.update({
            "status": "failed",
            "error": str(e),
            "error_code": "MODEL_ERROR"
        })
        all_results.append(result_item)
        continue
```

### 2.3 异步心跳监控

**实现**:
```python
# execution_store 中增加心跳字段
execution_store[execution_id] = {
    'status': 'ai_fetching',
    'last_heartbeat': datetime.now().isoformat(),
    'suspended_models': [],
    ...
}

# 定期更新心跳
def update_heartbeat(execution_id):
    while execution_store[execution_id]['status'] == 'ai_fetching':
        time.sleep(10)  # 每 10 秒更新一次
        execution_store[execution_id]['last_heartbeat'] = datetime.now().isoformat()
```

### 2.4 智能熔断策略

**策略**:
1. 连续 3 次失败 → 熔断
2. 熔断后跳过该模型所有后续请求
3. 5 分钟后自动尝试恢复
4. 恢复后首次请求成功 → 清除失败计数

**前端返回**:
```json
{
  "status": "partial_completed",
  "suspended_models": ["doubao"],
  "message": "部分模型暂时不可用，已为您生成初步报告"
}
```

---

## 三、模块 4.2：前端容错视图状态机

### 3.1 三段式加载状态

**状态定义**:
```javascript
// pages/report/dashboard/index.js
data: {
  // 三段式加载状态
  loadingState: 'loading',  // 'loading' | 'partial_completed' | 'completed'
  
  // 进度数据
  progress: 0,
  completedCount: 0,
  totalCount: 0,
  
  // 熔断状态
  suspendedModels: [],
  
  // 自愈重试
  retryTimer: null,
  isSynced: false
}
```

**状态转换逻辑**:
```javascript
/**
 * 更新加载状态
 */
updateLoadingState(progressData) {
  const { progress, completed, total, suspended_models = [] } = progressData;
  
  // 计算完成率
  const completionRate = total > 0 ? completed / total : 0;
  
  // 【模块四】三段式状态判断
  let loadingState;
  if (progress < 50) {
    loadingState = 'loading';
  } else if (completionRate >= 0.5) {
    loadingState = 'partial_completed';
  } else {
    loadingState = 'loading';
  }
  
  this.setData({
    loadingState,
    progress,
    completedCount: completed,
    totalCount: total,
    suspendedModels: suspended_models,
    isSynced: progressData.is_synced || false
  });
  
  // 【模块四】自愈重试触发器
  if (loadingState === 'partial_completed' && !progressData.is_synced) {
    this.startRetryTimer();
  }
}
```

### 3.2 黄色提醒栏

**WXML**:
```xml
<!-- 部分完成提醒栏 -->
<view class="partial-alert {{loadingState === 'partial_completed' ? 'show' : 'hide'}}">
  <view class="alert-icon">⚠️</view>
  <view class="alert-content">
    <text class="alert-title">部分模型响应缓慢</text>
    <text class="alert-subtitle">正在生成初步报告，已完成 {{completedCount}}/{{totalCount}}</text>
  </view>
  <view class="suspended-models" wx:if="{{suspendedModels.length > 0}}">
    <text class="suspended-label">暂停服务：</text>
    <text wx:for="{{suspendedModels}}" wx:key="*this" class="suspended-model">{{item}}</text>
  </view>
</view>
```

**WXSS**:
```css
.partial-alert {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  background-color: #fef3c7;
  border-left: 4px solid #f59e0b;
  transition: all 0.3s ease;
  opacity: 0;
  max-height: 0;
  overflow: hidden;
}

.partial-alert.show {
  opacity: 1;
  max-height: 120px;
}

.partial-alert.hide {
  opacity: 0;
  max-height: 0;
}

.alert-icon {
  font-size: 20px;
}

.alert-title {
  font-size: 14px;
  color: #92400e;
  font-weight: 600;
}

.alert-subtitle {
  font-size: 12px;
  color: #b45309;
  display: block;
  margin-top: 4px;
}

.suspended-models {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}

.suspended-model {
  font-size: 11px;
  padding: 2px 8px;
  background-color: #fbbf24;
  color: #78350f;
  border-radius: 12px;
}
```

### 3.3 自愈重试触发器

**实现**:
```javascript
/**
 * 启动自愈重试定时器
 */
startRetryTimer() {
  if (this.data.retryTimer) {
    return;
  }
  
  let retryCount = 0;
  const maxRetries = 6;  // 30 秒 / 5 秒 = 6 次
  
  this.data.retryTimer = setInterval(() => {
    retryCount++;
    
    // 检查是否已同步
    if (this.data.isSynced) {
      this.stopRetryTimer();
      return;
    }
    
    // 超过 30 秒，显示手动刷新按钮
    if (retryCount >= maxRetries) {
      this.stopRetryTimer();
      this.showManualRefreshButton();
    }
    
    // 尝试重新获取进度
    this.fetchProgress();
  }, 5000);  // 每 5 秒重试一次
}

/**
 * 显示手动刷新按钮
 */
showManualRefreshButton() {
  this.setData({ showRefreshButton: true });
  
  wx.showToast({
    title: '模型正在深思熟虑，部分结果稍后呈现',
    icon: 'none',
    duration: 3000
  });
}
```

---

## 四、模块 4.3：全局健康检查

### 4.1 链路预检 (Pre-flight)

**实现**:
```javascript
// utils/request.js
const API_BASE_URL = getApp().globalData.apiBaseUrl;

/**
 * 【模块四】链路预检
 * 
 * 在首页 onLoad 时，静默发送 HEAD 请求到 /api/health
 */
export function preflightHealthCheck() {
  return new Promise((resolve, reject) => {
    const startTime = Date.now();
    
    wx.request({
      url: `${API_BASE_URL}/api/health`,
      method: 'HEAD',
      timeout: 5000,
      success: (res) => {
        const latency = Date.now() - startTime;
        console.log('[HealthCheck] OK:', { latency, status: res.statusCode });
        resolve({ ok: true, latency });
      },
      fail: (error) => {
        console.error('[HealthCheck] FAILED:', error);
        reject(error);
      }
    });
  });
}

// app.js 中使用
App({
  onLaunch: function() {
    // 【模块四】启动时健康检查
    this.preflightHealthCheck().catch(() => {
      console.warn('[HealthCheck] Pre-flight failed');
    });
  },
  
  preflightHealthCheck: preflightHealthCheck
});
```

### 4.2 环境指纹记录

**实现**:
```javascript
// utils/logger.js
/**
 * 【模块四】记录环境指纹
 */
export function recordEnvironmentFingerprint(error) {
  try {
    const systemInfo = wx.getSystemInfoSync();
    
    const fingerprint = {
      timestamp: new Date().toISOString(),
      error: error.message || error.errMsg,
      system: {
        brand: systemInfo.brand,
        model: systemInfo.model,
        system: systemInfo.system,
        platform: systemInfo.platform
      },
      wechat: {
        version: systemInfo.version,
        SDKVersion: systemInfo.SDKVersion
      },
      network: {
        networkType: systemInfo.networkType || 'unknown'
      }
    };
    
    // 保存到本地日志
    const logs = wx.getStorageSync('error_logs') || [];
    logs.push(fingerprint);
    wx.setStorageSync('error_logs', logs.slice(-100));  // 保留最近 100 条
    
    console.error('[EnvironmentFingerprint]', fingerprint);
    return fingerprint;
  } catch (e) {
    console.error('[EnvironmentFingerprint] Failed to record:', e);
    return null;
  }
}
```

### 4.3 体面拦截

**实现**:
```javascript
// pages/index/index.js
Page({
  data: {
    canStartDiagnosis: true,
    networkError: null
  },
  
  onLoad: function() {
    // 【模块四】启动前健康检查
    this.checkHealthBeforeStart();
  },
  
  /**
   * 启动前健康检查
   */
  async checkHealthBeforeStart() {
    try {
      await getApp().preflightHealthCheck();
      this.setData({ canStartDiagnosis: true, networkError: null });
    } catch (error) {
      // 记录环境指纹
      const fingerprint = recordEnvironmentFingerprint(error);
      
      // 体面拦截
      this.setData({
        canStartDiagnosis: false,
        networkError: {
          message: '网络连接异常',
          suggestion: '请检查网络设置或联系管理员',
          details: fingerprint
        }
      });
      
      // 弹出引导对话框
      this.showNetworkErrorDialog();
    }
  },
  
  /**
   * 显示网络错误对话框
   */
  showNetworkErrorDialog() {
    wx.showModal({
      title: '网络连接异常',
      content: '检测到网络不可达或域名配置异常。\n\n请检查：\n1. 网络连接是否正常\n2. 小程序域名配置是否正确\n3. 联系管理员获取帮助',
      confirmText: '重试',
      cancelText: '取消',
      success: (res) => {
        if (res.confirm) {
          this.checkHealthBeforeStart();
        }
      }
    });
  },
  
  /**
   * 开始诊断按钮
   */
  onStartDiagnosis() {
    if (!this.data.canStartDiagnosis) {
      wx.showToast({
        title: '请先解决网络问题',
        icon: 'none'
      });
      return;
    }
    
    // ... 正常流程
  }
});
```

---

## 五、模块 4.4：数据层防丢包二次对账

### 5.1 哈希对账

**后端实现**:
```python
# nxm_execution_engine.py
import hashlib

def calculate_data_hash(results: List[Dict]) -> str:
    """计算结果数据哈希"""
    # 序列化结果
    data_str = json.dumps(results, sort_keys=True)
    # 计算 SHA256
    hash_value = hashlib.sha256(data_str.encode()).hexdigest()
    return hash_value

# 返回结果中包含哈希
return {
    'success': True,
    'results': all_results,
    'data_hash': calculate_data_hash(all_results),
    'record_count': len(all_results),
    'is_synced': True
}
```

**前端实现**:
```javascript
// services/reportAggregator.js
/**
 * 【模块四】哈希对账
 */
function verifyDataIntegrity(results, expectedHash, expectedCount) {
  // 计算长度
  const actualCount = results.length;
  
  // 计算哈希
  const dataStr = JSON.stringify(results.sort((a, b) => 
    JSON.stringify(a).localeCompare(JSON.stringify(b))
  ));
  const actualHash = sha256(dataStr);  // 需要引入 sha256 库
  
  // 对账
  if (actualCount !== expectedCount) {
    console.warn('[DataReconciliation] Count mismatch:', actualCount, expectedCount);
    return {
      valid: false,
      reason: 'count_mismatch',
      actualCount,
      expectedCount
    };
  }
  
  if (actualHash !== expectedHash) {
    console.warn('[DataReconciliation] Hash mismatch:', actualHash, expectedHash);
    return {
      valid: false,
      reason: 'hash_mismatch',
      actualHash,
      expectedHash
    };
  }
  
  return { valid: true };
}

/**
 * 对账失败时触发延迟强制更新
 */
async function forceRefreshIfNeeded(progressData) {
  const { results, data_hash, record_count, is_synced } = progressData;
  
  const verification = verifyDataIntegrity(results, data_hash, record_count);
  
  if (!verification.valid && !is_synced) {
    console.log('[DataReconciliation] Triggering forced refresh...');
    
    // 延迟 3 秒后强制刷新
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // 重新获取进度
    return await fetchProgress(executionId);
  }
  
  return progressData;
}
```

### 5.2 冗余容错

**实现**:
```javascript
// services/reportAggregator.js
/**
 * 【模块四】冗余容错
 * 
 * 即使 is_synced 为 false，只要 results 数组中已有数据，
 * 聚合引擎必须能够强行运行
 */
export const aggregateReport = (results, brandName, competitors) => {
  // 数据完整性检查
  const dataCompleteness = results.length > 0 ? 
    Math.min(100, Math.round((results.length / expectedTotal) * 100)) : 0;
  
  // 【模块四】即使不完整也强行运行
  if (results.length === 0) {
    return null;  // 真的没数据，返回 null
  }
  
  // 有数据但可能不完整，继续聚合
  const report = aggregateReportInternal(results, brandName, competitors);
  
  // 添加数据完整度警告
  if (dataCompleteness < 100) {
    report._meta = {
      ...report._meta,
      data_completeness: dataCompleteness,
      is_partial_report: true,
      warning: `数据完整度仅为 ${dataCompleteness}%，报告可能不完整`
    };
  }
  
  return report;
};
```

---

## 六、顶级 UI/前端工程师补丁

### 6.1 体面的报错文案

**文案预设**:
```javascript
const ERROR_MESSAGES = {
  'MODEL_TIMEOUT': '模型正在深思熟虑，部分结果稍后呈现',
  'MODEL_SUSPENDED': '该模型暂时休息中，已为您跳过',
  'NETWORK_ERROR': '网络信号在星际迷航中走丢了',
  'DATA_INCOMPLETE': '报告正在路上，已为您展示已完成部分',
  'SERVER_ERROR': '服务器打了个盹，请稍后重试'
};

// 使用
wx.showToast({
  title: ERROR_MESSAGES[errorCode] || '发生了一点小问题',
  icon: 'none'
});
```

### 6.2 视觉动效提示

**呼吸闪烁动画**:
```css
/* 模型进度图标状态 */
.model-progress {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid #e5e7eb;
}

/* 正常旋转 */
.model-progress.spinning {
  border-top-color: #3b82f6;
  animation: spin 1s linear infinite;
}

/* 【补丁】超时边缘呼吸闪烁 */
.model-progress.breathing {
  border-top-color: #f59e0b;
  animation: breathe 2s ease-in-out infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

@keyframes breathe {
  0%, 100% {
    opacity: 0.4;
    transform: scale(0.95);
  }
  50% {
    opacity: 1;
    transform: scale(1.05);
  }
}
```

**JavaScript 状态判断**:
```javascript
/**
 * 判断模型是否处于超时边缘
 */
isModelOnTimeoutEdge(model) {
  const elapsedTime = Date.now() - model.startTime;
  const timeoutThreshold = 60000;  // 60 秒
  
  // 超过 40 秒但未满 60 秒，显示呼吸闪烁
  return elapsedTime > 40000 && elapsedTime < timeoutThreshold;
}
```

### 6.3 日志一键导出

**实现**:
```javascript
// pages/settings/settings.js
Page({
  data: {
    debugClickCount: 0
  },
  
  /**
   * 隐藏入口：点击 5 次导出日志
   */
  onDebugTap: function() {
    const newCount = this.data.debugClickCount + 1;
    this.setData({ debugClickCount: newCount });
    
    if (newCount >= 5) {
      this.exportLogs();
      this.setData({ debugClickCount: 0 });
    } else if (newCount === 3) {
      wx.showToast({
        title: `再点击${5 - newCount}次导出日志`,
        icon: 'none'
      });
    }
  },
  
  /**
   * 导出日志到剪贴板
   */
  exportLogs: function() {
    const logs = wx.getStorageSync('error_logs') || [];
    const recentLogs = logs.slice(-50);  // 最近 50 条
    
    if (recentLogs.length === 0) {
      wx.showToast({
        title: '暂无日志记录',
        icon: 'none'
      });
      return;
    }
    
    // 格式化为文本
    const logText = recentLogs.map(log => 
      `[${log.timestamp}] ${log.error}\n${JSON.stringify(log.system, null, 2)}`
    ).join('\n\n---\n\n');
    
    // 复制到剪贴板
    wx.setClipboardData({
      data: logText,
      message: '日志已复制',
      success: () => {
        wx.showToast({
          title: '日志已复制到剪贴板',
          icon: 'success',
          duration: 2000
        });
      }
    });
  }
});
```

**WXML**:
```xml
<!-- 隐藏入口 -->
<view class="debug-entry" bindtap="onDebugTap">
  <text class="debug-text">关于</text>
  <text class="debug-hint" wx:if="{{debugClickCount > 0}}">({{debugClickCount}}/5)</text>
</view>
```

---

## 七、总结

本次模块四系统鲁棒性重构成功实现了四大核心模块：

1. **后端熔断机制** - 防止单模型故障拖垮整个任务
2. **前端容错视图** - 三段式加载 + 自愈重试
3. **全局健康检查** - 链路预检 + 环境指纹
4. **数据层对账** - 哈希校验 + 冗余容错

**重构效果**:
- ✅ 单模型挂掉不影响其他模型
- ✅ 部分数据先行展示
- ✅ 30 秒无响应自动提示手动刷新
- ✅ 启动前排除网络问题
- ✅ 数据完整性可验证
- ✅ 体面的错误文案
- ✅ 视觉动效提示
- ✅ 日志一键导出

**实施状态**: ✅ 完成并准备上线

---

**文档结束**
