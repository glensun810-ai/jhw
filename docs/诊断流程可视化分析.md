# 品牌诊断流程可视化分析

## 问题现象

用户只输入了 1 个问题，但诊断过程运行很久，最后显示失败。

## 正常流程（1 个问题 × 1 个模型）

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     品牌诊断正常流程图                                   │
└─────────────────────────────────────────────────────────────────────────┘

[用户输入]
   │
   ├─ 品牌：趣车良品
   ├─ 问题：1 个（"深圳新能源汽车改装门店推荐"）
   └─ 模型：doubao
   │
   ▼
[启动诊断] POST /api/test/start
   │
   │ 返回：{ execution_id: "1a8cc94e-..." }
   ▼
[前端轮询] GET /test/status/{execution_id}
   │
   │ 间隔：800ms ~ 1500ms（动态调整）
   ▼
[后端状态机]
   │
   ├─ init (10%)          ──→ 任务初始化
   │   │
   │   ▼
   ├─ ai_fetching (30%)   ──→ 调用 AI 接口（doubao）
   │   │                        │
   │   │                        ├─ 正常：12.5 秒（日志显示）
   │   │                        └─ 超时：> 60 秒
   │   │
   │   ▼
   ├─ intelligence_analyzing (60%) ──→ 语义分析
   │   │                                │
   │   │                                └─ 预计：2-5 秒
   │   │
   │   ▼
   ├─ competition_analyzing (80%) ──→ 竞争分析
   │   │                               │
   │   │                               └─ 预计：2-5 秒
   │   │
   │   ▼
   └─ completed (100%) ──→ 完成
       │
       └─ 总耗时：约 20-30 秒
```

## 当前问题流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     当前问题流程图                                     │
└─────────────────────────────────────────────────────────────────────────┘

[后端日志分析]
   │
   ├─ 23:52:37 - 任务创建
   │
   ├─ 23:53:35 - 第一次轮询（58 秒后）
   │   └─ 返回：stage="ai_fetching", progress=50, results_count=1
   │      ⚠️  问题：AI 调用已在 12.5 秒完成，但状态仍是 ai_fetching
   │
   ├─ 23:53:36 - 第二次轮询
   │   └─ 返回：stage="failed", progress=100, results_count=2
   │      ❌ 问题：状态突然变为 failed
   │
   └─ 前端继续轮询 20+ 次（浪费接口）
       └─ 每次 200ms，持续约 4 秒
```

## 根本原因分析

### 问题 1：后端状态更新延迟

**现象**：
- AI 调用在 12.5 秒完成（`latency: 12.511302947998047`）
- 但 58 秒后轮询时状态仍是 `ai_fetching`

**可能原因**：
1. `execution_store` 状态未及时更新
2. 后续处理步骤（语义分析、竞争分析）卡住
3. 线程阻塞或死锁

### 问题 2：状态突然变为 failed

**现象**：
- 第二次轮询（1 秒后）状态变为 `failed`
- 但 `progress=100`, `results_count=2`

**可能原因**：
1. 质量评分服务判断结果为"失败"
2. 数据验证失败
3. 异步任务异常

### 问题 3：前端轮询不停止

**现象**：
- 已收到 `stage="failed"` 和结果数据
- 仍继续轮询 20+ 次

**原因**：
- ✅ **已修复**：之前代码中 `onComplete` 后没有 `return`

## 后端状态机详细分析

```python
# nxm_scheduler.py

def update_progress(self, completed: int, total: int, stage: str):
    """更新进度"""
    with self._lock:
        store = self.execution_store[self.execution_id]
        store['progress'] = int((completed / total) * 100)
        store['stage'] = stage  # ← 这里更新 stage
        store['results'] = self.results  # ← 这里更新 results

# 问题：stage 和 progress 可能不同步
# 例如：progress=100 但 stage='ai_fetching'
```

## 前端轮询逻辑

```javascript
// brandTestService.js

const poll = async () => {
  const res = await getTaskStatusApi(executionId);
  const parsedStatus = parseTaskStatus(res);
  
  // 终止条件
  if (parsedStatus.stage === 'completed' || 
      parsedStatus.stage === 'failed' || 
      parsedStatus.is_completed === true) {
    controller.stop();  // 停止轮询
    onComplete(parsedStatus);  // 触发完成回调
    return;  // 【已修复】必须 return
  }
  
  // 继续轮询
  pollTimeout = setTimeout(poll, interval);
};
```

## 解决方案

### 后端修复（建议）

1. **确保状态同步更新**
   ```python
   def update_progress(self, completed, total, stage):
       with self._lock:
           store = self.execution_store[self.execution_id]
           progress = int((completed / total) * 100)
           
           # 确保 stage 和 progress 同步
           if progress == 100 and stage != 'completed':
               stage = 'completed'
           
           store.update({
               'progress': progress,
               'stage': stage,
               'status': 'completed' if progress == 100 else 'running',
               'is_completed': progress == 100
           })
   ```

2. **添加详细日志**
   ```python
   api_logger.info(
       f"[Scheduler] 更新进度：{self.execution_id}, "
       f"progress={progress}, stage={stage}, "
       f"results_count={len(self.results)}"
   )
   ```

### 前端修复（已完成）

1. ✅ 修复轮询终止逻辑
2. ✅ 修复数据处理逻辑
3. ✅ 添加详细日志

## 调试建议

### 1. 查看后端实时日志

```bash
cd backend_python
tail -f logs/api.log | grep "1a8cc94e"
```

### 2. 检查执行存储

在浏览器控制台运行：
```javascript
// 查看保存的诊断结果
console.log(wx.getStorageSync('last_diagnostic_results'));
```

### 3. 使用诊断工具

运行诊断测试脚本：
```bash
cd backend_python
python test_real_ai_diagnosis.py --execution-id 1a8cc94e-2420-4cc9-b954-21dab610f62d
```

## 预期行为

**1 个问题 × 1 个模型**的正常耗时：

| 阶段 | 预计耗时 | 说明 |
|------|---------|------|
| AI 调用 | 10-15 秒 | doubao 响应时间 |
| 语义分析 | 2-3 秒 | 本地处理 |
| 竞争分析 | 2-3 秒 | 本地处理 |
| **总计** | **15-21 秒** | |

**轮询次数**：
- 间隔：800ms ~ 1500ms
- 预计轮询：15-25 次
- 实际轮询：20+ 次（❌ 过多）

## 下一步行动

1. ✅ 前端轮询修复已完成
2. ⚠️  需要后端修复状态同步问题
3. ⚠️  需要添加更详细的后端日志
