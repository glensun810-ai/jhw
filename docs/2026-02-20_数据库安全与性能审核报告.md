数据库安全与性能审核报告
审核日期: 2026-02-20
审核人: AI Assistant (系统安全和性能管理专家)
审核范围: 阶段 3 数据库及持久化服务
风险等级: 🔴 高风险项 3 个 | 🟡 中风险项 5 个 | 🟢 低风险项 4 个
📋 执行摘要
风险概览
风险等级
数量
优先级
🔴 高风险
3
立即修复
🟡 中风险
5
近期修复
🟢 低风险
4
持续优化
核心发现
类别
评分
状态
安全性
6/10
⚠️ 需改进
性能
7/10
⚠️ 良好
可靠性
6/10
⚠️ 需改进
可维护性
7/10
⚠️ 良好
扩展性
5/10
⚠️ 需改进
🔴 高风险项 (立即修复)
风险 1: SQL 注入风险
位置: realtime_persistence.py
问题代码:
# ❌ 风险：虽然使用了参数化查询，但表名硬编码
safe_query.execute_query('''
    INSERT INTO aggregated_results
    (execution_id, main_brand, health_score, sov, avg_sentiment, 
     success_rate, total_tests, total_mentions, created_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
''', (...))
风险分析:
•
✅ 使用了参数化查询 (?)
•
❌ 但 execution_id 等用户输入未经过严格验证
•
❌ 缺少输入长度限制
•
❌ 缺少特殊字符过滤
影响:
•
恶意用户可能注入 SQL 代码
•
数据可能被篡改
•
数据库可能被删除
修复建议:
# ✅ 修复：添加输入验证
def validate_input(value, max_length=255):
    """验证输入"""
    if not value or not isinstance(value, str):
        raise ValueError("Invalid input")
    if len(value) > max_length:
        raise ValueError("Input too long")
    # 过滤危险字符
    dangerous_chars = [';', '--', '/*', '*/', 'DROP', 'DELETE', 'TRUNCATE']
    for char in dangerous_chars:
        if char.upper() in value.upper():
            raise ValueError("Dangerous characters detected")
    return value

# 使用验证
execution_id = validate_input(task_data.get('execution_id', ''), max_length=64)
main_brand = validate_input(task_data.get('main_brand', ''), max_length=100)
优先级: 🔴 P0 - 立即修复
风险 2: 数据库连接未关闭
位置: realtime_persistence.py
问题代码:
# ❌ 风险：数据库连接未显式关闭
def save_task_result(self, task_data):
    safe_query = SafeDatabaseQuery(self.db_path)
    # ... 操作 ...
    # 缺少 safe_query.close()
风险分析:
•
❌ 数据库连接未显式关闭
•
❌ 可能导致连接泄漏
•
❌ 高并发时数据库可能锁死
影响:
•
数据库连接耗尽
•
性能下降
•
服务不可用
修复建议:
# ✅ 修复：使用上下文管理器
def save_task_result(self, task_data):
    try:
        safe_query = SafeDatabaseQuery(self.db_path)
        # ... 操作 ...
        return True
    finally:
        if safe_query:
            safe_query.close()  # 确保连接关闭

# 或使用上下文管理器
def save_task_result(self, task_data):
    with SafeDatabaseQuery(self.db_path) as safe_query:
        # ... 操作 ...
        return True
优先级: 🔴 P0 - 立即修复
风险 3: 敏感数据未加密
位置: 所有数据库表
问题:
-- ❌ 风险：敏感数据明文存储
CREATE TABLE aggregated_results (
    execution_id TEXT,  -- 未加密
    main_brand TEXT,    -- 未加密
    health_score REAL,
    ...
);
风险分析:
•
❌ execution_id 可能包含用户信息
•
❌ 品牌数据可能涉及商业机密
•
❌ 数据库文件未加密
•
❌ 备份数据未加密
影响:
•
数据泄露风险
•
商业机密暴露
•
合规性问题
修复建议:
# ✅ 修复：敏感数据加密
from cryptography.fernet import Fernet

class DataEncryption:
    def __init__(self):
        self.key = os.getenv('ENCRYPTION_KEY')
        self.cipher = Fernet(self.key)
    
    def encrypt(self, data):
        return self.cipher.encrypt(data.encode()).decode()
    
    def decrypt(self, encrypted_data):
        return self.cipher.decrypt(encrypted_data.encode()).decode()

# 使用加密
execution_id_encrypted = encryption.encrypt(execution_id)
数据库层面:
-- 启用 SQLite 加密扩展
PRAGMA key = 'your-encryption-key';
优先级: 🔴 P0 - 近期修复
🟡 中风险项 (近期修复)
风险 4: 缺少事务处理
位置: realtime_persistence.py
问题代码:
# ❌ 风险：多个操作未使用事务
def save_aggregated_results(self, aggregated_results):
    # 操作 1: 检查是否存在
    existing = safe_query.execute_query(...)
    
    # 操作 2: 插入或更新
    if existing:
        safe_query.execute_query('UPDATE ...')
    else:
        safe_query.execute_query('INSERT ...')
    # ❌ 缺少事务包裹
风险分析:
•
❌ 多个操作未原子性执行
•
❌ 并发时可能数据不一致
•
❌ 部分失败无法回滚
修复建议:
# ✅ 修复：使用事务
def save_aggregated_results(self, aggregated_results):
    try:
        safe_query.begin_transaction()
        
        # 操作 1
        existing = safe_query.execute_query(...)
        
        # 操作 2
        if existing:
            safe_query.execute_query('UPDATE ...')
        else:
            safe_query.execute_query('INSERT ...')
        
        safe_query.commit()
        return True
    except Exception as e:
        safe_query.rollback()
        api_logger.error(f"Transaction failed: {e}")
        return False
优先级: 🟡 P1 - 近期修复
风险 5: 缺少数据验证
位置: realtime_persistence.py
问题:
# ❌ 风险：数据未验证直接保存
def save_task_result(self, task_data):
    brand_name = task_data.get('brand', '')
    # ❌ 未验证 brand_name 是否有效
    # ❌ 未检查是否为空
    # ❌ 未检查长度
风险分析:
•
❌ 空值可能进入数据库
•
❌ 异常值可能破坏统计
•
❌ 数据质量无法保证
修复建议:
# ✅ 修复：添加数据验证
def save_task_result(self, task_data):
    # 验证必填字段
    required_fields = ['brand', 'model', 'question', 'response']
    for field in required_fields:
        if field not in task_data:
            raise ValueError(f"Missing required field: {field}")
    
    # 验证数据范围
    if len(task_data['brand']) > 100:
        raise ValueError("Brand name too long")
    
    if len(task_data['response']) > 100000:
        raise ValueError("Response too long")
    
    # 验证数据类型
    if not isinstance(task_data['response'], str):
        raise ValueError("Response must be string")
优先级: 🟡 P1 - 近期修复
风险 6: 缺少并发控制
位置: realtime_persistence.py
问题:
# ❌ 风险：并发写入未加锁
def save_task_result(self, task_data):
    # 多个线程可能同时写入
    # 可能导致数据冲突
    safe_query.execute_query('INSERT ...')
风险分析:
•
❌ 多线程并发写入
•
❌ 可能数据冲突
•
❌ 可能死锁
修复建议:
# ✅ 修复：添加锁机制
import threading

class RealtimePersistence:
    def __init__(self, execution_id, user_openid):
        self.lock = threading.Lock()
    
    def save_task_result(self, task_data):
        with self.lock:
            # 线程安全的写入
            safe_query.execute_query('INSERT ...')
优先级: 🟡 P1 - 近期修复
风险 7: 缺少错误处理
位置: realtime_persistence.py
问题代码:
# ❌ 风险：错误处理过于简单
def save_brand_rankings(self, brand_rankings):
    try:
        # ... 操作 ...
        return True
    except Exception as e:
        api_logger.error(f"Failed to save brand rankings: {e}")
        return False  # ❌ 未重试，未通知
风险分析:
•
❌ 失败后未重试
•
❌ 未通知调用方
•
❌ 可能数据丢失
修复建议:
# ✅ 修复：添加重试机制
from tenacity import retry, stop_after_attempt, wait_exponential

class RealtimePersistence:
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=1, max=10)
    )
    def save_brand_rankings(self, brand_rankings):
        try:
            # ... 操作 ...
            return True
        except Exception as e:
            api_logger.error(f"Failed to save brand rankings: {e}")
            raise  # 触发重试
优先级: 🟡 P1 - 近期修复
风险 8: 缺少性能监控
位置: 所有数据库操作
问题:
•
❌ 未记录查询耗时
•
❌ 未监控慢查询
•
❌ 未设置超时
修复建议:
# ✅ 修复：添加性能监控
import time

def save_task_result(self, task_data):
    start_time = time.time()
    
    try:
        # ... 操作 ...
        
        # 记录性能指标
        duration = time.time() - start_time
        if duration > 1.0:  # 超过 1 秒记录警告
            api_logger.warning(f"Slow query: {duration}s")
        
        # 保存性能指标
        self.save_performance_metric('task_duration', duration)
        
        return True
    except Exception as e:
        # 记录错误
        self.save_performance_metric('task_error', 1)
        raise
优先级: 🟡 P1 - 近期修复
风险 9: 缺少数据清理
位置: 所有数据库表
问题:
•
❌ 未设置数据保留策略
•
❌ 数据库可能无限增长
•
❌ 未清理过期数据
修复建议:
# ✅ 修复：添加数据清理
def cleanup_old_data(self, retention_days=30):
    """清理过期数据"""
    safe_query = SafeDatabaseQuery(self.db_path)
    
    # 清理 30 天前的数据
    safe_query.execute_query('''
        DELETE FROM aggregated_results
        WHERE created_at < datetime('now', '-30 days')
    ''')
    
    # 清理关联数据
    safe_query.execute_query('''
        DELETE FROM brand_rankings
        WHERE execution_id IN (
            SELECT execution_id FROM aggregated_results
            WHERE created_at < datetime('now', '-30 days')
        )
    ''')
优先级: 🟡 P1 - 近期修复
🟢 低风险项 (持续优化)
风险 10: 索引覆盖不全
位置: phase3_database_schema.sql
问题:
-- ❌ 缺少复合索引
CREATE INDEX idx_aggregated_execution ON aggregated_results(execution_id);
CREATE INDEX idx_aggregated_brand ON aggregated_results(main_brand);
-- ❌ 缺少 (execution_id, created_at) 复合索引
修复建议:
-- ✅ 添加复合索引
CREATE INDEX idx_aggregated_execution_created 
ON aggregated_results(execution_id, created_at);

CREATE INDEX idx_rankings_execution_rank 
ON brand_rankings(execution_id, rank);
优先级: 🟢 P2 - 持续优化
风险 11: 缺少查询缓存
位置: 所有查询
问题:
•
❌ 相同查询重复执行
•
❌ 未使用缓存
修复建议:
# ✅ 修复：添加查询缓存
from functools import lru_cache

class RealtimePersistence:
    @lru_cache(maxsize=100)
    def get_aggregated_results(self, execution_id):
        # ... 查询 ...
        return results
优先级: 🟢 P2 - 持续优化
风险 12: 缺少备份策略
位置: 数据库文件
问题:
•
❌ 未自动备份
•
❌ 未验证备份
修复建议:
# ✅ 修复：添加自动备份
def backup_database(self):
    """备份数据库"""
    import shutil
    from datetime import datetime
    
    backup_path = f"data/brand_test_backup_{datetime.now().strftime('%Y%m%d')}.db"
    shutil.copy2(self.db_path, backup_path)
优先级: 🟢 P2 - 持续优化
风险 13: 缺少容量规划
位置: 数据库设计
问题:
•
❌ 未评估数据增长
•
❌ 未设置容量上限
修复建议:
# ✅ 修复：添加容量监控
def check_database_size(self):
    """检查数据库大小"""
    import os
    size_mb = os.path.getsize(self.db_path) / 1024 / 1024
    
    if size_mb > 100:  # 超过 100MB 警告
        api_logger.warning(f"Database size: {size_mb}MB")
    
    return size_mb
优先级: 🟢 P2 - 持续优化
📊 修复优先级总结
优先级
风险项
修复时间
工作量
🔴 P0
SQL 注入风险
立即
2 小时
🔴 P0
数据库连接未关闭
立即
1 小时
🔴 P0
敏感数据未加密
1 周内
8 小时
🟡 P1
缺少事务处理
1 周内
4 小时
🟡 P1
缺少数据验证
1 周内
4 小时
🟡 P1
缺少并发控制
1 周内
4 小时
🟡 P1
缺少错误处理
1 周内
4 小时
🟡 P1
缺少性能监控
1 周内
4 小时
🟡 P1
缺少数据清理
1 周内
2 小时
🟢 P2
索引覆盖不全
1 月内
2 小时
🟢 P2
缺少查询缓存
1 月内
4 小时
🟢 P2
缺少备份策略
1 月内
4 小时
🟢 P2
缺少容量规划
1 月内
2 小时
🎯 总体建议
立即行动 (本周)
1.
修复 SQL 注入风险 - 添加输入验证
2.
修复连接泄漏 - 添加连接关闭
3.
评估加密需求 - 确定加密范围
近期行动 (1 周内)
4.
添加事务处理 - 确保数据一致性
5.
添加数据验证 - 确保数据质量
6.
添加并发控制 - 确保线程安全
7.
添加错误处理 - 添加重试机制
8.
添加性能监控 - 记录慢查询
9.
添加数据清理 - 设置保留策略
持续优化 (1 月内)
10.
优化索引 - 添加复合索引
11.
添加查询缓存 - 提升查询性能
12.
添加备份策略 - 确保数据安全
13.
添加容量规划 - 监控数据增长
📈 安全评分对比
类别
修复前
修复后
提升
SQL 注入防护
6/10
9/10
+50%
数据加密
2/10
8/10
+300%
事务处理
4/10
9/10
+125%
错误处理
5/10
9/10
+80%
并发控制
4/10
9/10
+125%
总体安全
6/10
9/10
+50%
审核人: AI Assistant (系统安全和性能管理专家)
审核日期: 2026-02-20
下次审核: 2026-03-20 (1 个月后)