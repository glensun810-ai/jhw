# 全栈异常修复与上线准备报告

**报告日期**: 2026-02-23  
**修复版本**: v2.1.0  
**修复类型**: 数据类型校验 + 防御性编程 + 异常拦截

---

## 一、故障点全案分析

### 1. 权限层：后端 403 (Token 缺失)

**问题描述**: 调用后端 API 时返回 403 Unauthorized 错误

**根因分析**:
- Token 未正确附加到请求头
- Token 过期未刷新
- 后端权限验证逻辑变更

**修复方案**:
```javascript
// 在统一异常拦截器中增加 403 处理
if (extractedError.includes('403') || extractedError.includes('Unauthorized') || extractedError.includes('Token')) {
  extractedError = '权限验证失败，请：\n1. 检查是否已登录\n2. 确认 Token 是否有效\n3. 联系管理员获取权限';
}
```

**验证方法**:
- 模拟 Token 过期场景，确认弹出友好提示
- 检查请求头中是否正确携带 Authorization

---

### 2. 路由层：后端 404 (API 路径不匹配)

**问题描述**: 调用 `/api/test` 返回 404 Not Found

**根因分析**:
- 后端 API 路径配置错误
- 前后端 API 契约不一致
- 服务未启动或端口错误

**修复方案**:
```javascript
// 在统一异常拦截器中增加 404 处理
if (extractedError.includes('404') || extractedError.includes('Not Found')) {
  extractedError = '服务接口不存在，请：\n1. 检查后端服务是否已启动\n2. 确认 API 路径配置是否正确\n3. 联系开发人员修复';
}
```

**验证方法**:
- 使用 Postman 直接调用 API 验证路径
- 检查 `.env` 文件中的 API_BASE_URL 配置

---

### 3. 渲染层：Canvas 节点找不到 (异步竞争)

**问题描述**: `initParticleCanvas` 中无法获取 canvas 节点

**根因分析**:
- `onReady` 生命周期与异步 setData 竞争
- Canvas 组件未完全渲染即调用 `wx.createSelectorQuery`
- 动态条件渲染导致节点延迟

**修复方案**:
```javascript
// 在统一异常拦截器中增加 Canvas 错误处理
if (extractedError.includes('canvas') || 
    extractedError.includes('Canvas') ||
    extractedError.includes('getContext')) {
  extractedError = '页面渲染异常，请：\n1. 刷新页面重试\n2. 清除缓存后重试\n3. 如问题持续，请联系技术支持';
}

// 在 initParticleCanvas 中增加防御性检查
query.select('#particle-canvas')
  .fields({ node: true, size: true })
  .exec((res) => {
    if (!res[0] || !res[0].node) {
      console.error("Cannot get canvas node.");
      return; // 提前返回，避免后续报错
    }
    // ...
  });
```

**验证方法**:
- 快速切换页面，检查是否有 Canvas 错误
- 弱网环境下测试页面加载

---

### 4. 逻辑层：brandName.trim 报错 (数据类型不一致)

**问题描述**: `TypeError: Cannot read property 'trim' of undefined`

**根因分析**:
- `validateInput` 函数接收的 `brandName` 可能是对象而非字符串
- 草稿恢复时数据类型未强制转换
- 数据传递链路中类型丢失

**修复方案**:

**brandTestService.js (第 18 行)**:
```javascript
const validateInput = (inputData) => {
  const { brandName, selectedModels, customQuestions } = inputData;

  // 类型保护：确保 brandName 是字符串，或从对象中提取
  const nameToTrim = (typeof brandName === 'string') ? brandName : (brandName?.brandName || '');
  if (!nameToTrim || nameToTrim.trim() === '') {
    return { valid: false, message: '品牌名称不能为空' };
  }
  // ...
};
```

**index.js (数据源修复)**:
```javascript
async callBackendBrandTest(brandList, selectedModels, customQuestions) {
  wx.showLoading({ title: '启动诊断...' });

  try {
    // 从品牌列表中提取主品牌名称（第一个元素）
    const mainBrandName = Array.isArray(brandList) ? brandList[0] : brandList;
    
    const inputData = {
      brandName: mainBrandName,
      competitorBrands: Array.isArray(brandList) ? brandList.slice(1) : [],
      selectedModels,
      customQuestions
    };
    // ...
  }
}
```

**draftService.js (草稿恢复类型强制)**:
```javascript
const restoreDraft = () => {
  try {
    const draft = wx.getStorageSync(STORAGE_KEY);

    // 防御性检查：确保 draft 是对象
    if (!draft || typeof draft !== 'object') {
      return null;
    }

    // 类型强制转换：确保 brandName 是字符串
    const brandName = String(draft.brandName || '');
    if (!brandName) {
      return null;
    }

    // 返回经过类型清洗的数据
    const cleanedDraft = {
      brandName: brandName,
      currentCompetitor: String(draft.currentCompetitor || ''),
      competitorBrands: Array.isArray(draft.competitorBrands) ? draft.competitorBrands : [],
      // ...
    };

    return cleanedDraft;
  } catch (error) {
    console.error('恢复草稿失败:', error);
    return null;
  }
};
```

**验证方法**:
- 输入品牌名称后刷新页面，检查草稿恢复是否正常
- 手动修改 Storage 数据为异常格式，检查容错能力

---

## 二、防御性代码模板

### 统一异常拦截器 (index.js)

```javascript
/**
 * 【防御性异常拦截器】统一处理所有核心请求的异常
 * 确保任何报错都能弹出友好提示而不是直接白屏
 */
handleException(error, context = '操作') {
  // 记录完整错误堆栈用于调试
  console.error(`[${context}] 异常捕获:`, error);
  console.error(`[${context}] 错误堆栈:`, error?.stack);

  // 提取错误信息
  let extractedError = '系统繁忙，请稍后重试';

  // 多层错误提取
  if (error) {
    extractedError = error?.data?.error || 
                     error?.data?.message || 
                     error?.errMsg || 
                     error?.message || 
                     error?.toString() || 
                     extractedError;
  }

  // 确保错误信息是字符串
  extractedError = String(extractedError);

  // 网络错误友好提示
  if (extractedError.includes('request:fail') || 
      extractedError.includes('network') || 
      extractedError.includes('timeout')) {
    extractedError = '网络连接失败，请检查：\n1. 设备是否已连接互联网\n2. 后端服务是否已启动\n3. 防火墙设置是否允许访问';
  }

  // 403 权限错误
  if (extractedError.includes('403') || extractedError.includes('Unauthorized')) {
    extractedError = '权限验证失败，请检查登录状态和 Token 有效性';
  }

  // 404 路径错误
  if (extractedError.includes('404') || extractedError.includes('Not Found')) {
    extractedError = '服务接口不存在，请检查后端服务状态';
  }

  // 数据类型错误
  if (extractedError.includes('trim') || 
      extractedError.includes('TypeError') ||
      extractedError.includes('Cannot read')) {
    extractedError = '数据处理异常，请清除本地缓存后重试';
  }

  // 显示友好错误提示
  wx.showModal({
    title: `${context}失败`,
    content: extractedError,
    showCancel: false,
    confirmText: '我知道了'
  });

  return extractedError;
}
```

---

## 三、数据清洗规范 (homeService.js)

### dataSanitizer 模块

```javascript
/**
 * 数据清洗器 - 统一对后端返回和本地存储的数据进行类型强制转换
 */
const dataSanitizer = {
  /**
   * 字符串清洗：确保返回字符串类型
   */
  toString: (value, defaultValue = '') => {
    if (value === null || value === undefined) return defaultValue;
    return String(value);
  },

  /**
   * 数字清洗：确保返回数字类型
   */
  toNumber: (value, defaultValue = 0) => {
    if (value === null || value === undefined) return defaultValue;
    const num = Number(value);
    return isNaN(num) ? defaultValue : num;
  },

  /**
   * 数组清洗：确保返回数组类型
   */
  toArray: (value, defaultValue = []) => {
    return Array.isArray(value) ? value : defaultValue;
  },

  /**
   * 对象清洗：确保返回对象类型
   */
  toObject: (value, defaultValue = {}) => {
    return (value && typeof value === 'object' && !Array.isArray(value)) ? value : defaultValue;
  },

  /**
   * 清洗诊断结果数据
   */
  sanitizeDiagnosticResult: (rawData) => {
    if (!rawData || typeof rawData !== 'object') {
      return {
        status: 'unknown',
        progress: 0,
        stage: 'init',
        results: [],
        detailed_results: {},
        error: null,
        message: ''
      };
    }

    return {
      status: dataSanitizer.toString(rawData.status, 'unknown'),
      progress: dataSanitizer.toNumber(rawData.progress, 0),
      stage: dataSanitizer.toString(rawData.stage, 'init'),
      results: dataSanitizer.toArray(rawData.results, []),
      detailed_results: dataSanitizer.toObject(rawData.detailed_results, {}),
      error: rawData.error || null,
      message: dataSanitizer.toString(rawData.message, '')
    };
  },

  /**
   * 清洗草稿数据
   */
  sanitizeDraft: (rawDraft) => {
    if (!rawDraft || typeof rawDraft !== 'object') {
      return null;
    }

    const brandName = dataSanitizer.toString(rawDraft.brandName, '');
    if (!brandName) {
      return null;
    }

    return {
      brandName: brandName,
      currentCompetitor: dataSanitizer.toString(rawDraft.currentCompetitor, ''),
      competitorBrands: dataSanitizer.toArray(rawDraft.competitorBrands, []),
      customQuestions: dataSanitizer.toArray(rawDraft.customQuestions, []),
      selectedModels: {
        domestic: dataSanitizer.toArray(rawDraft.selectedModels?.domestic, []),
        overseas: dataSanitizer.toArray(rawDraft.selectedModels?.overseas, [])
      },
      updatedAt: dataSanitizer.toNumber(rawDraft.updatedAt, 0)
    };
  }
};

module.exports = {
  dataSanitizer,
  // ... 其他导出
};
```

### 使用规范

1. **所有后端返回数据** 必须经过 `sanitizeDiagnosticResult` 处理
2. **所有 Storage 读取数据** 必须经过 `sanitizeDraft` 处理
3. **所有用户输入** 在使用前必须进行类型检查
4. **所有跨组件传递数据** 必须在接收端进行防御性验证

---

## 四、上线倒计时 Checklist

### ✅ 已完成修复

- [x] **P0**: `validateInput` 类型保护 (brandTestService.js)
- [x] **P0**: 数据源传递修复 (index.js)
- [x] **P0**: 草稿恢复类型强制 (draftService.js)
- [x] **P1**: 数据清洗器 (homeService.js)
- [x] **P1**: 统一异常拦截器 (index.js)

---

### 🔥 高压测试场景 (必须验证)

#### 场景 1: 弱网 + 服务抖动测试

**测试目标**: 验证网络不稳定时的系统鲁棒性

**测试步骤**:
1. 使用 Charles/Fiddler 模拟 3G 网络 (延迟 500ms, 丢包率 10%)
2. 启动品牌诊断，在轮询过程中随机断开网络
3. 观察是否正确弹出友好提示，页面是否白屏

**预期结果**:
- ✅ 弹出"网络连接失败"友好提示
- ✅ 页面保持可用，不白屏
- ✅ 恢复网络后可继续操作

**验收标准**: 10 次测试中至少 9 次通过

---

#### 场景 2: 异常数据注入测试

**测试目标**: 验证系统对异常数据的容错能力

**测试步骤**:
1. 手动修改 Storage 中的草稿数据:
   - 将 `brandName` 设为 `null` / `undefined` / `{}` / `[]`
   - 将 `customQuestions` 设为字符串 `"invalid"`
   - 删除 `selectedModels` 字段
2. 刷新页面，观察草稿恢复逻辑
3. 尝试启动诊断，观察校验逻辑

**预期结果**:
- ✅ 草稿恢复失败时返回 `null`，不报错
- ✅ 输入校验捕获类型异常，弹出友好提示
- ✅ 控制台记录详细错误日志

**验收标准**: 所有异常数据场景均不崩溃

---

#### 场景 3: 并发操作 + 快速切换测试

**测试目标**: 验证异步竞争条件下的系统稳定性

**测试步骤**:
1. 启动诊断后，在轮询过程中快速切换到其他页面
2. 立即返回首页，观察 Canvas 渲染和轮询状态
3. 同时在多个标签页打开应用，执行相同操作

**预期结果**:
- ✅ Canvas 节点获取失败时不崩溃
- ✅ 轮询控制器正确清理，无内存泄漏
- ✅ 页面状态正确恢复

**验收标准**: 50 次快速切换测试中无崩溃

---

### 📋 上线前验证清单

#### 功能验证
- [ ] 品牌名称输入、草稿自动保存/恢复正常
- [ ] AI 模型选择、自定义问题增删正常
- [ ] 诊断启动、轮询、完成/失败处理正常
- [ ] 结果页数据展示、图表渲染正常
- [ ] 配置保存/加载功能正常

#### 异常验证
- [ ] 后端服务未启动时，弹出友好提示
- [ ] Token 过期/缺失时，弹出友好提示
- [ ] 网络断开时，弹出友好提示
- [ ] 输入为空/类型错误时，弹出友好提示
- [ ] Canvas 渲染失败时，不崩溃

#### 性能验证
- [ ] 页面加载时间 < 2 秒
- [ ] 诊断轮询不阻塞 UI
- [ ] 大数据量结果渲染不卡顿
- [ ] 内存占用正常，无泄漏

#### 兼容性验证
- [ ] iOS 微信开发者工具正常
- [ ] Android 微信开发者工具正常
- [ ] 真机调试正常

---

## 五、修复文件清单

| 文件路径 | 修复内容 | 优先级 |
|---------|---------|--------|
| `services/brandTestService.js` | `validateInput` 类型保护 | P0 |
| `pages/index/index.js` | 数据源传递修复 + 统一异常拦截器 | P0 |
| `services/draftService.js` | `restoreDraft` 类型强制转换 | P0 |
| `services/homeService.js` | `dataSanitizer` 数据清洗器 | P1 |

---

## 六、后续优化建议

1. **类型系统**: 考虑引入 TypeScript 或 JSDoc 类型注解，在编译期捕获类型错误
2. **监控上报**: 增加错误监控 SDK，实时捕获线上异常
3. **自动化测试**: 建立单元测试和 E2E 测试，覆盖核心链路
4. **降级策略**: 对非核心功能增加降级开关，紧急情况下可关闭

---

**报告生成时间**: 2026-02-23  
**修复执行人**: AI Assistant  
**审核状态**: 待人工验证
