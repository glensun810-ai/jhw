# P0-2 Token 刷新机制实施报告

**文档版本**: v1.0  
**创建日期**: 2026-02-21  
**实施状态**: ✅ 已完成  

---

## 执行摘要

### 问题描述

JWT Token 过期后无刷新机制，用户需重新登录，导致：
- 用户体验差（Token 过期后需重新登录）
- 增加服务器认证负载

### 实施内容

本次实施完成了完整的 Token 刷新机制，包括：
1. ✅ JWTManager 增强（支持 refresh token）
2. ✅ Refresh Token 存储机制
3. ✅ Token 验证端点 `/api/validate-token`
4. ✅ Token 刷新端点 `/api/refresh-token`
5. ✅ 登出端点 `/api/logout`
6. ✅ 前端自动 Token 刷新逻辑

### 新增 API 端点

| 端点 | 方法 | 功能 | 状态 |
|------|------|------|------|
| `/api/validate-token` | POST | 验证 Access Token 有效性 | ✅ 完成 |
| `/api/refresh-token` | POST | 使用 Refresh Token 刷新 Access Token | ✅ 完成 |
| `/api/logout` | POST | 登出（撤销 Refresh Token） | ✅ 完成 |

### Token 生命周期

```
┌─────────────────────────────────────────────────────────────┐
│                    Token 生命周期                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 用户登录/注册                                            │
│     ├── 生成 Access Token (24 小时)                          │
│     └── 生成 Refresh Token (7 天)                            │
│                                                             │
│  2. 访问受保护资源                                           │
│     ├── 使用 Access Token 认证                               │
│     └── Token 过期 → 自动刷新                                │
│                                                             │
│  3. Token 刷新                                               │
│     ├── 使用 Refresh Token 获取新 Access Token               │
│     ├── 生成新 Refresh Token（Token 轮换）                   │
│     └── 撤销旧 Refresh Token                                 │
│                                                             │
│  4. 用户登出                                                 │
│     ├── 撤销当前 Refresh Token                               │
│     └── 或撤销所有 Refresh Token（全部登出）                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 第一部分：后端实现

### 1.1 JWTManager 增强

**文件**: `backend_python/wechat_backend/security/auth.py`

**新增功能**:
- 支持 `token_type` 参数（'access' 或 'refresh'）
- 访问令牌默认 24 小时过期
- 刷新令牌默认 7 天过期
- 验证时检查令牌类型

```python
class JWTManager:
    """JWT 管理器（支持刷新令牌）"""

    def generate_token(self, user_id: str, expires_delta: timedelta = None, 
                      additional_claims: Dict = None, token_type: str = 'access') -> str:
        """生成 JWT 令牌
        
        Args:
            user_id: 用户 ID
            expires_delta: 过期时间
            additional_claims: 额外声明
            token_type: 令牌类型 ('access' 或 'refresh')
        """
        if expires_delta is None:
            # 访问令牌默认 24 小时，刷新令牌默认 7 天
            expires_delta = timedelta(days=7) if token_type == 'refresh' else timedelta(hours=24)

        now = datetime.utcnow()
        payload = {
            'user_id': user_id,
            'iat': now,
            'exp': now + expires_delta,
            'type': token_type  # 令牌类型标识
        }

        token = jwt.encode(payload, self.secret, algorithm=self.algorithm)
        return token

    def decode_token(self, token: str, verify_type: str = None) -> Dict:
        """解码 JWT 令牌
        
        Args:
            token: JWT 令牌
            verify_type: 验证令牌类型，None 表示不验证类型
        """
        payload = jwt.decode(token, self.secret, algorithms=[self.algorithm])
        
        # 验证令牌类型
        if verify_type and payload.get('type') != verify_type:
            raise AuthenticationError(f"令牌类型错误，期望 {verify_type}")
        
        return payload
```

---

### 1.2 Refresh Token 存储

**文件**: `backend_python/wechat_backend/database.py`

**新增函数**:

```python
# Refresh token 存储（内存存储，生产环境应使用 Redis）
_refresh_tokens = {}

def save_refresh_token(user_id: str, refresh_token: str):
    """保存刷新令牌"""
    expiration_time = datetime.now() + timedelta(days=7)  # 7 天有效期
    _refresh_tokens[refresh_token] = {
        'user_id': user_id,
        'expires_at': expiration_time,
        'created_at': datetime.now()
    }

def verify_refresh_token(refresh_token: str) -> str:
    """验证刷新令牌，返回用户 ID"""
    stored = _refresh_tokens.get(refresh_token)
    if not stored:
        return None
    
    # 检查过期
    if datetime.now() > stored['expires_at']:
        del _refresh_tokens[refresh_token]
        return None
    
    return stored['user_id']

def revoke_refresh_token(refresh_token: str):
    """撤销（登出）刷新令牌"""
    if refresh_token in _refresh_tokens:
        del _refresh_tokens[refresh_token]

def revoke_all_user_tokens(user_id: str):
    """撤销用户所有刷新令牌（从所有设备登出）"""
    tokens_to_revoke = [token for token, data in _refresh_tokens.items() 
                       if data['user_id'] == user_id]
    for token in tokens_to_revoke:
        del _refresh_tokens[token]
```

**生产环境建议**: 使用 Redis 存储

```python
import redis

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def save_refresh_token(user_id: str, refresh_token: str):
    key = f'refresh_token:{refresh_token}'
    redis_client.setex(key, 604800, user_id)  # 7 天 = 604800 秒

def verify_refresh_token(refresh_token: str) -> str:
    key = f'refresh_token:{refresh_token}'
    user_id = redis_client.get(key)
    return user_id.decode() if user_id else None

def revoke_refresh_token(refresh_token: str):
    key = f'refresh_token:{refresh_token}'
    redis_client.delete(key)
```

---

### 1.3 Token 验证端点

**文件**: `backend_python/wechat_backend/views.py`

```python
@wechat_bp.route('/api/validate-token', methods=['POST'])
@rate_limit(limit=30, window=60, per='ip')
def validate_token():
    """Validate access token"""
    api_logger.info("Token validation endpoint accessed")
    
    data = request.get_json()
    if not data:
        return jsonify({'status': 'invalid', 'error': 'No JSON data provided'}), 400
    
    token = data.get('token')
    if not token:
        # Try to get token from Authorization header
        auth_header = request.headers.get('Authorization')
        if auth_header and auth_header.startswith('Bearer '):
            token = auth_header.split(' ')[1]
    
    if not token:
        return jsonify({'status': 'invalid', 'error': 'Token not provided'}), 400
    
    try:
        from wechat_backend.security.auth import jwt_manager
        if not jwt_manager:
            return jsonify({'status': 'invalid', 'error': 'JWT service unavailable'}), 500
        
        # Decode and validate token (verify it's an access token)
        payload = jwt_manager.decode_token(token, verify_type='access')
        
        return jsonify({
            'status': 'valid',
            'user_id': payload.get('user_id'),
            'expires_at': payload.get('exp')
        })
        
    except Exception as e:
        api_logger.warning(f"Token validation failed: {e}")
        return jsonify({'status': 'invalid', 'error': str(e)}), 401
```

---

### 1.4 Token 刷新端点

**文件**: `backend_python/wechat_backend/views.py`

```python
@wechat_bp.route('/api/refresh-token', methods=['POST'])
@rate_limit(limit=10, window=60, per='ip')
def refresh_token():
    """Refresh access token using refresh token"""
    api_logger.info("Token refresh endpoint accessed")
    
    data = request.get_json()
    if not data:
        return jsonify({'error': 'No JSON data provided'}), 400
    
    refresh_token_str = data.get('refresh_token')
    
    if not refresh_token_str:
        refresh_token_str = request.headers.get('X-Refresh-Token')
    
    if not refresh_token_str:
        return jsonify({'error': 'Refresh token is required'}), 400
    
    # Verify refresh token
    from wechat_backend.database import verify_refresh_token
    user_id = verify_refresh_token(refresh_token_str)
    
    if not user_id:
        return jsonify({'error': 'Invalid or expired refresh token'}), 401
    
    try:
        from wechat_backend.security.auth import jwt_manager
        if not jwt_manager:
            return jsonify({'error': 'JWT service unavailable'}), 500
        
        # Generate new access token
        new_access_token = jwt_manager.generate_token(
            user_id,
            expires_delta=timedelta(hours=24),
            token_type='access'
        )
        
        # Generate new refresh token (rotate refresh tokens for security)
        new_refresh_token = jwt_manager.generate_token(
            user_id,
            expires_delta=timedelta(days=7),
            token_type='refresh'
        )
        
        # Save new refresh token
        from wechat_backend.database import save_refresh_token
        save_refresh_token(user_id, new_refresh_token)
        
        # Revoke old refresh token (token rotation)
        from wechat_backend.database import revoke_refresh_token
        revoke_refresh_token(refresh_token_str)
        
        api_logger.info(f"Token refreshed for user {user_id}")
        
        return jsonify({
            'status': 'success',
            'token': new_access_token,
            'refresh_token': new_refresh_token,
            'expires_in': 86400,  # 24 hours
            'token_type': 'Bearer'
        })
        
    except Exception as e:
        api_logger.error(f"Token refresh failed: {e}")
        return jsonify({'error': 'Token refresh failed'}), 500
```

**安全特性**:
- ✅ Token 轮换（Refresh Token 一次性使用）
- ✅ 限流保护（10 次/分钟/IP）
- ✅ 过期验证
- ✅ 撤销旧 Token

---

### 1.5 登出端点

**文件**: `backend_python/wechat_backend/views.py`

```python
@wechat_bp.route('/api/logout', methods=['POST'])
@require_auth_optional
@rate_limit(limit=10, window=60, per='ip')
def logout():
    """Logout user (revoke refresh tokens)"""
    api_logger.info("Logout endpoint accessed")
    
    data = request.get_json() or {}
    user_id = get_current_user_id()
    
    # Option 1: Logout from current device only
    refresh_token_str = data.get('refresh_token') or request.headers.get('X-Refresh-Token')
    if refresh_token_str:
        from wechat_backend.database import revoke_refresh_token
        revoke_refresh_token(refresh_token_str)
    
    # Option 2: Logout from all devices (if requested)
    if data.get('all_devices', False) and user_id:
        from wechat_backend.database import revoke_all_user_tokens
        revoke_all_user_tokens(user_id)
        api_logger.info(f"All tokens revoked for user {user_id}")
    else:
        api_logger.info(f"Token revoked for user {user_id or 'anonymous'}")
    
    return jsonify({
        'status': 'success',
        'message': 'Logout successful'
    })
```

---

### 1.6 登录/注册端点更新

**文件**: `backend_python/wechat_backend/views.py`

**注册端点增强**:
```python
# Generate JWT tokens
access_token = jwt_manager.generate_token(str(user_id), expires_delta=timedelta(hours=24), token_type='access')
refresh_token = jwt_manager.generate_token(str(user_id), expires_delta=timedelta(days=7), token_type='refresh')

# Save refresh token
save_refresh_token(str(user_id), refresh_token)

return jsonify({
    'status': 'success',
    'message': 'User registered successfully',
    'user_id': user_id,
    'token': access_token,
    'refresh_token': refresh_token,
    'expires_in': 86400,  # 24 hours
    'refresh_expires_in': 604800  # 7 days
})
```

**登录端点增强**:
```python
# Generate JWT tokens
access_token = jwt_manager.generate_token(str(user['id']), expires_delta=timedelta(hours=24), token_type='access')
refresh_token = jwt_manager.generate_token(str(user['id']), expires_delta=timedelta(days=7), token_type='refresh')

# Save refresh token
save_refresh_token(str(user['id']), refresh_token)

return jsonify({
    'status': 'success',
    'message': 'Login successful',
    'user_id': user['id'],
    'token': access_token,
    'refresh_token': refresh_token,
    'expires_in': 86400,
    'refresh_expires_in': 604800,
    'profile': { ... }
})
```

---

## 第二部分：前端实现

### 2.1 请求工具增强

**文件**: `utils/request.js`

**新增功能**:
- 自动 Token 刷新机制
- 401 错误自动重试
- 请求队列管理（防止并发刷新）

```javascript
// Token 刷新锁，防止并发刷新
let isRefreshing = false;
let refreshQueue = [];

/**
 * 刷新 Token
 */
const refreshToken = () => {
  return new Promise((resolve, reject) => {
    const refresh_token = wx.getStorageSync('refreshToken');
    
    if (!refresh_token) {
      console.error('No refresh token available');
      reject(new Error('No refresh token'));
      return;
    }
    
    wx.request({
      url: getBaseUrl() + API_ENDPOINTS.AUTH.REFRESH_TOKEN,
      method: 'POST',
      data: { refresh_token },
      header: { 'Content-Type': 'application/json' },
      success: (res) => {
        if (res.statusCode === 200 && res.data.status === 'success') {
          // 保存新 token
          wx.setStorageSync('userToken', res.data.token);
          wx.setStorageSync('refreshToken', res.data.refresh_token);
          console.log('Token refreshed successfully');
          resolve(res.data.token);
        } else {
          console.error('Token refresh failed:', res.data);
          reject(new Error('Token refresh failed'));
        }
      },
      fail: (err) => {
        console.error('Token refresh request failed:', err);
        reject(err);
      }
    });
  });
};
```

**401 错误处理**:
```javascript
success: (response) => {
  if (loading) wx.hideLoading();
  
  // 处理 401 错误 - 尝试刷新 token
  if (response.statusCode === 401) {
    // 如果不是刷新 token 的请求本身失败
    if (!options.url.includes('/api/refresh-token')) {
      if (isRefreshing) {
        // 已经在刷新，加入队列等待
        refreshQueue.push({ resolve, reject, options });
        return;
      }
      
      isRefreshing = true;
      
      // 尝试刷新 token
      refreshToken()
        .then((newToken) => {
          isRefreshing = false;
          // 执行队列中的请求
          executeRefreshQueue(newToken);
          // 重试原请求
          const newHeader = { ...header, Authorization: `Bearer ${newToken}` };
          return request({ ...options, header: newHeader, loading: false });
        })
        .then(resolve)
        .catch((err) => {
          isRefreshing = false;
          rejectRefreshQueue(err);
          handleUnauthorized();
          reject(new Error('认证失效，请重新登录'));
        });
      return;
    } else {
      // refresh token 请求本身失败
      handleUnauthorized();
      reject(new Error('未授权'));
      return;
    }
  }
  
  if (response.statusCode === 200) {
    resolve(response.data);
  }
}
```

---

### 2.2 注册页面更新

**文件**: `pages/register/register.js`

**变更**: 保存 refresh token

```javascript
// 保存 token 和 refresh token
if (res.token) {
  wx.setStorageSync('token', res.token);
  wx.setStorageSync('userToken', res.token);  // 兼容旧代码
}
if (res.refresh_token) {
  wx.setStorageSync('refreshToken', res.refresh_token);
}
wx.setStorageSync('user_id', res.user_id);
wx.setStorageSync('isLoggedIn', true);
```

---

## 第三部分：测试验证

### 3.1 测试脚本

**文件**: `test_token_refresh.py`

**测试用例**:

| 测试项 | 描述 | 预期结果 | 状态 |
|--------|------|----------|------|
| 注册获取 Tokens | 注册用户并获取 Access/Refresh Token | 返回 200 + tokens | ✅ |
| 验证 Token | 验证 Access Token 有效性 | 返回 200 + valid | ✅ |
| 刷新 Token | 使用 Refresh Token 刷新 | 返回 200 + new tokens | ✅ |
| 新 Token 访问 | 使用新 Token 访问资源 | 返回 200 | ✅ |
| 登出 | 撤销 Refresh Token | 返回 200 | ✅ |
| 已撤销 Token 失效 | 验证已撤销的 Token 失效 | 返回 401 | ✅ |

---

### 3.2 测试步骤

**运行测试**:
```bash
# 1. 启动后端服务
cd backend_python
python app.py

# 2. 运行测试脚本
python test_token_refresh.py
```

**预期输出**:
```
============================================================
品牌 AI 诊断系统 - Token 刷新机制测试
============================================================

==================================================
测试 1: 注册并获取 Tokens
==================================================
注册响应：{
  "status": "success",
  "message": "User registered successfully",
  "user_id": 1,
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expires_in": 86400,
  "refresh_expires_in": 604800
}
✅ 注册成功

==================================================
测试 2: 验证 Token
==================================================
验证响应：{
  "status": "valid",
  "user_id": "1",
  "expires_at": 1708617600
}
✅ Token 有效

==================================================
测试 3: 刷新 Token
==================================================
刷新响应：{
  "status": "success",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expires_in": 86400,
  "token_type": "Bearer"
}
✅ Token 刷新成功

✅ 所有 Token 刷新机制测试通过！
```

---

## 第四部分：安全考虑

### 4.1 Token 轮换

**当前实现**: Refresh Token 一次性使用

```python
# 生成新 Refresh Token
new_refresh_token = jwt_manager.generate_token(...)

# 保存新 Token
save_refresh_token(user_id, new_refresh_token)

# 撤销旧 Token
revoke_refresh_token(refresh_token_str)
```

**安全优势**:
- ✅ 防止 Refresh Token 重放攻击
- ✅ 泄露后立即失效
- ✅ 可追踪异常使用

---

### 4.2 Token 存储

**前端存储**:
```javascript
wx.setStorageSync('userToken', access_token);      // Access Token
wx.setStorageSync('refreshToken', refresh_token);  // Refresh Token
```

**后端存储**:
- Access Token: 无状态（JWT）
- Refresh Token: 内存存储（生产环境用 Redis）

**生产环境建议**:
- 使用 Redis 存储 Refresh Token
- 设置合理的过期时间
- 实现 Token 黑名单机制

---

### 4.3 Token 过期时间

| Token 类型 | 过期时间 | 用途 |
|-----------|----------|------|
| Access Token | 24 小时 | 访问受保护资源 |
| Refresh Token | 7 天 | 刷新 Access Token |

**安全建议**:
- Access Token 不宜过长（建议 1-24 小时）
- Refresh Token 可较长（建议 7-30 天）
- 敏感操作需重新认证

---

## 第五部分：API 使用示例

### 5.1 验证 Token

```bash
curl -X POST http://127.0.0.1:5000/api/validate-token \
  -H "Content-Type: application/json" \
  -d '{"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}'
```

**响应**:
```json
{
  "status": "valid",
  "user_id": "1",
  "expires_at": 1708617600
}
```

---

### 5.2 刷新 Token

```bash
curl -X POST http://127.0.0.1:5000/api/refresh-token \
  -H "Content-Type: application/json" \
  -d '{"refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}'
```

**响应**:
```json
{
  "status": "success",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expires_in": 86400,
  "token_type": "Bearer"
}
```

---

### 5.3 登出

```bash
# 当前设备登出
curl -X POST http://127.0.0.1:5000/api/logout \
  -H "Content-Type: application/json" \
  -d '{"refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}'

# 所有设备登出
curl -X POST http://127.0.0.1:5000/api/logout \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -d '{"all_devices": true}'
```

**响应**:
```json
{
  "status": "success",
  "message": "Logout successful"
}
```

---

## 第六部分：故障排查

### 6.1 常见问题

**问题 1**: Token 刷新失败 - Invalid or expired refresh token

```
错误：Invalid or expired refresh token
原因：
  1. Refresh Token 已过期（>7 天）
  2. Refresh Token 已被使用（Token 轮换）
  3. Refresh Token 格式错误
解决：重新登录获取新 Token
```

**问题 2**: Token 验证失败 - 令牌已过期

```
错误：令牌已过期
原因：Access Token 已过期（>24 小时）
解决：
  1. 前端自动刷新（已实现）
  2. 或重新登录
```

**问题 3**: 401 错误循环刷新

```
现象：不断收到 401 错误
原因：
  1. Refresh Token 也过期了
  2. 网络问题导致刷新失败
解决：清除本地存储，重新登录
```

---

### 6.2 日志查看

**后端日志**:
```bash
# 查看 Token 相关日志
tail -f logs/app.log | grep -E "token|refresh|logout"
```

**关键日志**:
```
INFO - Token validation endpoint accessed
INFO - Token refresh endpoint accessed
INFO - Token refreshed for user 1
INFO - Logout endpoint accessed
INFO - All tokens revoked for user 1
```

---

## 第七部分：后续改进计划

### P1 改进项

1. **Redis 存储**
   - Refresh Token 分布式存储
   - 支持多实例部署
   - 提高撤销效率

2. **Token 黑名单**
   - 实现 Token 撤销列表
   - 支持主动撤销 Access Token
   - 增强安全性

### P2 改进项

3. **设备管理**
   - 记录登录设备信息
   - 支持设备级撤销
   - 显示活跃设备列表

4. **安全增强**
   - Refresh Token 绑定设备指纹
   - 异常登录检测
   - 地理位置验证

---

**文档结束**
