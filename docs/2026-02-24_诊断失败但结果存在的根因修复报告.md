# 2026-02-24_诊断失败但结果存在的根因修复报告

**报告日期**: 2026-02-24  
**问题级别**: 🔴 P0 - 阻塞性错误  
**修复状态**: ✅ 已完成  
**修复负责人**: 系统首席架构师  

---

## 一、问题描述

### 1.1 错误现象

用户运行品牌诊断时，前端显示"诊断失败"，但日志显示后端返回了 5 个结果：

```javascript
[parseTaskStatus] 解析结果：{
  stage: "failed", 
  progress: 100, 
  is_completed: false, 
  status: "failed", 
  results_count: 5,  // ← 有 5 个结果！
  …
}
```

### 1.2 错误日志

```
[诊断启动] 异常捕获：Error: 诊断失败
    at _callee3$ (brandTestService.js:274)
    ...
```

### 1.3 不合理性

- ✅ 进度：100%
- ✅ 结果数：5 个
- ❌ 状态：failed
- ❌ 完成标志：false

**核心矛盾**：为什么有结果却报告失败？

---

## 二、根因分析

### 2.1 问题链路

```
后端执行 → 结果验证 → 设置失败状态 → 前端轮询 → 检测失败状态 → 报错
         (部分结果)    (stage=failed)  (stage=failed)  (诊断失败)
```

### 2.2 根本原因

#### 后端问题：`nxm_execution_engine.py`

**问题代码** (第 329 行):
```python
api_logger.info(f"[NxM] 执行成功：{execution_id}, 结果数：{len(deduplicated)}")
else:
    scheduler.fail_execution(verification['message'])  # ← 直接标记为失败
```

**验证逻辑** (`nxm_result_aggregator.py:verify_completion`):
```python
def verify_completion(results, expected_total):
    if len(results) == expected_total:
        return {'success': True, ...}
    # 只要结果数不足，就返回失败
    return {'success': False, 'message': '结果不完整', ...}
```

**问题**：
- 当 `actual_count < expected_total` 时，直接调用 `fail_execution`
- 即使有 5 个有效结果，也因为"不完整"而被标记为失败
- **没有区分"部分完成"和"完全失败"**

#### 前端问题：`brandTestService.js`

**问题代码** (第 265-275 行):
```javascript
if (parsedStatus.stage === 'completed' || parsedStatus.stage === 'failed' || ...) {
  const isCompleted = parsedStatus.is_completed === true || parsedStatus.stage === 'completed';
  
  if (isCompleted && onComplete) {
    onComplete(parsedStatus);
  } else if (!isCompleted && onError) {
    onError(new Error('诊断失败'));  // ← 直接报错
  }
}
```

**问题**：
- 检测到 `stage='failed'` 就直接调用 `onError`
- **没有检查结果是否存在**
- 即使有结果也无法展示

---

## 三、修复方案

### 3.1 后端修复：区分"部分完成"和"完全失败"

**文件**: `backend_python/wechat_backend/nxm_execution_engine.py`

**修复位置**: 第 324-340 行

**修复前**:
```python
api_logger.info(f"[NxM] 执行成功：{execution_id}, 结果数：{len(deduplicated)}")
else:
    scheduler.fail_execution(verification['message'])
```

**修复后**:
```python
# 【关键修复】区分"部分完成"和"完全失败"
# 当有有效结果时，即使数量不足也应该返回结果而不是报错
if len(deduplicated) > 0:
    api_logger.info(f"[NxM] 执行部分完成：{execution_id}, 结果数：{len(deduplicated)}/{total_tasks}, 完成率：{len(deduplicated)*100//max(total_tasks,1)}%")
    # 设置部分完成状态
    scheduler.complete_execution()  # 使用完成而不是失败
    # 记录部分完成的警告
    execution_store[execution_id]['warning'] = f'部分结果缺失：{len(deduplicated)}/{total_tasks}'
    execution_store[execution_id]['missing_count'] = total_tasks - len(deduplicated)
else:
    # 完全没有结果时才标记为失败
    scheduler.fail_execution(verification['message'])
    api_logger.error(f"[NxM] 执行完全失败：{execution_id}, 无有效结果")
```

**修复逻辑**:
1. 检查是否有有效结果 (`len(deduplicated) > 0`)
2. 有结果 → 调用 `complete_execution()` 标记为完成
3. 同时记录警告信息（部分缺失）
4. 无结果 → 调用 `fail_execution()` 标记为失败

### 3.2 前端修复：处理"部分完成"情况

**文件**: `services/brandTestService.js`

**修复位置**: 第 264-299 行

**修复前**:
```javascript
const isCompleted = parsedStatus.is_completed === true || parsedStatus.stage === 'completed';

if (isCompleted && onComplete) {
  onComplete(parsedStatus);
} else if (!isCompleted && onError) {
  onError(new Error('诊断失败'));
}
```

**修复后**:
```javascript
// 【关键修复】区分"完全失败"和"部分完成"
const isCompleted = parsedStatus.is_completed === true || parsedStatus.stage === 'completed';
const hasResults = parsedStatus.results && parsedStatus.results.length > 0;
const hasDetailedResults = parsedStatus.detailed_results && parsedStatus.detailed_results.length > 0;
const hasAnyResults = hasResults || hasDetailedResults;

// 部分完成的情况：有结果但状态是 failed
if (!isCompleted && parsedStatus.stage === 'failed' && hasAnyResults) {
  console.warn('[品牌诊断] 部分完成：检测到结果但状态为 failed，可能是部分 AI 调用失败');
  // 仍然调用 onComplete，让前端展示可用结果
  if (onComplete) {
    onComplete(parsedStatus);
  }
  return;
}

// 正常完成
if (isCompleted && onComplete) {
  onComplete(parsedStatus);
} 
// 完全失败（无结果）
else if (!isCompleted && !hasAnyResults && onError) {
  onError(new Error(parsedStatus.error || '诊断失败'));
}
// 部分失败但有结果
else if (!isCompleted && hasAnyResults && onComplete) {
  console.warn('[品牌诊断] 部分失败但有结果，继续展示可用数据');
  onComplete(parsedStatus);
}
```

**修复逻辑**:
1. 检查结果是否存在 (`hasAnyResults`)
2. `stage='failed'` 但有结果 → 调用 `onComplete` 展示结果
3. `stage='failed'` 且无结果 → 调用 `onError` 报错
4. 添加警告日志，提示部分完成

### 3.3 前端辅助修复：保留失败时的进度值

**文件**: `services/taskStatusService.js`

**修复位置**: 第 80-86 行

**修复前**:
```javascript
case TASK_STAGES.FAILED:
  parsed.progress = 0; // 失败时进度为 0 或保持原值
  parsed.statusText = '任务执行失败...';
  parsed.stage = TASK_STAGES.FAILED;
  parsed.is_completed = false;
  break;
```

**修复后**:
```javascript
case TASK_STAGES.FAILED:
  // 【关键修复】失败时保留后端返回的进度值，不要强制设置为 0
  // 因为可能是部分完成，已经有进度和结果
  parsed.statusText = '任务执行失败...';
  parsed.stage = TASK_STAGES.FAILED;
  parsed.is_completed = false;
  break;
```

**说明**: 由于第 99-102 行已有逻辑覆盖后端进度值，此修复实际上通过"不设置 progress"来实现保留后端值。

---

## 四、修复验证

### 4.1 预期行为

| 场景 | 结果数 | 后端状态 | 前端处理 | 用户体验 |
|------|--------|---------|---------|---------|
| 完全成功 | 10/10 | completed | onComplete | ✅ 展示完整报告 |
| 部分完成 | 5/10 | completed + warning | onComplete | ✅ 展示可用报告 + 警告提示 |
| 完全失败 | 0/10 | failed | onError | ❌ 显示错误提示 |

### 4.2 测试步骤

1. **正常场景测试**:
   - 运行品牌诊断（所有 AI 平台正常）
   - 验证：进度 100%，状态 completed，展示完整报告

2. **部分失败场景测试**:
   - 运行品牌诊断（部分 AI 平台失败）
   - 验证：进度 100%，状态 completed + warning，展示可用报告

3. **完全失败场景测试**:
   - 运行品牌诊断（所有 AI 平台失败）
   - 验证：进度 0%，状态 failed，显示错误提示

### 4.3 验证检查点

- [ ] 后端日志显示"执行部分完成"而非"执行失败"
- [ ] 前端控制台显示警告而非错误
- [ ] 结果页正常打开并展示 5 个结果
- [ ] 页面顶部显示"部分结果缺失"警告提示

---

## 五、技术细节

### 5.1 后端状态流转

**修复前**:
```
执行中 → 验证失败 → stage=failed → 前端报错
```

**修复后**:
```
执行中 → 验证部分完成 → stage=completed + warning → 前端展示结果
         ↓
      验证完全失败 → stage=failed → 前端报错
```

### 5.2 前端状态判断逻辑

```javascript
// 优先级：有结果 > 状态标志
if (hasAnyResults) {
  // 有结果就展示，即使状态是 failed
  onComplete(parsedStatus);
} else if (isCompleted) {
  // 正常完成
  onComplete(parsedStatus);
} else {
  // 真的失败了
  onError('诊断失败');
}
```

### 5.3 容错机制

| 层级 | 容错措施 |
|------|---------|
| 后端验证 | 允许部分结果，不强制要求 100% 完成 |
| 状态标记 | 使用 warning 字段记录缺失情况 |
| 前端判断 | 优先检查结果存在性，而非状态标志 |
| 用户提示 | 区分"部分完成"和"完全失败"的提示 |

---

## 六、影响范围

### 6.1 修改文件

| 文件 | 修改类型 | 行数变化 |
|------|---------|---------|
| `backend_python/wechat_backend/nxm_execution_engine.py` | 逻辑增强 | +10 行 |
| `services/brandTestService.js` | 逻辑增强 | +21 行 |
| `services/taskStatusService.js` | 逻辑优化 | -1 行 |

### 6.2 影响功能

- ✅ 品牌诊断功能
- ✅ 结果展示功能
- ✅ 错误处理流程

### 6.3 兼容性

- ✅ 向后兼容：完全成功的场景不受影响
- ✅ 降级兼容：完全失败的场景保持原有行为
- ✅ 新增场景：部分完成的场景得到正确处理

---

## 七、后续建议

### 7.1 短期优化（1 周内）

1. **前端警告提示**:
   ```javascript
   if (parsedStatus.warning) {
     wx.showModal({
       title: '提示',
       content: `部分结果缺失：${parsedStatus.warning}`,
       showCancel: false
     });
   }
   ```

2. **后端缺失品牌提示**:
   - 在响应中添加 `missing_brands` 字段
   - 告知用户哪些品牌的数据缺失

### 7.2 中期优化（1 个月内）

1. **重试机制**:
   - 对失败的部分自动重试
   - 提高完成率

2. **熔断机制**:
   - 对频繁失败的 AI 平台暂时熔断
   - 优先使用可用平台

### 7.3 长期优化（持续）

1. **质量评分**:
   - 为部分完成的结果添加质量评分
   - 告知用户结果的可信度

2. **智能降级**:
   - 当部分平台失败时，自动调整预期结果数
   - 避免"部分完成"的警告

---

## 八、总结

### 8.1 核心问题

**问题**：后端将"部分完成"错误地标记为"失败"，导致前端无法展示有效结果。

**根因**：
1. 后端验证逻辑过于严格，不允许部分结果
2. 前端处理逻辑单一，未区分"部分失败"和"完全失败"

### 8.2 修复效果

- ✅ 有结果时总是展示，避免数据浪费
- ✅ 区分"部分完成"和"完全失败"，提供准确反馈
- ✅ 改善用户体验，减少无谓的错误提示

### 8.3 设计原则

**核心原则**: **有结果就展示，无结果才报错**

这一原则确保了：
1. 用户总能看到可用的数据
2. 不会因为部分失败而丢失全部结果
3. 错误提示更加准确和有意义

---

**修复者**: AI Assistant (系统首席架构师)  
**审核状态**: 待人工验证  
**文档版本**: v1.0  
**最后更新**: 2026-02-24

---

*本报告包含完整的问题分析、修复方案和验证指南*
