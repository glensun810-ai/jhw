# 品牌诊断系统 - 架构自检与问题盘点报告

**检查人**: 首席系统架构师 & 全栈开发工程师 (AI)
**检查日期**: 2026-02-23
**检查范围**: 参数调用、数据存取、前后端对接、模块交互
**检查依据**: `2026-02-23_全栈架构与参数调用关系总览.md`

---

## 执行摘要

### 检查结论

经过全面的架构自检，发现以下问题：

| 优先级 | 问题数量 | 状态 |
|-------|---------|------|
| 🔴 P0 | 2 | 需立即修复 |
| 🟡 P1 | 5 | 需优先修复 |
| 🟢 P2 | 8 | 建议优化 |

### 核心风险

1. **execution_store 内存泄漏风险** - 服务器重启后数据丢失
2. **数据库降级查询逻辑不完善** - 部分字段映射错误
3. **前端 Storage 数据格式不一致** - 可能导致结果页加载失败
4. **错误处理链路不完整** - 部分异常未正确传递到前端

---

## 一、🔴 P0 级问题（严重）

### P0-1: execution_store 内存依赖导致数据丢失

**问题描述**:
- 后端完全依赖内存中的 `execution_store` 存储任务状态
- 服务器重启或进程崩溃后，所有进行中的任务状态丢失
- 前端轮询时会收到 404 或空响应，导致超时错误

**影响范围**:
- 所有进行中的诊断任务
- 服务器重启后的所有用户

**问题链路**:
```
诊断任务执行中
    ↓
execution_store 存储状态
    ↓
服务器重启/进程崩溃
    ↓
execution_store 清空 ❌
    ↓
前端轮询 404 ❌
    ↓
轮询超时 ❌
```

**代码位置**:
- `wechat_backend/views.py:370` - execution_store 初始化
- `wechat_backend/views.py:2548` - 从 execution_store 查询
- `wechat_backend/views.py:2567` - 降级查询逻辑（不完善）

**当前降级逻辑问题**:
```python
# views.py:2567-2602
db_task_status = get_db_task_status(task_id)
if db_task_status:
    response_data = {
        'progress': db_task_status.get('progress', 0),
        # ❌ 问题：数据库中的 stage 是枚举值，前端期望字符串
        'stage': db_task_status.get('stage', 'init'),
        # ❌ 问题：数据库可能没有 detailed_results 字段
        'detailed_results': db_task_status.get('results', []),
    }
```

**修复建议**:
1. ✅ **持久化任务状态** - 每次进度更新都写入数据库
2. ✅ **完善降级查询** - 确保数据库查询返回完整数据结构
3. ✅ **添加任务恢复机制** - 服务器重启后恢复进行中的任务

**修复代码示例**:
```python
# 修复 1: 完善降级查询逻辑
def get_task_status_api(task_id):
    # 优先从 execution_store 获取
    if task_id in execution_store:
        return jsonify(execution_store[task_id])
    
    # 降级：从数据库查询完整数据
    db_status = get_db_task_status(task_id)
    db_result = get_deep_intelligence_result(task_id)
    
    if db_status and db_result:
        # 构建完整的响应数据结构
        response_data = {
            'task_id': task_id,
            'progress': db_status.progress,
            'stage': db_status.stage.value,  # ✅ 转换为字符串
            'status': 'completed' if db_status.is_completed else 'processing',
            'results': db_result.to_dict(),  # ✅ 完整的结果数据
            'detailed_results': db_result.detailed_results,
            'is_completed': db_status.is_completed,
            'created_at': db_status.created_at
        }
        return jsonify(response_data), 200
    
    #  truly not found
    return jsonify({'error': 'Task not found'}), 404
```

**优先级**: 🔴 P0
**预计修复时间**: 2 小时

---

### P0-2: 数据库表结构不一致导致查询失败

**问题描述**:
- `task_statuses` 表和 `test_records` 表结构不一致
- `task_statuses` 存储任务进度状态
- `test_records` 存储完整测试结果
- 但两个表之间的关联关系不清晰，导致降级查询失败

**发现的问题**:

```sql
-- task_statuses 表
CREATE TABLE task_statuses (
    task_id TEXT,
    progress INTEGER,
    stage TEXT,  -- 存储枚举值 'init', 'completed' 等
    status_text TEXT,
    is_completed BOOLEAN
);

-- test_records 表
CREATE TABLE test_records (
    id INTEGER PRIMARY KEY,
    execution_id TEXT,  -- 与 task_id 对应
    results_summary BLOB,  -- JSON 数据（可能压缩）
    is_summary_compressed BOOLEAN
);
```

**查询问题**:
```python
# views.py:2584-2590
cursor.execute("""
    SELECT results_summary, is_summary_compressed
    FROM test_records
    WHERE id = (SELECT MAX(id)
                FROM test_records
                WHERE json_extract(results_summary, '$.execution_id') = ?)
    """, (task_id,))
```

**问题分析**:
1. ❌ 使用 `json_extract` 查询压缩的 JSON 数据会失败
2. ❌ 子查询效率低，每次轮询都执行
3. ❌ `task_id` 和 `execution_id` 混用，容易混淆

**修复建议**:
```python
# 修复 1: 直接使用 execution_id 查询
cursor.execute("""
    SELECT results_summary, is_summary_compressed
    FROM test_records
    WHERE execution_id = ?
    ORDER BY id DESC
    LIMIT 1
    """, (task_id,))

# 修复 2: 添加索引
CREATE INDEX idx_test_records_execution_id ON test_records(execution_id);
```

**优先级**: 🔴 P0
**预计修复时间**: 1 小时

---

## 二、🟡 P1 级问题（重要）

### P1-1: 前端 Storage 数据格式不一致

**问题描述**:
- 前端使用多个 Storage key 存储诊断结果
- 不同入口写入的数据格式不一致
- 结果页加载时可能因为格式问题失败

**Storage Key 清单**:
```javascript
// index.js:996-1004
wx.setStorageSync('last_diagnostic_results', {
  results: resultsToSave,
  competitiveAnalysis: competitiveAnalysisToSave,
  brandScores: brandScoresToSave,
  targetBrand: this.data.brandName,
  executionId: executionId,
  timestamp: Date.now()
});

wx.setStorageSync('latestTestResults_' + executionId, resultsToSave);
wx.setStorageSync('latestCompetitiveAnalysis_' + executionId, competitiveAnalysisToSave);
wx.setStorageSync('latestBrandScores_' + executionId, brandScoresToSave);
wx.setStorageSync('latestTargetBrand', this.data.brandName);
```

**结果页加载逻辑**:
```javascript
// results.js:82-95
const lastDiagnosticResults = wx.getStorageSync('last_diagnostic_results');

if (lastDiagnosticResults && lastDiagnosticResults.executionId === executionId) {
  // ✅ 数据匹配，直接使用
  this.setData({
    targetBrand: lastDiagnosticResults.targetBrand,
    latestTestResults: lastDiagnosticResults.results,
    competitiveAnalysis: lastDiagnosticResults.competitiveAnalysis
  });
} else {
  // ❌ 数据不匹配，尝试从后端拉取
  this.fetchResultsFromServer(executionId, brandName);
}
```

**潜在问题**:
1. ❌ 如果 `last_diagnostic_results` 被清除，但 `latestTestResults_*` 还在，数据不一致
2. ❌ 多个 Storage key 增加维护复杂度
3. ❌ 没有数据校验逻辑

**修复建议**:
```javascript
// 统一 Storage 数据结构
const storageData = {
  executionId: executionId,
  brandName: brandName,
  timestamp: Date.now(),
  data: {
    results: resultsToSave,
    competitiveAnalysis: competitiveAnalysisToSave,
    brandScores: brandScoresToSave
  },
  version: '1.0'  // 添加版本号，便于后续升级
};

wx.setStorageSync('diagnosis_' + executionId, storageData);

// 统一加载逻辑
function loadDiagnosisResult(executionId) {
  const data = wx.getStorageSync('diagnosis_' + executionId);
  
  // 数据校验
  if (!data || !data.version || data.executionId !== executionId) {
    return null;
  }
  
  // 检查数据是否过期（7 天）
  const expiryTime = 7 * 24 * 60 * 60 * 1000;
  if (Date.now() - data.timestamp > expiryTime) {
    wx.removeStorageSync('diagnosis_' + executionId);
    return null;
  }
  
  return data.data;
}
```

**优先级**: 🟡 P1
**预计修复时间**: 2 小时

---

### P1-2: 错误处理链路不完整

**问题描述**:
- 后端某些异常未正确传递到前端
- 前端错误处理逻辑不完善
- 用户看到的错误信息不明确

**问题链路**:
```
后端异常
    ↓
try-catch 捕获
    ↓
记录日志 ✅
    ↓
返回通用错误消息 ❌
    ↓
前端显示"网络错误" ❌
```

**具体案例**:

**案例 1: AI 调用失败**
```python
# nxm_execution_engine.py:188-192
except Exception as e:
    api_logger.error(f"[NxM] 执行失败：{model_name}, Q{q_idx}: {e}")
    scheduler.record_model_failure(model_name)
    completed += 1
    # ❌ 问题：错误未传递到 execution_store
    # ❌ 前端不知道具体失败原因
```

**案例 2: 参数验证失败**
```python
# views.py:216-218
if 'brand_list' not in data:
    return jsonify({"status": "error", "error": 'Missing brand_list'}), 400
# ✅ 正确：返回具体错误信息
```

**修复建议**:
```python
# 修复 1: 完善错误传递
except Exception as e:
    error_message = f"AI 调用失败：{model_name}, 问题{q_idx+1}: {str(e)}"
    api_logger.error(error_message)
    
    # 更新 execution_store，包含错误信息
    if execution_id in execution_store:
        execution_store[execution_id].update({
            'status': 'failed',
            'error': error_message,
            'error_details': {
                'model': model_name,
                'question_index': q_idx,
                'error_type': type(e).__name__
            }
        })
```

```javascript
// 修复 2: 前端完善错误处理
handleDiagnosisError(error) {
  const errorMessages = {
    '诊断超时': '诊断耗时过长，请重试或联系管理员',
    '权限验证失败': '登录已过期，请重新登录',
    '网络请求失败': '网络连接异常，请检查网络',
    'AI 调用失败': 'AI 服务暂时不可用，请稍后重试'
  };
  
  const userMessage = errorMessages[error.message] || error.message;
  
  wx.showModal({
    title: '诊断失败',
    content: userMessage,
    showCancel: false
  });
}
```

**优先级**: 🟡 P1
**预计修复时间**: 3 小时

---

### P1-3: selectedModels 参数格式转换不一致

**问题描述**:
- 前端传递的 `selectedModels` 格式与后端期望不一致
- 后端有多次格式转换，增加出错风险
- 部分转换逻辑重复

**前端格式**:
```javascript
// brandTestService.js:46-68
const processedSelectedModels = (selectedModels || []).map(item => {
  if (typeof item === 'object' && item !== null) {
    const modelName = (item.id || item.name || item.value || '').toLowerCase();
    return {
      name: modelName,
      checked: item.checked !== undefined ? item.checked : true
    };
  }
  // ...
});

// 最终发送格式
{
  brand_list: [...],
  selectedModels: [{name: 'deepseek', checked: true}, ...],
  custom_question: '...'
}
```

**后端格式转换**:
```python
# views.py:246-268
# 第一次转换：从对象数组提取名称
parsed_selected_models = []
for model in selected_models:
    if isinstance(model, dict):
        model_name = model.get('name') or model.get('id') or model.get('value') or model.get('label')
        if model_name:
            parsed_selected_models.append({'name': model_name, 'checked': model.get('checked', True)})

# 第二次转换：NxM 引擎再次处理
# nxm_execution_engine.py:78
for model_idx, model_name in enumerate(selected_models):
    client = AIAdapterFactory.create(model_name)  # 期望字符串
```

**问题分析**:
1. ❌ 前端已经转换为 `{name, checked}` 格式
2. ❌ 后端再次转换，增加复杂度
3. ❌ NxM 引擎期望字符串，但收到对象数组

**修复建议**:
```javascript
// 前端直接发送字符串数组
const modelNames = selectedModels.map(item => {
  return (item.id || item.name || item.value || '').toLowerCase();
});

const payload = {
  brand_list,
  selectedModels: modelNames,  // ✅ 直接发送字符串数组
  custom_question
};
```

```python
# 后端简化处理
# views.py:236-240
selected_models = data['selectedModels']  # 已经是字符串数组
if not selected_models:
    return jsonify({"error": 'At least one AI model must be selected'}), 400
```

**优先级**: 🟡 P1
**预计修复时间**: 1 小时

---

### P1-4: 轮询状态更新不及时

**问题描述**:
- NxM 引擎执行过程中，进度更新频率低
- 前端轮询 800ms 一次，但后端可能长时间不更新进度
- 用户感觉"卡住"

**当前更新逻辑**:
```python
# nxm_execution_engine.py:103-105
for q_idx, question_template in enumerate(raw_questions):
    for model_idx, model_name in enumerate(selected_models):
        # 执行 AI 调用...
        # ❌ 问题：只有所有调用完成后才更新进度
```

**修复建议**:
```python
# 每次 AI 调用后都更新进度
for q_idx, question_template in enumerate(raw_questions):
    for model_idx, model_name in enumerate(selected_models):
        try:
            # 执行 AI 调用
            response = client.generate_response(...)
            
            # ✅ 立即更新进度
            completed += 1
            progress = int((completed / total_tasks) * 100)
            
            if execution_id in execution_store:
                execution_store[execution_id].update({
                    'progress': progress,
                    'stage': 'ai_fetching',
                    'status': f'正在处理问题{q_idx+1}/{len(raw_questions)} - 模型{model_idx+1}'
                })
            
        except Exception as e:
            # 记录错误，继续执行
            completed += 1
```

**优先级**: 🟡 P1
**预计修复时间**: 2 小时

---

### P1-5: 数据库连接未正确关闭

**问题描述**:
- 部分数据库查询后未关闭连接
- 可能导致连接泄漏
- 长时间运行后可能耗尽连接池

**问题代码**:
```python
# views.py:2584-2592
conn = get_connection()
cursor = conn.cursor()
cursor.execute("SELECT ...", (task_id,))
db_row = cursor.fetchone()
conn.close()  # ✅ 有关闭

# 但如果中间抛出异常...
try:
    conn = get_connection()
    cursor.execute("SELECT ...")
    result = process(cursor.fetchone())
    conn.close()  # ❌ 异常时不会执行
except:
    pass  # ❌ 连接泄漏
```

**修复建议**:
```python
# 使用上下文管理器
from contextlib import contextmanager

@contextmanager
def get_db_connection():
    conn = get_connection()
    try:
        yield conn
    finally:
        conn.close()

# 使用示例
with get_db_connection() as conn:
    cursor = conn.cursor()
    cursor.execute("SELECT ...", (task_id,))
    db_row = cursor.fetchone()
# 自动关闭连接
```

**优先级**: 🟡 P1
**预计修复时间**: 1 小时

---

## 三、🟢 P2 级问题（优化建议）

### P2-1: 日志记录过于详细

**问题**: 生产环境记录过多 DEBUG 日志，影响性能
**建议**: 根据环境配置日志级别
**优先级**: 🟢 P2

### P2-2: 缺少请求限流监控

**问题**: 有限流但无监控，无法识别攻击
**建议**: 添加限流触发告警
**优先级**: 🟢 P2

### P2-3: AI 适配器缺少缓存

**问题**: 相同问题重复调用 AI，浪费配额
**建议**: 添加问题 - 答案缓存
**优先级**: 🟢 P2

### P2-4: 前端缺少离线支持

**问题**: 网络断开后无法查看历史结果
**建议**: 实现离线缓存
**优先级**: 🟢 P2

### P2-5: 缺少性能监控

**问题**: 无法追踪 API 响应时间
**建议**: 添加 APM 监控
**优先级**: 🟢 P2

### P2-6: 错误日志无结构化

**问题**: 日志难以机器分析
**建议**: 使用结构化日志
**优先级**: 🟢 P2

### P2-7: 缺少自动化测试

**问题**: 依赖手动测试，回归成本高
**建议**: 添加集成测试
**优先级**: 🟢 P2

### P2-8: 文档更新滞后

**问题**: 代码变更后文档未同步更新
**建议**: 建立文档审查流程
**优先级**: 🟢 P2

---

## 四、问题汇总与修复计划

### 4.1 问题汇总表

| 编号 | 优先级 | 问题描述 | 模块 | 预计工时 |
|-----|--------|---------|------|---------|
| P0-1 | 🔴 | execution_store 内存依赖 | 后端 | 2h |
| P0-2 | 🔴 | 数据库表结构不一致 | 数据库 | 1h |
| P1-1 | 🟡 | Storage 数据格式不一致 | 前端 | 2h |
| P1-2 | 🟡 | 错误处理链路不完整 | 全栈 | 3h |
| P1-3 | 🟡 | selectedModels 格式转换不一致 | 全栈 | 1h |
| P1-4 | 🟡 | 轮询状态更新不及时 | 后端 | 2h |
| P1-5 | 🟡 | 数据库连接未正确关闭 | 后端 | 1h |
| P2-1~8 | 🟢 | 优化建议 (8 项) | 全栈 | 8h |

### 4.2 修复计划

**第一阶段 (立即执行 - P0)**:
- [ ] 修复 execution_store 降级查询逻辑
- [ ] 修复数据库查询索引问题
- **预计时间**: 3 小时

**第二阶段 (本周内 - P1)**:
- [ ] 统一 Storage 数据格式
- [ ] 完善错误处理链路
- [ ] 简化 selectedModels 格式
- [ ] 优化轮询状态更新
- [ ] 修复数据库连接泄漏
- **预计时间**: 9 小时

**第三阶段 (下周 - P2)**:
- [ ] 实施 8 项优化建议
- **预计时间**: 8 小时

---

## 五、自检方法论

### 5.1 检查维度

1. **参数传递链路** - 从前端到后端到数据库
2. **数据一致性** - 存储格式、读取格式、转换逻辑
3. **错误处理** - 异常捕获、日志记录、用户提示
4. **性能优化** - 缓存、索引、连接池
5. **可维护性** - 代码结构、文档、测试

### 5.2 检查工具

- 静态代码分析
- 调用链路追踪
- 日志分析
- 性能监控

### 5.3 检查标准

- ✅ 参数类型匹配
- ✅ 数据格式一致
- ✅ 错误处理完整
- ✅ 资源正确释放
- ✅ 日志清晰可读

---

**报告生成时间**: 2026-02-23
**检查人**: 首席系统架构师 & 全栈开发工程师 (AI)
**状态**: ✅ 已完成
**下一步**: 按优先级执行修复
