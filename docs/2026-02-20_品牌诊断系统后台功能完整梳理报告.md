# 品牌诊断系统后台功能完整梳理报告

**生成时间**: 2026-02-20  
**文档版本**: 1.0  
**梳理范围**: 品牌诊断系统所有后台功能模块

---

## 一、问题背景

当前诊断过程中存在**时序不同步**问题：
- 前端诊断报告已经弹出
- `ai_responses.jsonl` 文件里的结果还没完全写入
- 导致前端报告中的数据与实际 AI 平台反馈的结果对不上

**根本原因分析**：
1. 前端轮询 `/api/test-progress` 获取进度时，后端 `execution_store` 中的数据可能尚未完全同步
2. AI 响应日志写入 (`ai_responses.jsonl`) 与结果返回给前端是异步的
3. 诊断报告生成可能基于不完整的中间状态数据

---

## 二、系统架构总览

### 2.1 核心数据流

```
用户输入 (品牌/问题/模型选择)
    ↓
前端请求 → /api/perform-brand-test
    ↓
后端生成 execution_id → execution_store[execution_id] = {初始化状态}
    ↓
启动异步线程 run_async_test()
    ├─→ 立即返回 execution_id 给前端
    └─→ 后台执行 NxM 测试循环
         ├─→ 调用 AI 适配器 (AIAdapterFactory.create)
         ├─→ 发送 prompt 获取 AI 响应
         ├─→ 解析 GEO 分析结果
         ├─→ 写入 ai_responses.jsonl ← 【关键：日志写入点】
         ├─→ 更新 execution_store[execution_id].results
         └─→ 更新 execution_store[execution_id].progress
              ↓
前端轮询 /api/test-progress?executionId={id}
    ↓
返回 execution_store[execution_id] 数据
    ↓
前端解析并展示诊断报告
```

### 2.2 关键存储介质

| 存储介质 | 路径/位置 | 用途 | 写入时机 |
|---------|----------|------|---------|
| `execution_store` | 内存 (Python dict) | 临时存储执行进度和结果 | 执行过程中实时更新 |
| `ai_responses.jsonl` | `backend_python/data/ai_responses/ai_responses.jsonl` | 持久化 AI 响应日志 | 每次 AI 调用完成后立即写入 |
| `test_records` | SQLite 数据库 | 测试结果记录 | 全部执行完成后写入 |
| `task_status` | SQLite 数据库 | 任务状态跟踪 | 各阶段更新时写入 |

---

## 三、功能模块详细梳理

### 3.1 品牌测试执行模块 (`/api/perform-brand-test`)

**文件位置**: `wechat_backend/views.py`

#### 3.1.1 输入验证规则

| 字段 | 类型 | 验证规则 | 默认值 |
|------|------|---------|--------|
| `brand_list` | list | 非空，每个元素为字符串，长度≤100 | - |
| `selectedModels` | list | 非空，支持对象/字符串格式 | - |
| `custom_question` | string | 可选，长度≤500 | - |
| `customQuestions` | list | 可选，每个元素为字符串 | - |
| `userLevel` | string | Free/Premium/Enterprise | 'Free' |

#### 3.1.2 执行流程

```python
1. 输入验证和净化 (InputValidator, validate_safe_text)
2. 解析 selectedModels → 标准化为 [{'name': 'deepseek', 'checked': True}]
3. 解析问题：
   - 优先使用 custom_question (字符串，智能分割)
   - 备选使用 customQuestions (数组)
   - 默认问题模板：["介绍一下{brandName}", "{brandName}的主要产品是什么", ...]
4. 验证 AI 模型可用性：
   - AIAdapterFactory.is_platform_available(normalized_model_name)
   - 检查 API Key 配置：config_manager.get_api_key()
5. 生成 execution_id = uuid.uuid4()
6. 初始化 execution_store[execution_id] = {progress: 0, completed: 0, total: 0, ...}
7. 启动异步线程 run_async_test()
8. 立即返回 {'status': 'success', 'execution_id': execution_id}
```

#### 3.1.3 数据来源

| 数据项 | 来源 | 处理逻辑 |
|--------|------|---------|
| 品牌列表 | 前端请求体 | 直接读取 `data['brand_list']` |
| 模型选择 | 前端请求体 | 解析对象/字符串格式，标准化 |
| 问题列表 | 前端请求体/默认模板 | 智能分割或数组处理 |
| API Key | 配置管理器 | `config_manager.get_api_key(platform)` |
| 模型 ID | 配置管理器 | `config_manager.get_platform_model(platform)` |

---

### 3.2 NxM 执行引擎模块

**文件位置**: `wechat_backend/nxm_execution_engine.py`

#### 3.2.1 执行公式

```
总请求次数 = 问题数 × 模型数

注意：只针对用户自己的品牌 (main_brand) 进行请求
竞品品牌 (competitor_brands) 仅用于 Prompt 中的对比分析，不参与 API 请求循环
```

#### 3.2.2 循环逻辑

```python
for q_idx, base_question in enumerate(raw_questions):          # 外层：问题循环
    question_text = base_question.replace('{brandName}', main_brand)
    
    for model_idx, model_info in enumerate(selected_models):    # 内层：模型循环
        model_name = model_info['name']
        
        # 1. 创建 AI 客户端
        adapter = AIAdapterFactory.create(normalized_model_name, api_key, model_id)
        
        # 2. 构建 GEO Prompt
        geo_prompt = GEO_PROMPT_TEMPLATE.format(
            brand_name=main_brand,
            competitors=", ".join(competitor_brands),
            question=question_text
        )
        
        # 3. 调用 AI 平台
        ai_response = adapter.send_prompt(geo_prompt, ...)
        
        # 4. 解析 GEO 分析结果
        analysis = parse_geo_json(ai_response.content)
        
        # 5. 【关键】写入 ai_responses.jsonl
        log_ai_response(...)
        
        # 6. 更新 execution_store
        execution_store[execution_id].update({
            'progress': int((completed_count / total_executions) * 100),
            'completed': completed_count,
            'results': all_results
        })
```

#### 3.2.3 GEO Prompt 模板

**文件位置**: `wechat_backend/ai_adapters/base_adapter.py`

```python
GEO_PROMPT_TEMPLATE = """
用户品牌：{brand_name}
竞争对手：{competitors}

请回答以下用户问题：
{question}

---
重要要求：
1. 请以专业顾问的身份客观回答。
2. 在回答结束后，必须另起一行，以严格的 JSON 格式输出以下字段：
{{
  "geo_analysis": {{
    "brand_mentioned": boolean,
    "rank": number,
    "sentiment": number,
    "cited_sources": [
      {{"url": "string", "site_name": "string", "attitude": "positive/negative/neutral"}}
    ],
    "interception": "string"
  }}
}}
"""
```

#### 3.2.4 数据来源映射

| 数据项 | 来源 | 处理逻辑 |
|--------|------|---------|
| `main_brand` | `brand_list[0]` | 用户自己的品牌 |
| `competitor_brands` | `brand_list[1:]` | 竞品品牌列表 |
| `raw_questions` | 前端输入/默认模板 | QuestionManager 验证后返回 |
| `selected_models` | 前端输入 | 解析并标准化 |
| `api_key` | 配置管理器 | `config_manager.get_api_key(platform)` |
| `model_id` | 配置管理器 | `config_manager.get_platform_model(platform)` |

---

### 3.3 AI 响应日志模块

**文件位置**: `utils/ai_response_logger_v2.py`

#### 3.3.1 日志记录结构 (V2 增强版)

```json
{
  "record_id": "uuid",
  "timestamp": "ISO 格式时间戳",
  "unix_timestamp": 1234567890.123,
  "version": "2.0",
  
  "question": {
    "text": "问题内容",
    "stats": {"length": 23, "chinese_chars": 21, ...}
  },
  
  "response": {
    "text": "AI 响应内容",
    "stats": {"length": 1500, "chinese_chars": 1200, ...}
  },
  
  "platform": {
    "name": "豆包",
    "model": "ep-20260212000000-gd5tq"
  },
  
  "business": {
    "brand": "品牌名",
    "competitor": "竞品名",
    "industry": "行业",
    "question_category": "问题分类"
  },
  
  "performance": {
    "latency_ms": 5000,
    "tokens": {"total": 1000, "prompt": 500, "completion": 500},
    "throughput": 200.0
  },
  
  "status": {
    "success": true,
    "error_message": null,
    "error_type": null,
    "http_status_code": 200
  },
  
  "reliability": {
    "retry_count": 0,
    "circuit_breaker_open": false
  },
  
  "context": {
    "execution_id": "执行 ID",
    "question_index": 1,
    "total_questions": 6
  },
  
  "quality": {
    "score": 0.9,
    "has_structured_data": true,
    "completeness": 0.95
  },
  
  "metadata": {
    "source": "nxm_execution_engine",
    "geo_analysis": {...}
  }
}
```

#### 3.3.2 写入时机

**关键发现**：日志写入发生在 AI 响应解析之后，但在更新 `execution_store` 之前

```python
# nxm_execution_engine.py 第 176-201 行
try:
    # 记录 AI 响应的前 200 个字符用于调试
    api_logger.info(f"AI Response preview: {response_text[:200]}...")
    
    # 先解析 GEO 分析结果
    analysis = parse_geo_json(response_text)
    
    # 【日志写入点】记录到 ai_responses.jsonl 文件
    try:
        from utils.ai_response_logger_v2 import log_ai_response
        log_ai_response(
            question=geo_prompt,
            response=response_text,
            platform=normalized_model_name,
            model=model_id,
            brand=main_brand,
            competitor=", ".join(competitor_brands) if competitor_brands else None,
            industry="家居定制",
            question_category="品牌搜索",
            latency_ms=int(latency * 1000),
            tokens_used=getattr(ai_response, 'tokens_used', 0),
            success=True,
            execution_id=execution_id,
            question_index=q_idx + 1,
            total_questions=len(raw_questions) * len(selected_models),
            metadata={
                "source": "nxm_execution_engine",
                "geo_analysis": analysis
            }
        )
        api_logger.info(f"[AIResponseLogger] Task [Q:{q_idx+1}] [Model:{model_name}] logged successfully")
    except Exception as log_error:
        api_logger.warning(f"[AIResponseLogger] Failed to log: {log_error}")
    
    # 【结果更新点】构造结构化结果并更新 execution_store
    result_item.update({
        "content": response_text,
        "geo_data": analysis,
        "status": "success",
        "latency": latency,
        "tokens_used": getattr(ai_response, 'tokens_used', 0),
        "platform": normalized_model_name
    })
```

#### 3.3.3 问题根因

**时序问题**：
1. 日志写入 (`log_ai_response`) 是同步文件 I/O 操作
2. 如果文件 I/O 较慢，可能导致 `execution_store` 已更新但日志尚未落盘
3. 前端轮询获取 `execution_store` 数据时，可能拿到的是"中间状态"
4. 但更关键的是：**前端可能在 AI 调用尚未全部完成时就获取了部分结果**

---

### 3.4 进度查询接口 (`/api/test-progress`)

**文件位置**: `wechat_backend/views.py` 第 2156 行

#### 3.4.1 接口逻辑

```python
@wechat_bp.route('/api/test-progress', methods=['GET'])
def get_test_progress():
    execution_id = request.args.get('executionId')
    if execution_id and execution_id in execution_store:
        progress_data = execution_store[execution_id]
        
        # 如果任务已完成，添加停止轮询标志
        if progress_data.get('status') in ['completed', 'failed']:
            progress_data['should_stop_polling'] = True
        
        return jsonify(progress_data)
    else:
        return jsonify({'error': 'Execution ID not found'}), 404
```

#### 3.4.2 返回数据结构

```json
{
  "progress": 50,
  "completed": 3,
  "total": 6,
  "status": "ai_fetching",
  "stage": "ai_fetching",
  "results": [
    {
      "question_id": 0,
      "question_text": "介绍一下品牌名",
      "main_brand": "品牌名",
      "model": "deepseek",
      "content": "AI 响应内容",
      "geo_data": {"rank": 1, "sentiment": 0.8, ...},
      "status": "success",
      "latency": 5.2,
      "tokens_used": 1000
    },
    ...
  ],
  "start_time": "2026-02-20T10:00:00.000000"
}
```

#### 3.4.3 数据来源

| 字段 | 来源 | 更新时机 |
|------|------|---------|
| `progress` | 计算值 | 每次循环后更新：`int((completed_count / total_executions) * 100)` |
| `completed` | 计数器 | 每次循环后 +1 |
| `total` | 计算值 | 初始化时计算：`len(raw_questions) * len(selected_models)` |
| `status` | 状态机 | 执行中：'ai_fetching'，完成：'completed' |
| `results` | 数组 | 每次循环后追加 result_item |
| `stage` | 状态机 | 与 status 同步 |

---

### 3.5 AI 适配器工厂模块

**文件位置**: `wechat_backend/ai_adapters/factory.py`

#### 3.5.1 平台名称映射规则

```python
MODEL_NAME_MAP = {
    # 豆包平台
    "豆包": "doubao",
    "doubao": "doubao",
    "doubao-pro": "doubao",
    "ep-20260212000000-gd5tq": "doubao",  # 豆包部署点 ID
    
    # 通义千问
    "qwen": "qwen",
    "千问": "qwen",
    "通义千问": "qwen",
    
    # DeepSeek
    "deepseek": "deepseek",
    "deepseek-chat": "deepseek",
    "deepseek-r1": "deepseekr1",
    
    # 智谱 AI
    "zhipu": "zhipu",
    "智谱": "zhipu",
    "glm-4": "zhipu",
    
    # ... 其他平台
}
```

#### 3.5.2 适配器注册机制

```python
# 注册已导入的适配器
if DeepSeekAdapter:
    AIAdapterFactory.register(AIPlatformType.DEEPSEEK, DeepSeekAdapter)
if QwenAdapter:
    AIAdapterFactory.register(AIPlatformType.QWEN, QwenAdapter)
if DoubaoAdapter:
    AIAdapterFactory.register(AIPlatformType.DOUBAO, DoubaoAdapter)
if ZhipuAdapter:
    AIAdapterFactory.register(AIPlatformType.ZHIPU, ZhipuAdapter)
# ... 其他适配器
```

#### 3.5.3 适配器创建流程

```python
@classmethod
def create(cls, platform_type, api_key=None, model_name=None, **kwargs):
    # 1. 标准化平台名称
    normalized_platform_type = cls.get_normalized_model_name(platform_type)
    
    # 2. 检查适配器是否已注册
    if platform_type not in cls._adapters:
        raise ValueError(f"No adapter registered for platform: {platform_type}")
    
    # 3. 如果 API Key 未提供，从配置管理器获取
    if not api_key:
        api_key = config_manager.get_api_key(platform_type.value)
    
    # 4. 如果模型名未提供，从配置管理器获取默认值
    if not model_name:
        model_name = config_manager.get_platform_model(platform_type.value)
    
    # 5. 创建适配器实例
    adapter_class = cls._adapters[platform_type]
    return adapter_class(api_key, model_name, **kwargs)
```

---

### 3.6 报告生成模块

**文件位置**: `wechat_backend/analytics/report_generator.py`

#### 3.6.1 报告生成流程

```python
def generate_executive_summary(self, brand_name: str, days: int = 30):
    # 1. 获取测试结果数据 (从数据库)
    test_results = self._get_test_results(brand_name, days)
    
    # 2. 获取巡航趋势数据
    trend_data = self.cruise_controller.get_trend_data(brand_name, days)
    
    # 3. 计算 ROI 指标
    roi_metrics = self._calculate_roi_metrics(test_results, trend_data)
    
    # 4. 计算曝光增量
    exposure_increment = self._calculate_exposure_increment(trend_data)
    
    # 5. 生成汇总报告
    summary = {
        'brand_name': brand_name,
        'report_period': {...},
        'roi_metrics': roi_metrics,
        'exposure_metrics': {...},
        'performance_summary': {...},
        'key_insights': [...],
        'recommendations': [...]
    }
    
    return summary
```

#### 3.6.2 数据来源

| 数据项 | 来源表 | 查询条件 |
|--------|--------|---------|
| 测试结果 | `test_records` | `WHERE brand_name = ? AND test_date >= ?` |
| 巡航趋势 | `cruise_trend` (推测) | `brand_name` + 时间范围 |
| 情报结果 | `deep_intelligence` | `brand_name` |

---

### 3.7 任务状态管理模块

**文件位置**: `wechat_backend/models.py`

#### 3.7.1 任务状态枚举

```python
class TaskStage(Enum):
    INIT = "init"
    QUESTION_PREPARATION = "question_preparation"
    AI_FETCHING = "ai_fetching"
    INTELLIGENCE_EVALUATING = "intelligence_evaluating"
    INTELLIGENCE_ANALYZING = "intelligence_analyzing"
    COMPETITION_ANALYZING = "competition_analyzing"
    SOURCE_TRACING = "source_tracing"
    RANKING_ANALYSIS = "ranking_analysis"
    COMPLETED = "completed"
    FAILED = "failed"
```

#### 3.7.2 状态更新逻辑

```python
def update_task_stage(task_id, stage, progress, status_text):
    """更新任务阶段"""
    # 1. 查询现有状态
    # 2. 更新 stage, progress, status_text
    # 3. 如果 stage 是 completed/failed，设置 is_completed=True
    # 4. 保存到数据库
```

---

## 四、问题根因分析

### 4.1 时序问题详解

```
时间线：
T0: 前端发起 /api/perform-brand-test 请求
T1: 后端生成 execution_id，初始化 execution_store
T2: 后端启动异步线程，立即返回 execution_id
T3: 前端开始轮询 /api/test-progress
T4: 异步线程执行第 1 个 AI 调用
T5: AI 返回响应
T6: 解析 GEO 分析结果
T7: 写入 ai_responses.jsonl  ← 【日志写入点】
T8: 更新 execution_store[execution_id].results  ← 【结果更新点】
T9: 前端轮询获取到第 1 个结果
...
Tn: 异步线程执行第 N 个 AI 调用
Tn+1: 前端轮询获取到部分结果（尚未完成）
Tn+2: 前端判断 progress >= 100 或 status == 'completed'
Tn+3: 前端弹出诊断报告  ← 【问题：此时可能还有日志未写入完成】
```

### 4.2 关键问题点

1. **日志写入与结果更新不同步**
   - `log_ai_response()` 是同步文件 I/O
   - 如果文件 I/O 慢，可能导致 `execution_store` 已更新但日志未落盘

2. **前端轮询时机过早**
   - 前端在 `status == 'completed'` 时立即展示报告
   - 但此时可能还有后台处理（如数据库保存）未完成

3. **数据库保存延迟**
   - `save_test_record()` 在所有 AI 调用完成后执行
   - 如果前端此时读取数据库，可能拿到旧数据

### 4.3 数据一致性风险

| 场景 | 风险 | 影响 |
|------|------|------|
| 日志写入慢 | `ai_responses.jsonl` 缺少最新记录 | 后续分析基于不完整数据 |
| 数据库保存慢 | `test_records` 表无最新记录 | 报告生成基于旧数据 |
| 前端轮询快 | 获取到中间状态 | 报告显示部分结果 |

---

## 五、修复方案

### 5.1 方案 1：确保日志写入完成后再更新进度

**修改位置**: `wechat_backend/nxm_execution_engine.py`

```python
# 当前逻辑（有问题）：
try:
    log_ai_response(...)  # 写入日志
except Exception as log_error:
    api_logger.warning(f"[AIResponseLogger] Failed to log: {log_error}")

result_item.update({...})  # 更新结果
all_results.append(result_item)  # 追加到结果列表
execution_store[execution_id].update({...})  # 更新进度

# 修复后逻辑：
try:
    log_ai_response(...)  # 写入日志
    # 【新增】确保日志落盘
    # (ai_response_logger_v2.py 内部已处理，无需额外操作)
except Exception as log_error:
    api_logger.error(f"[AIResponseLogger] CRITICAL: Failed to log: {log_error}")
    # 【关键】日志写入失败时，不应更新进度
    result_item.update({
        "status": "logged_failed",  # 特殊状态
        "error": f"日志写入失败：{log_error}"
    })
    all_results.append(result_item)
    execution_store[execution_id].update({...})
    continue  # 跳过本次循环

result_item.update({...})
all_results.append(result_item)
execution_store[execution_id].update({...})
```

### 5.2 方案 2：添加"日志写入完成"标志

**修改位置**: `wechat_backend/views.py` - `/api/test-progress`

```python
@wechat_bp.route('/api/test-progress', methods=['GET'])
def get_test_progress():
    execution_id = request.args.get('executionId')
    if execution_id and execution_id in execution_store:
        progress_data = execution_store[execution_id]
        
        # 【新增】检查日志写入状态
        if progress_data.get('status') == 'completed':
            # 确保所有日志已落盘
            total_logged = count_logged_records(execution_id)  # 新增函数
            total_expected = progress_data.get('total', 0)
            
            if total_logged < total_expected:
                # 日志尚未完全写入，返回"处理中"状态
                progress_data['status'] = 'finalizing'
                progress_data['message'] = f'正在完成日志写入 ({total_logged}/{total_expected})'
        
        if progress_data.get('status') in ['completed', 'failed']:
            progress_data['should_stop_polling'] = True
        
        return jsonify(progress_data)
```

### 5.3 方案 3：前端增加"数据就绪"确认

**修改位置**: `services/mvpService.js` 或 `pages/mvp-index/mvp-index.js`

```javascript
// 当前逻辑（有问题）：
if (result.success && result.results) {
  this.handleTestComplete(result.results);  // 立即跳转
}

// 修复后逻辑：
if (result.success && result.results) {
  // 【新增】确认数据已就绪
  const expectedCount = result.total || result.results.length;
  const actualCount = result.results.filter(r => r.status === 'success').length;
  
  if (actualCount >= expectedCount) {
    // 数据完整，可以跳转
    this.handleTestComplete(result.results);
  } else {
    // 数据不完整，继续等待
    this.setData({
      statusText: `正在完成数据处理 (${actualCount}/${expectedCount})...`
    });
    // 继续轮询或延迟跳转
  }
}
```

### 5.4 方案 4：数据库保存完成后才标记为 completed

**修改位置**: `wechat_backend/nxm_execution_engine.py`

```python
# 当前逻辑：
execution_store[execution_id].update({
    'status': 'completed',
    'stage': 'completed',
    'progress': 100,
    ...
})

# 将结果保存到数据库
save_test_record(...)

# 修复后逻辑：
# 先保存到数据库
try:
    record_id = save_test_record(...)
    api_logger.info(f"Saved test record with ID: {record_id}")
except Exception as e:
    api_logger.error(f"Error saving test records: {e}")
    # 数据库保存失败，不应标记为 completed
    execution_store[execution_id].update({
        'status': 'failed',
        'error': f'数据库保存失败：{e}'
    })
    return

# 数据库保存成功后，才标记为 completed
execution_store[execution_id].update({
    'status': 'completed',
    'stage': 'completed',
    'progress': 100,
    'database_record_id': record_id,  # 新增：数据库记录 ID
    'data_ready': True  # 新增：数据就绪标志
})
```

---

## 六、推荐修复优先级

### 6.1 紧急修复（P0）

1. **确保数据库保存完成后再标记为 completed**
   - 防止前端读取到未保存的数据
   - 修改位置：`nxm_execution_engine.py`

2. **添加日志写入失败处理**
   - 日志写入失败时不应静默忽略
   - 修改位置：`nxm_execution_engine.py`

### 6.2 重要修复（P1）

3. **前端增加数据完整性校验**
   - 确认结果数量与预期一致后再展示报告
   - 修改位置：`mvpService.js` 或 `mvp-index.js`

4. **添加"数据就绪"标志**
   - 在 `execution_store` 中添加 `data_ready` 字段
   - 修改位置：`views.py` - `/api/test-progress`

### 6.3 优化修复（P2）

5. **日志写入性能优化**
   - 考虑异步日志写入或批量写入
   - 修改位置：`ai_response_logger_v2.py`

6. **添加日志写入确认机制**
   - 写入后验证记录是否存在
   - 修改位置：`ai_response_logger_v2.py`

---

## 七、自检清单

### 7.1 功能模块覆盖检查

- [x] 品牌测试执行模块 (`/api/perform-brand-test`)
- [x] NxM 执行引擎模块
- [x] AI 响应日志模块
- [x] 进度查询接口 (`/api/test-progress`)
- [x] AI 适配器工厂模块
- [x] 报告生成模块
- [x] 任务状态管理模块

### 7.2 数据流检查

- [x] 输入数据来源明确
- [x] 数据处理逻辑清晰
- [x] 输出数据去向明确
- [x] 存储介质和时机明确

### 7.3 问题根因检查

- [x] 时序问题分析
- [x] 数据一致性风险分析
- [x] 修复方案覆盖所有问题点

### 7.4 修复方案检查

- [x] 紧急修复方案可行
- [x] 重要修复方案可行
- [x] 优化修复方案可行
- [x] 修复优先级合理

---

## 八、附录

### 8.1 相关文件清单

| 文件路径 | 模块 | 关键函数/类 |
|---------|------|------------|
| `wechat_backend/views.py` | API 端点 | `perform_brand_test`, `get_test_progress` |
| `wechat_backend/nxm_execution_engine.py` | 执行引擎 | `execute_nxm_test` |
| `utils/ai_response_logger_v2.py` | 日志记录 | `AIResponseLogger`, `log_ai_response` |
| `wechat_backend/ai_adapters/factory.py` | 适配器工厂 | `AIAdapterFactory.create` |
| `wechat_backend/ai_adapters/base_adapter.py` | 基础适配器 | `AIClient`, `GEO_PROMPT_TEMPLATE` |
| `wechat_backend/analytics/report_generator.py` | 报告生成 | `ReportGenerator.generate_executive_summary` |
| `wechat_backend/models.py` | 数据模型 | `TaskStatus`, `TaskStage` |
| `services/DiagnosisService.js` | 前端诊断服务 | `parseTaskStatus` |
| `services/mvpService.js` | 前端 MVP 服务 | `startMVPBrandTest` |

### 8.2 关键配置项

| 配置项 | 位置 | 说明 |
|--------|------|------|
| `LOG_FILE` | `config.py` | 日志文件路径 |
| `DB_PATH` | `database.py` | 数据库文件路径 |
| `execution_store` | `views.py` | 内存状态存储 |
| `AIAdapterFactory.MODEL_NAME_MAP` | `factory.py` | 平台名称映射 |

### 8.3 调试命令

```bash
# 查看最近的 AI 响应日志
python backend_python/view_ai_responses_v2.py view 10

# 查看统计信息
python backend_python/view_ai_responses_v2.py stats 7

# 导出日志用于分析
python backend_python/view_ai_responses_v2.py export backup.json 10000
```

---

**文档结束**
