ç³»ç»Ÿç¨³å®šæ€§ä¿®å¤å®æ–½æ‰‹å†Œ (v1.0)
æ‰§è¡ŒåŸåˆ™ï¼š

å®‰å…¨ç¬¬ä¸€ï¼šå…ˆè½®æ¢å¯†é’¥ï¼Œå†ä¿®ä»£ç ã€‚
æ•°æ®ä¼˜å…ˆï¼šå…ˆæ”¹æ•°æ®åº“ï¼Œå†æ”¹ä»£ç ã€‚
é˜²å¾¡æ€§ç¼–ç¨‹ï¼šæ‰€æœ‰å¤–éƒ¨è¾“å…¥/ä¾èµ–è¿”å›å¿…é¡»æ ¡éªŒã€‚
éªŒè¯é—­ç¯ï¼šæ¯ä¸€æ­¥ä¿®å¤åå¿…é¡»è¿è¡ŒéªŒè¯æµ‹è¯•ã€‚
ğŸš¨ Phase 0: å®‰å…¨ç´§æ€¥å“åº” (ç«‹å³æ‰§è¡Œ)
ç›®æ ‡ï¼š æ¶ˆé™¤æ—¥å¿—ä¸­æ³„éœ²çš„æ•æ„Ÿå‡­è¯é£é™©ã€‚ æ“ä½œäººï¼š è¿ç»´/æ¶æ„å¸ˆ AI å‚ä¸åº¦ï¼š æ—  (äººå·¥æ“ä½œ)

æ­¥éª¤	æ“ä½œå†…å®¹	éªŒè¯æ ‡å‡†
0-1	è½®æ¢æ‰€æœ‰æ³„éœ²çš„ API Key<br>1. ç«å±±å¼•æ“ (Doubao/ARK)<br>2. å¾®ä¿¡ (AppSecret)<br>3. Google (Gemini)<br>4. é˜¿é‡Œäº‘ (DashScope)	æ—§ Key ç«‹å³å¤±æ•ˆï¼Œæ–° Key åœ¨é…ç½®ä¸­å¿ƒæ›´æ–°æˆåŠŸã€‚
0-2	æ¸…ç†æ—¥å¿—å†å²<br>åˆ é™¤æˆ–è„±æ•åŒ…å« Key çš„æ—¥å¿—æ–‡ä»¶ã€‚	æ—¥å¿—æ–‡ä»¶ä¸­ä¸å†åŒ…å«æ˜æ–‡ Keyã€‚
0-3	é…ç½®è„±æ•ä¸­é—´ä»¶<br>ç¡®ä¿åç»­æ—¥å¿—è‡ªåŠ¨è¿‡æ»¤ KEY, SECRET, TOKEN å­—æ®µã€‚	æ–°äº§ç”Ÿçš„æ—¥å¿—ä¸­æ•æ„Ÿå­—æ®µæ˜¾ç¤ºä¸º ***ã€‚
ğŸ—ï¸ Phase 1: åŸºç¡€è®¾æ–½ä¸é…ç½®ä¿®å¤ (P0)
ç›®æ ‡ï¼š è§£å†³æ•°æ®åº“ç»“æ„ä¸ä¸€è‡´å’Œè¶…æ—¶é…ç½®è¿‡ä½é—®é¢˜ï¼Œä¸ºä»£ç è¿è¡Œé“ºå¹³é“è·¯ã€‚

æ­¥éª¤ 1-1: æ•°æ®åº“ Schema è¿ç§»
æ¶‰åŠæ–‡ä»¶ï¼š wechat_backend/database/task_status_repository.py, æ•°æ®åº“
AI æç¤ºè¯ (Prompt):
# Role: Database Architect
# Task: Fix Database Schema Mismatch
# Context: Logs show error "table task_statuses has no column named completed_count".
# Action:
1. Analyze `wechat_backend/database/task_status_repository.py` to understand the `task_statuses` table structure.
2. Generate a SQL migration script (or Alembic migration) to add the following columns to `task_statuses` table:
   - `completed_count` (Integer, Default: 0, Nullable: False)
   - `total_count` (Integer, Default: 0, Nullable: False)
3. If using SQLAlchemy, update the Model class definition to reflect these new columns.
4. Ensure the migration is idempotent (safe to run multiple times).
# Constraint: Do not drop any existing data.
éªŒè¯ï¼š æ‰§è¡Œè¿ç§»è„šæœ¬ï¼Œç¡®è®¤ task_statuses è¡¨åŒ…å«æ–°å­—æ®µã€‚
æ­¥éª¤ 1-2: è°ƒæ•´ AI è¶…æ—¶é…ç½®
æ¶‰åŠæ–‡ä»¶ï¼š wechat_backend/api/qwen_adapter.py, wechat_backend/hot_reload_config.py
AI æç¤ºè¯ (Prompt):
# Role: Backend Engineer
# Task: Increase AI API Timeout Thresholds
# Context: Logs show Qwen API takes 43-55s, but current timeout is 30s, causing false failures.
# Action:
1. In `wechat_backend/hot_reload_config.py`, add/update configuration for `AI_REQUEST_TIMEOUT` (Global) to 60 seconds.
2. In `wechat_backend/api/qwen_adapter.py`, specifically set the timeout for Qwen model requests to 90 seconds.
3. Ensure these values are loaded from environment variables or config file, not hardcoded.
4. Check if there is a `fault_tolerant_executor.py` or similar timeout wrapper and update its threshold accordingly.
# Constraint: Maintain existing retry logic, only change timeout duration.
éªŒè¯ï¼š ä¿®æ”¹é…ç½®åé‡å¯æœåŠ¡ï¼Œæ£€æŸ¥æ—¥å¿—ç¡®è®¤æ–°è¶…æ—¶æ—¶é—´ç”Ÿæ•ˆã€‚
ğŸ› ï¸ Phase 2: æ ¸å¿ƒé€»è¾‘å´©æºƒä¿®å¤ (P0)
ç›®æ ‡ï¼š ä¿®å¤å¯¼è‡´ç³»ç»Ÿç›´æ¥å´©æºƒçš„ç©ºæŒ‡é’ˆå’Œé€»è¾‘é”™è¯¯ã€‚

æ­¥éª¤ 2-1: ä¿®å¤ç»“æœèšåˆç©ºæŒ‡é’ˆå¼‚å¸¸
æ¶‰åŠæ–‡ä»¶ï¼š wechat_backend/nxm_result_aggregator.py
AI æç¤ºè¯ (Prompt):
# Role: Python Developer
# Task: Fix AttributeError in Result Aggregation
# Context: Log error: "AttributeError: 'NoneType' object has no attribute 'get'" in `calculate_result_quality`.
# Location: `wechat_backend/nxm_result_aggregator.py`, function `calculate_result_quality`, line ~184.
# Action:
1. Locate the line accessing `geo_data.get('brand_mentioned')`.
2. Add a defensive check: `if geo_data is not None and isinstance(geo_data, dict):`.
3. If `geo_data` is None, return a default quality score or skip the calculation gracefully without crashing.
4. Search the entire file for similar `.get()` calls on potentially None objects and apply the same fix.
# Constraint: Do not change the return type of the function.
éªŒè¯ï¼š æ¨¡æ‹Ÿ AI è¿”å›ç©ºæ•°æ®ï¼Œè¿è¡Œèšåˆé€»è¾‘ï¼Œç¡®è®¤æ— æŠ¥é”™ã€‚
æ­¥éª¤ 2-2: æ ‡å‡†åŒ–å¤±è´¥æ•°æ®å¯¹è±¡
æ¶‰åŠæ–‡ä»¶ï¼š wechat_backend/nxm_execution_engine.py
AI æç¤ºè¯ (Prompt):
# Role: System Architect
# Task: Standardize Failure Data Objects
# Context: When AI calls fail/timeout, downstream code receives None, causing crashes.
# Location: `wechat_backend/nxm_execution_engine.py`, where AI results are collected.
# Action:
1. Identify where AI task results are stored.
2. When a task fails (timeout/exception), do NOT store `None`.
3. Instead, store a standardized dictionary object: `{'status': 'failed', 'error': 'timeout', 'geo_data': None, 'content': ''}`.
4. Ensure this structure matches what `nxm_result_aggregator.py` expects.
# Constraint: Ensure this change is compatible with existing success path data structure.
éªŒè¯ï¼š è§¦å‘ä¸€æ¬¡ AI è¶…æ—¶ï¼Œæ£€æŸ¥ç”Ÿæˆçš„ç»“æœå¯¹è±¡æ˜¯å¦ç¬¦åˆæ–°ç»“æ„ã€‚
ğŸ§± Phase 3: å¼‚å¸¸å¤„ç†é“¾åŠ å›º (P1)
ç›®æ ‡ï¼š ç¡®ä¿â€œæŠ¥é”™æ—¶ä¸ä¼šå´©å¾—æ›´å‰å®³â€ï¼Œä¿®å¤é”™è¯¯å¤„ç†ä»£ç æœ¬èº«çš„ Bugã€‚

æ­¥éª¤ 3-1: ä¿®å¤çŠ¶æ€ç®¡ç†å™¨å¯¼å…¥ä½œç”¨åŸŸ
æ¶‰åŠæ–‡ä»¶ï¼š wechat_backend/diagnosis_views.py
AI æç¤ºè¯ (Prompt):
# Role: Python Developer
# Task: Fix Import Scope Error in Exception Handler
# Context: Log error: "cannot access local variable 'get_state_manager' where it is not associated with a value".
# Location: `wechat_backend/diagnosis_views.py`, inside `run_async_test` function, specifically in the `except` block.
# Action:
1. Find where `get_state_manager` is imported or defined.
2. Move the import statement to the top of the file (module level).
3. Ensure it is accessible within the `except` block where `fail_execution` is called.
4. Check for any other variables used in the `except` block that might be undefined if the error happens early.
# Constraint: Do not change the logic of the exception handling, only fix the scope.
éªŒè¯ï¼š äººä¸ºæŠ›å‡ºå¼‚å¸¸ï¼Œç¡®è®¤ except å—èƒ½æ­£å¸¸æ‰§è¡Œä¸”ä¸æŠ¥ NameErrorã€‚
æ­¥éª¤ 3-2: ä¿®å¤é”™è¯¯æŠ¥å‘Šä¿å­˜å‚æ•°
æ¶‰åŠæ–‡ä»¶ï¼š wechat_backend/diagnosis_views.py, wechat_backend/database/diagnosis_report_service.py
AI æç¤ºè¯ (Prompt):
# Role: Backend Engineer
# Task: Fix Function Signature Mismatch
# Context: Log error: "save_diagnosis_report() got an unexpected keyword argument 'error_message'".
# Location: Call site in `wechat_backend/diagnosis_views.py` and definition in `wechat_backend/database/diagnosis_report_service.py`.
# Action:
1. Check the definition of `save_diagnosis_report` in `diagnosis_report_service.py`.
2. Option A: Add `error_message` parameter to the function definition and handle it (e.g., save to DB).
3. Option B: If the parameter is not needed, remove it from the call site in `diagnosis_views.py`.
4. Prefer Option A to preserve error information.
5. Search for all calls to `save_diagnosis_report` to ensure consistency.
# Constraint: Ensure database schema supports storing error messages if Option A is chosen.
éªŒè¯ï¼š è§¦å‘é”™è¯¯ä¿å­˜æµç¨‹ï¼Œç¡®è®¤æ—  TypeErrorã€‚
ğŸ§¹ Phase 4: è¿è¡Œç¯å¢ƒä¸æ—¥å¿—æ²»ç† (P2)
ç›®æ ‡ï¼š æ¶ˆé™¤ä¸Šä¸‹æ–‡ç¼ºå¤±è­¦å‘Šï¼Œæ¸…ç†æ—¥å¿—å™ªéŸ³ã€‚

æ­¥éª¤ 4-1: ä¿®å¤ Flask åº”ç”¨ä¸Šä¸‹æ–‡ç¼ºå¤±
æ¶‰åŠæ–‡ä»¶ï¼š wechat_backend/diagnosis_views.py (Async tasks), wechat_backend/api/qwen_adapter.py
AI æç¤ºè¯ (Prompt):
# Role: Flask Developer
# Task: Fix Application Context in Async Tasks
# Context: Log warning: "Working outside of application context". Happens in background threads/tasks.
# Location: `wechat_backend/diagnosis_views.py` (async functions) and logging calls in adapters.
# Action:
1. Identify async functions (e.g., `run_async_test` or tasks spawned within it).
2. Wrap the core logic of these async tasks with `with app.app_context():`.
3. Alternatively, if using a specific logger, ensure the logger is initialized outside the Flask context dependency.
4. Specifically check `qwen_adapter.py` where "Failed to log response" warning appears.
# Constraint: Ensure `app` is imported correctly in the file.
éªŒè¯ï¼š è¿è¡Œå¼‚æ­¥ä»»åŠ¡ï¼Œæ£€æŸ¥æ—¥å¿—ä¸å†å‡ºç° "Working outside of application context"ã€‚
æ­¥éª¤ 4-2: æ¸…ç†æ—¥å¿—çº§åˆ«ä¸æ•æ„Ÿä¿¡æ¯
æ¶‰åŠæ–‡ä»¶ï¼š wechat_backend/api/factory.py, wechat_backend/hot_reload_config.py
AI æç¤ºè¯ (Prompt):
# Role: DevOps Engineer
# Task: Clean Up Log Levels and Sensitive Data
# Context: Logs show ERROR level for normal info, and print API Keys.
# Location: `wechat_backend/api/factory.py` (REGISTERED_MODELS), `hot_reload_config.py`.
# Action:
1. In `factory.py`, change `logger.error("REGISTERED_MODELS...")` to `logger.debug` or `logger.info`.
2. In `hot_reload_config.py`, ensure that when logging config changes, values for keys containing "KEY", "SECRET", "TOKEN" are masked (e.g., show "2a37***9f92").
3. Implement a helper function `mask_sensitive_value(key, value)` to handle this globally.
# Constraint: Do not remove the logs entirely, just adjust level and content.
éªŒè¯ï¼š é‡å¯æœåŠ¡ï¼Œç¡®è®¤æ—¥å¿—çº§åˆ«æ­£å¸¸ï¼Œæ— æ˜æ–‡å¯†é’¥ã€‚
âœ… Phase 5: æœ€ç»ˆéªŒè¯ä¸éªŒæ”¶
ç›®æ ‡ï¼š ç¡®è®¤æ‰€æœ‰ä¿®å¤ç”Ÿæ•ˆï¼Œç³»ç»Ÿç¨³å®šã€‚

éªŒè¯é¡¹	æµ‹è¯•æ–¹æ³•	é¢„æœŸç»“æœ
DB ä¸€è‡´æ€§	æ’å…¥ä¸€æ¡æ–°ä»»åŠ¡ï¼ŒæŸ¥è¯¢ DB	task_statuses è¡¨æœ‰ completed_count ä¸”å€¼æ­£ç¡®ã€‚
è¶…æ—¶å®¹å¿	æ¨¡æ‹Ÿ Qwen æ¥å£å»¶è¿Ÿ 50s	ç³»ç»Ÿç­‰å¾…å¹¶æˆåŠŸè¿”å›ï¼Œæˆ–æ ‡è®°ä¸ºè¶…æ—¶ä½†ä¸å´©æºƒã€‚
ç©ºå€¼é˜²å¾¡	æ¨¡æ‹Ÿ AI è¿”å› geo_data: null	ç³»ç»Ÿè·³è¿‡è´¨é‡è®¡ç®—ï¼Œä»»åŠ¡çŠ¶æ€ä¸º partial_success æˆ– failedï¼Œæ— æŠ¥é”™ã€‚
å¼‚å¸¸æ•è·	æ‰‹åŠ¨æŠ›å‡ºå¼‚å¸¸	é”™è¯¯è¢«è®°å½•ï¼ŒçŠ¶æ€åŒæ­¥æˆåŠŸï¼Œæ—  AttributeErrorã€‚
æ—¥å¿—å®‰å…¨	è§¦å‘é…ç½®åŠ è½½	æ—¥å¿—ä¸­ API Key æ˜¾ç¤ºä¸º ***ã€‚
ğŸ’¡ ç»™æ‰§è¡Œè€…çš„å»ºè®®
åˆ†æ”¯ç®¡ç†ï¼š è¯·åœ¨ fix/stability-20260227 åˆ†æ”¯ä¸Šè¿›è¡Œæ‰€æœ‰ä¿®æ”¹ï¼Œåˆå¹¶å‰éœ€é€šè¿‡ CIã€‚
æäº¤è§„èŒƒï¼š æ¯ä¸ª Phase å®Œæˆåå•ç‹¬ Commitï¼Œæ³¨é‡Šä¸­å¼•ç”¨æœ¬è®¡åˆ’ç¼–å·ï¼ˆå¦‚ Fix: Phase 2-1 NullPointerï¼‰ã€‚
å›æ»šè®¡åˆ’ï¼š å¦‚æœ Phase 1 æ•°æ®åº“è¿ç§»å¤±è´¥ï¼Œç«‹å³æ¢å¤å¤‡ä»½ï¼›å¦‚æœä»£ç ä¿®å¤å¯¼è‡´æ–° Bugï¼Œç«‹å³å›æ»šè‡³ Phase 0 åçš„çŠ¶æ€ã€‚