# 诊断逻辑需求差异分析与修复计划

**分析日期**: 2026-02-27  
**问题发现**: 用户输入 1 个品牌、1 个问题、2 个 AI 平台，实际请求次数远超 2 次  

---

## 一、问题描述

### 1.1 用户需求

```
用户输入:
- 品牌（1 个）：趣车良品
- 自定义问题（1 个）：深圳新能源汽车改装门店哪家好
- AI 平台（2 个）：doubao, qwen
- 竞品品牌：无（用户未选择）

期望行为:
1. 发起 AI 请求：1 问题 × 2AI 平台 = 2 次请求
2. 保存完整响应到数据库（2 条记录）
3. 分析用户品牌在答案中的出现情况、排名
4. 与竞品品牌对比（若无竞品，则与答案中前 3 名对比）
5. 输出对比分析结果
```

### 1.2 实际行为

**当前代码逻辑**（`nxm_execution_engine.py` 第 251-281 行）:

```python
# 外层循环：遍历品牌（主品牌 + 竞品）
all_brands = [main_brand] + (competitor_brands or [])
api_logger.info(f"[NxM] 执行品牌数：{len(all_brands)}, 品牌列表：{all_brands}")

for brand in all_brands:  # ← 遍历所有品牌
    for q_idx, question in enumerate(raw_questions):  # ← 遍历所有问题
        for model_info in selected_models:  # ← 遍历所有模型
            # 发起 AI 请求
            ai_result = run_async_in_thread(
                ai_executor.execute_with_fallback(
                    task_func=client.send_prompt,
                    task_name=f"{brand}-{model_name}",
                    source=model_name,
                    prompt=prompt
                )
            )
```

**实际请求次数计算**:
```
实际请求 = 品牌数 × 问题数 × AI 平台数
        = (1 主品牌 + 0 竞品) × 1 问题 × 2AI 平台
        = 1 × 1 × 2
        = 2 次请求 ✓ （这个案例正确）
```

**但问题在于提示词内容**:
```python
# 当前提示词（第 281 行）
prompt = GEO_PROMPT_TEMPLATE.format(
    brand_name=brand,  # ← 每次循环的品牌
    competitors=', '.join(current_competitors),  # ← 其他品牌作为竞品
    question=question
)
```

**实际发起的 2 次请求内容**:

| 请求 | brand_name | competitors | question |
|------|-----------|-------------|----------|
| 1 | 趣车良品 | 无 | 深圳新能源汽车改装门店哪家好 |
| 2 | 趣车良品 | 无 | 深圳新能源汽车改装门店哪家好 |

**问题**: 虽然请求次数正确（2 次），但**提示词设计不符合需求**！

---

## 二、需求对比分析

### 2.1 需求流程

```
┌─────────────────────────────────────────────────────────────┐
│ 步骤 1: 获取 AI 响应（1 问题 × 2AI 平台 = 2 次请求）            │
│ - 提问：深圳新能源汽车改装门店哪家好                          │
│ - 平台：doubao, qwen                                         │
│ - 不指定品牌，获取客观推荐                                   │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 2: 保存完整响应（2 条记录）                                │
│ - 存储完整的 API 响应（包括 tokens、finish_reason 等）        │
│ - 存储 AI 原始回答内容                                        │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 3: 分析品牌提及情况                                      │
│ - 从 doubao 回答中提取：趣车良品是否被提及、排名、情感        │
│ - 从 qwen 回答中提取：趣车良品是否被提及、排名、情感          │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 4: 竞品对比分析                                         │
│ - 若用户未指定竞品，提取每个答案中的前 3 名作为竞品            │
│ - 对比用户品牌与竞品的排名、情感、提及次数                   │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 5: 生成诊断报告                                         │
│ - 露出情况：2 个 AI 平台中提及用户品牌的次数/比例              │
│ - 排名对比：用户品牌平均排名 vs 竞品平均排名                 │
│ - 情感对比：用户品牌平均情感分 vs 竞品平均情感分             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 当前实现流程

```
┌─────────────────────────────────────────────────────────────┐
│ 步骤 1: 遍历品牌（主品牌 + 竞品）发起 AI 请求                   │
│ - 对每个品牌都发起独立的 AI 请求                              │
│ - 提示词：请比较{brand_name}和{competitors}                   │
│ - 问题：1 问题 × (1 主品牌 +0 竞品) × 2AI 平台 = 2 次请求       │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 2: 保存响应                                             │
│ - 保存每个品牌×问题的响应                                   │
│ - 问题：保存的是"比较型"回答，不是客观推荐                   │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤 3: GEO 分析（已在 AI 调用时完成）                         │
│ - AI 直接返回品牌提及、排名、情感                             │
│ - 问题：分析的是"比较型"回答，不是客观推荐                   │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 核心差异

| 维度 | 需求 | 当前实现 | 差异 |
|------|------|---------|------|
| **请求对象** | 客观问题（不指定品牌） | 比较型问题（指定品牌 vs 竞品） | ❌ |
| **提示词** | "深圳新能源汽车改装门店哪家好" | "请比较趣车良品和无" | ❌ |
| **分析时机** | AI 响应后分析 | AI 调用时直接分析 | ⚠️ |
| **竞品对比** | 提取答案中前 3 名 | 用户指定的竞品 | ❌ |
| **数据客观性** | 客观第三方推荐 | 带有品牌倾向的比较 | ❌ |

---

## 三、问题根因

### 3.1 设计问题

**根因**: 当前实现基于"品牌对比"思维，而非"客观诊断"思维

**错误假设**:
```
错误：用户想知道"我的品牌 vs 竞品"的表现
正确：用户想知道"在客观推荐中"我的品牌表现如何
```

### 3.2 代码问题

**问题 1: 提示词设计错误**
```python
# 当前（错误）
GEO_PROMPT_TEMPLATE = """
用户品牌：{brand_name}
竞争对手：{competitors}
请回答以下用户问题：{question}
"""
# 这会引导 AI 进行品牌对比，而非客观推荐

# 应该（正确）
OBJECTIVE_PROMPT_TEMPLATE = """
请回答以下用户问题：{question}
要求：请客观推荐，不要有品牌倾向
"""
```

**问题 2: 品牌遍历逻辑多余**
```python
# 当前（错误）- 对每个品牌都发起请求
all_brands = [main_brand] + (competitor_brands or [])
for brand in all_brands:
    # 发起 AI 请求

# 应该（正确）- 只发起一次客观问题请求
for question in raw_questions:
    for model in selected_models:
        # 发起客观问题请求
```

**问题 3: 竞品处理逻辑错误**
```python
# 当前（错误）- 竞品用于 AI 请求
current_competitors = [b for b in all_brands if b != brand]
prompt = GEO_PROMPT_TEMPLATE.format(
    brand_name=brand,
    competitors=', '.join(current_competitors),
    question=question
)

# 应该（正确）- 竞品从答案中提取
# 步骤 1: 获取客观回答
# 步骤 2: 从回答中提取前 3 名作为竞品
# 步骤 3: 对比用户品牌与竞品的排名
```

---

## 四、修复计划

### 4.1 总体方案

**阶段一：修改提示词设计（P0）**
- 移除品牌倾向性提示
- 改为客观问题提问

**阶段二：修改请求逻辑（P0）**
- 移除品牌遍历循环
- 只对"问题×AI 平台"发起请求

**阶段三：添加后置分析（P1）**
- 从 AI 回答中提取品牌提及
- 提取前 3 名作为竞品
- 对比分析

**阶段四：更新数据存储（P1）**
- 存储客观回答
- 存储分析结果
- 存储竞品对比

### 4.2 详细修改计划

#### 修改 1: 提示词模板（P0）

**文件**: `wechat_backend/ai_adapters/base_adapter.py`

**修改前**:
```python
GEO_PROMPT_TEMPLATE = """
用户品牌：{brand_name}
竞争对手：{competitors}

请回答以下用户问题：
{question}

---
重要要求：
1. 请以专业顾问的身份客观回答。
2. 在回答结束后，必须另起一行，以严格的 JSON 格式输出以下字段...
"""
```

**修改后**:
```python
# 客观问题提示词（用于获取 AI 回答）
OBJECTIVE_QUESTION_TEMPLATE = """
请回答以下用户问题：
{question}

---
重要要求：
1. 请以专业顾问的身份客观回答。
2. 请列出您推荐的 TOP3 品牌/门店，并说明理由。
3. 在回答结束后，必须另起一行，以严格的 JSON 格式输出以下字段（不要包含在 Markdown 代码块中）：
{{
  "top3_brands": [
    {{"name": "品牌 1", "rank": 1, "reason": "推荐理由 1"}},
    {{"name": "品牌 2", "rank": 2, "reason": "推荐理由 2"}},
    {{"name": "品牌 3", "rank": 3, "reason": "推荐理由 3"}}
  ],
  "total_brands_mentioned": 5
}}
"""

# 品牌分析提示词（用于分析 AI 回答）
BRAND_ANALYSIS_TEMPLATE = """
以下是 AI 对问题"{question}"的回答：
{ai_response}

用户关注的品牌：{user_brand}

请分析该品牌在回答中的表现：
1. 是否被提及（brand_mentioned: true/false）
2. 排名是多少（rank: 1-10，未提及为 -1）
3. 情感倾向（sentiment: -1.0 到 1.0）
4. 是否被推荐为 TOP3（is_top3: true/false）

请以 JSON 格式输出：
{{
  "brand_analysis": {{
    "brand_mentioned": boolean,
    "rank": number,
    "sentiment": number,
    "is_top3": boolean,
    "mention_context": "提及的上下文"
  }}
}}
"""
```

#### 修改 2: 执行引擎（P0）

**文件**: `wechat_backend/nxm_execution_engine.py`

**修改前**:
```python
def execute_nxm_test(execution_id, main_brand, competitor_brands, ...):
    all_brands = [main_brand] + (competitor_brands or [])
    
    # 外层循环：遍历品牌
    for brand in all_brands:
        # 中层循环：遍历问题
        for question in raw_questions:
            # 内层循环：遍历模型
            for model in selected_models:
                # 发起 AI 请求
```

**修改后**:
```python
def execute_nxm_test(execution_id, main_brand, competitor_brands, ...):
    # 修复：只遍历问题和模型，不遍历品牌
    # 请求次数 = 问题数 × AI 平台数
    
    total_tasks = len(raw_questions) * len(selected_models)
    
    # 外层循环：遍历问题
    for q_idx, question in enumerate(raw_questions):
        # 内层循环：遍历模型
        for model_info in selected_models:
            model_name = model_info.get('name', '')
            
            # 构建客观问题提示词
            prompt = OBJECTIVE_QUESTION_TEMPLATE.format(
                question=question
            )
            
            # 发起 AI 请求
            ai_result = run_async_in_thread(
                ai_executor.execute_with_fallback(
                    task_func=client.send_prompt,
                    task_name=f"Q{q_idx}-{model_name}",
                    source=model_name,
                    prompt=prompt
                )
            )
            
            # 保存客观回答
            result = {
                'question': question,
                'model': model_name,
                'response': ai_result.data,
                'is_objective': True  # 标记为客观回答
            }
            results.append(result)
    
    # 后置分析：分析品牌提及
    analysis_results = analyze_brand_mentions(
        results=results,
        user_brand=main_brand,
        competitor_brands=competitor_brands
    )
    
    return {
        'success': True,
        'results': results,
        'analysis': analysis_results,
        'formula': f"{len(raw_questions)}问题 × {len(selected_models)}模型 = {len(results)}次请求"
    }
```

#### 修改 3: 添加后置分析模块（P1）

**新文件**: `wechat_backend/services/brand_analysis_service.py`

```python
"""
品牌分析服务

职责：
1. 从 AI 客观回答中提取品牌提及
2. 提取 TOP3 品牌作为竞品
3. 对比用户品牌与竞品表现
"""

import json
import re
from typing import List, Dict, Any
from wechat_backend.ai_adapters.base_adapter import BRAND_ANALYSIS_TEMPLATE
from wechat_backend.ai_adapters.factory import AIAdapterFactory


class BrandAnalysisService:
    """品牌分析服务"""
    
    def __init__(self):
        self.judge_model = 'doubao'  # 使用 doubao 作为分析模型
    
    def analyze_brand_mentions(
        self,
        results: List[Dict[str, Any]],
        user_brand: str,
        competitor_brands: List[str] = None
    ) -> Dict[str, Any]:
        """
        分析品牌提及情况
        
        Args:
            results: AI 回答列表
            user_brand: 用户品牌
            competitor_brands: 竞品品牌（可选，若为 None 则从回答中提取）
        
        Returns:
            分析结果
        """
        analysis = {
            'user_brand_analysis': {},
            'competitor_analysis': [],
            'comparison': {}
        }
        
        # 步骤 1: 从每个回答中提取 TOP3 品牌
        all_top3_brands = []
        for result in results:
            top3 = self._extract_top3_brands(result['response'])
            all_top3_brands.extend(top3)
        
        # 步骤 2: 若未指定竞品，使用 TOP3 品牌作为竞品
        if not competitor_brands:
            competitor_brands = list(set([b['name'] for b in all_top3_brands if b['name'] != user_brand]))[:3]
        
        # 步骤 3: 分析用户品牌在每个回答中的表现
        user_brand_mentions = []
        for result in results:
            mention = self._analyze_brand_in_response(
                response=result['response'],
                brand=user_brand,
                question=result['question']
            )
            user_brand_mentions.append(mention)
        
        analysis['user_brand_analysis'] = {
            'brand': user_brand,
            'mentions': user_brand_mentions,
            'mentioned_count': sum(1 for m in user_brand_mentions if m['brand_mentioned']),
            'total_responses': len(results),
            'mention_rate': sum(1 for m in user_brand_mentions if m['brand_mentioned']) / len(results),
            'average_rank': self._calc_average_rank(user_brand_mentions),
            'average_sentiment': self._calc_average_sentiment(user_brand_mentions)
        }
        
        # 步骤 4: 分析竞品品牌
        for competitor in competitor_brands:
            competitor_mentions = []
            for result in results:
                mention = self._analyze_brand_in_response(
                    response=result['response'],
                    brand=competitor,
                    question=result['question']
                )
                competitor_mentions.append(mention)
            
            analysis['competitor_analysis'].append({
                'brand': competitor,
                'mentions': competitor_mentions,
                'mentioned_count': sum(1 for m in competitor_mentions if m['brand_mentioned']),
                'average_rank': self._calc_average_rank(competitor_mentions),
                'average_sentiment': self._calc_average_sentiment(competitor_mentions)
            })
        
        # 步骤 5: 对比分析
        analysis['comparison'] = self._generate_comparison(
            user_analysis=analysis['user_brand_analysis'],
            competitor_analyses=analysis['competitor_analysis']
        )
        
        return analysis
    
    def _extract_top3_brands(self, response: str) -> List[Dict[str, Any]]:
        """从回答中提取 TOP3 品牌"""
        # 尝试解析 JSON 格式的 top3_brands
        try:
            # 查找 JSON 部分
            json_match = re.search(r'\{.*"top3_brands".*\}', response, re.DOTALL)
            if json_match:
                data = json.loads(json_match.group())
                return data.get('top3_brands', [])
        except:
            pass
        
        # 降级：使用正则提取
        return []
    
    def _analyze_brand_in_response(
        self,
        response: str,
        brand: str,
        question: str
    ) -> Dict[str, Any]:
        """分析品牌在回答中的表现"""
        # 使用 AI 分析
        client = AIAdapterFactory.create(self.judge_model)
        prompt = BRAND_ANALYSIS_TEMPLATE.format(
            ai_response=response,
            user_brand=brand,
            question=question
        )
        
        result = client.send_prompt(prompt)
        
        # 解析分析结果
        try:
            json_match = re.search(r'\{.*"brand_analysis".*\}', result.data, re.DOTALL)
            if json_match:
                data = json.loads(json_match.group())
                analysis = data.get('brand_analysis', {})
                return {
                    'brand_mentioned': analysis.get('brand_mentioned', False),
                    'rank': analysis.get('rank', -1),
                    'sentiment': analysis.get('sentiment', 0),
                    'is_top3': analysis.get('is_top3', False),
                    'mention_context': analysis.get('mention_context', '')
                }
        except:
            pass
        
        # 降级：简单文本匹配
        mentioned = brand.lower() in response.lower()
        return {
            'brand_mentioned': mentioned,
            'rank': -1 if not mentioned else 0,
            'sentiment': 0,
            'is_top3': False,
            'mention_context': ''
        }
    
    def _calc_average_rank(self, mentions: List[Dict]) -> float:
        """计算平均排名"""
        ranks = [m['rank'] for m in mentions if m['rank'] > 0]
        return sum(ranks) / len(ranks) if ranks else -1
    
    def _calc_average_sentiment(self, mentions: List[Dict]) -> float:
        """计算平均情感分"""
        sentiments = [m['sentiment'] for m in mentions if m['brand_mentioned']]
        return sum(sentiments) / len(sentiments) if sentiments else 0
    
    def _generate_comparison(
        self,
        user_analysis: Dict,
        competitor_analyses: List[Dict]
    ) -> Dict[str, Any]:
        """生成对比分析"""
        return {
            'user_brand': user_analysis['brand'],
            'mention_rate': user_analysis['mention_rate'],
            'average_rank': user_analysis['average_rank'],
            'average_sentiment': user_analysis['average_sentiment'],
            'vs_competitors': [
                {
                    'competitor': comp['brand'],
                    'mention_rate_diff': user_analysis['mention_rate'] - (comp['mentioned_count'] / len(comp['mentions'])),
                    'rank_diff': user_analysis['average_rank'] - comp['average_rank'],
                    'sentiment_diff': user_analysis['average_sentiment'] - comp['average_sentiment']
                }
                for comp in competitor_analyses
            ]
        }


def get_brand_analysis_service() -> BrandAnalysisService:
    """获取品牌分析服务实例"""
    return BrandAnalysisService()
```

#### 修改 4: 更新数据存储（P1）

**修改**: `wechat_backend/diagnosis_report_repository.py`

添加新的存储方法：
```python
def save_brand_analysis(
    self,
    report_id: int,
    execution_id: str,
    analysis: Dict[str, Any]
) -> int:
    """保存品牌分析结果"""
    now = datetime.now().isoformat()
    
    with self.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO diagnosis_analysis (
                report_id, execution_id,
                analysis_type, analysis_data,
                created_at
            ) VALUES (?, ?, ?, ?, ?)
        ''', (
            report_id,
            execution_id,
            'brand_analysis',
            json.dumps(analysis, ensure_ascii=False),
            now
        ))
        
        return cursor.lastrowid
```

---

## 五、修改优先级

| 优先级 | 修改项 | 预计工作量 | 影响范围 |
|--------|--------|-----------|---------|
| P0 | 修改提示词模板 | 2 小时 | 所有 AI 请求 |
| P0 | 修改执行引擎循环逻辑 | 4 小时 | 核心执行流程 |
| P1 | 添加品牌分析服务 | 8 小时 | 新增模块 |
| P1 | 更新数据存储 | 2 小时 | 数据库 schema |
| P2 | 前端展示更新 | 4 小时 | 报告页面 |

---

## 六、测试计划

### 6.1 单元测试

- [ ] 测试客观问题提示词生成
- [ ] 测试品牌提及分析
- [ ] 测试 TOP3 品牌提取
- [ ] 测试对比分析生成

### 6.2 集成测试

- [ ] 测试完整诊断流程（1 问题×2AI）
- [ ] 测试数据库存储
- [ ] 测试报告生成

### 6.3 验收标准

- [ ] 请求次数 = 问题数 × AI 平台数
- [ ] 提示词无品牌倾向
- [ ] 能正确提取 TOP3 品牌
- [ ] 能正确分析用户品牌提及
- [ ] 能生成对比分析报告

---

## 七、回滚方案

若修改后出现问题，可通过特性开关快速回滚：

```python
# wechat_backend/v2/feature_flags.py
FEATURE_FLAGS = {
    'use_objective_question': False,  # 设为 False 回滚到旧逻辑
    'use_brand_analysis_service': False,
}
```

---

**制定人**: 系统架构组  
**日期**: 2026-02-27  
**版本**: v1.0
